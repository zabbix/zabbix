/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
/**
 * A special note for Zabbix users:
 *    This file has been generated from file
 *    apache-cassandra-1.0.7-src/interface/cassandra.thrift
 *    by an IN-HOUSE PATCHED Thrift Compiler 0.7.0.
 *    Thrift was patched as suggested in a comment by Jerry Gally, 16/Oct/11 20:20
 *    at https://issues.apache.org/jira/browse/THRIFT-1389
 *    to prevent a large memory leak:
 * ------------------------------------------------
 * The following change to t_c_glib_generator.cc appears to fix the leak:
 *
 *1733c1733
 *< indent(f_types_impl_) << "object->" << name << " = g_object_new (" << this->nspace_uc << "TYPE_" << type_name_uc << ", NULL);" << endl;
 *--
 *> indent(f_types_impl_) << "object->" << name << " = NULL;" << endl;
 *------------------------------------------------
 */

#include "cassandra_types.h"
#include <thrift.h>

/* constants */

/* reads a column object */
gint32
column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Column * this_object = COLUMN(object);
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->ttl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ttl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Column * this_object = COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Column", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->name)->data, ((GByteArray *) this_object->name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->value)->data, ((GByteArray *) this_object->value)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ttl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ttl", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->ttl, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
column_instance_init (Column * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->ttl = 0;
  object->__isset_ttl = FALSE;
}

void 
column_finalize (GObject *object)
{
  Column *tobject = COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
column_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = column_finalize;
  cls->read = column_read;
  cls->write = column_write;
}

GType
column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Column),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a super_column object */
gint32
super_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SuperColumn * this_object = SUPER_COLUMN(object);
  gboolean isset_name = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              Column * _elem0;
              _elem0 = g_object_new (TYPE_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
super_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SuperColumn * this_object = SUPER_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SuperColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->name)->data, ((GByteArray *) this_object->name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->columns->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->columns->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->columns, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
super_column_instance_init (SuperColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->columns = g_ptr_array_new();
}

void 
super_column_finalize (GObject *object)
{
  SuperColumn *tobject = SUPER_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->columns, FALSE);
}

void 
super_column_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = super_column_finalize;
  cls->read = super_column_read;
  cls->write = super_column_write;
}

GType
super_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SuperColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) super_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SuperColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) super_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SuperColumnType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a counter_column object */
gint32
counter_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CounterColumn * this_object = COUNTER_COLUMN(object);
  gboolean isset_name = FALSE;
  gboolean isset_value = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_value)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
counter_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CounterColumn * this_object = COUNTER_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CounterColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->name)->data, ((GByteArray *) this_object->name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
counter_column_instance_init (CounterColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->value = 0;
}

void 
counter_column_finalize (GObject *object)
{
  CounterColumn *tobject = COUNTER_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
counter_column_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = counter_column_finalize;
  cls->read = counter_column_read;
  cls->write = counter_column_write;
}

GType
counter_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CounterColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) counter_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CounterColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) counter_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CounterColumnType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a counter_super_column object */
gint32
counter_super_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CounterSuperColumn * this_object = COUNTER_SUPER_COLUMN(object);
  gboolean isset_name = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              CounterColumn * _elem1;
              _elem1 = g_object_new (TYPE_COUNTER_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
counter_super_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CounterSuperColumn * this_object = COUNTER_SUPER_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CounterSuperColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->name)->data, ((GByteArray *) this_object->name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->columns->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->columns->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->columns, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
counter_super_column_instance_init (CounterSuperColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->columns = g_ptr_array_new();
}

void 
counter_super_column_finalize (GObject *object)
{
  CounterSuperColumn *tobject = COUNTER_SUPER_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->columns, FALSE);
}

void 
counter_super_column_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = counter_super_column_finalize;
  cls->read = counter_super_column_read;
  cls->write = counter_super_column_write;
}

GType
counter_super_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CounterSuperColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) counter_super_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CounterSuperColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) counter_super_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CounterSuperColumnType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a column_or_super_column object */
gint32
column_or_super_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnOrSuperColumn * this_object = COLUMN_OR_SUPER_COLUMN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          this_object->column = g_object_new (TYPE_COLUMN, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          this_object->super_column = g_object_new (TYPE_SUPER_COLUMN, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->super_column), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_super_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          this_object->counter_column = g_object_new (TYPE_COUNTER_COLUMN, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->counter_column), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_counter_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          this_object->counter_super_column = g_object_new (TYPE_COUNTER_SUPER_COLUMN, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->counter_super_column), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_counter_super_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
column_or_super_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnOrSuperColumn * this_object = COLUMN_OR_SUPER_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnOrSuperColumn", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_super_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "super_column", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->super_column), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_counter_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "counter_column", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->counter_column), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_counter_super_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "counter_super_column", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->counter_super_column), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
column_or_super_column_instance_init (ColumnOrSuperColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column = NULL;
  object->__isset_column = FALSE;
  object->super_column = NULL;
  object->__isset_super_column = FALSE;
  object->counter_column = NULL;
  object->__isset_counter_column = FALSE;
  object->counter_super_column = NULL;
  object->__isset_counter_super_column = FALSE;
}

void 
column_or_super_column_finalize (GObject *object)
{
  ColumnOrSuperColumn *tobject = COLUMN_OR_SUPER_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
column_or_super_column_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = column_or_super_column_finalize;
  cls->read = column_or_super_column_read;
  cls->write = column_or_super_column_write;
}

GType
column_or_super_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnOrSuperColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_or_super_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnOrSuperColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_or_super_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnOrSuperColumnType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a not_found_exception object */
gint32
not_found_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NotFoundException * this_object = NOT_FOUND_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
not_found_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NotFoundException * this_object = NOT_FOUND_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NotFoundException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
not_found_exception_instance_init (NotFoundException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void 
not_found_exception_finalize (GObject *object)
{
  NotFoundException *tobject = NOT_FOUND_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
not_found_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = not_found_exception_finalize;
  cls->read = not_found_exception_read;
  cls->write = not_found_exception_write;
}

GType
not_found_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NotFoundExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) not_found_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NotFoundException),
      0, /* n_preallocs */
      (GInstanceInitFunc) not_found_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NotFoundExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define NOT_FOUND_EXCEPTION_ERROR_DOMAIN "not_found_exception_error_quark"
GQuark
not_found_exception_error_quark (void)
{
  return g_quark_from_static_string (NOT_FOUND_EXCEPTION_ERROR_DOMAIN);
}

/* reads a invalid_request_exception object */
gint32
invalid_request_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InvalidRequestException * this_object = INVALID_REQUEST_EXCEPTION(object);
  gboolean isset_why = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->why, error)) < 0)
            return -1;
          xfer += ret;
          isset_why = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_why)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
invalid_request_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  InvalidRequestException * this_object = INVALID_REQUEST_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InvalidRequestException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "why", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->why, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
invalid_request_exception_instance_init (InvalidRequestException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->why = NULL;
}

void 
invalid_request_exception_finalize (GObject *object)
{
  InvalidRequestException *tobject = INVALID_REQUEST_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
invalid_request_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = invalid_request_exception_finalize;
  cls->read = invalid_request_exception_read;
  cls->write = invalid_request_exception_write;
}

GType
invalid_request_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (InvalidRequestExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) invalid_request_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (InvalidRequestException),
      0, /* n_preallocs */
      (GInstanceInitFunc) invalid_request_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "InvalidRequestExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define INVALID_REQUEST_EXCEPTION_ERROR_DOMAIN "invalid_request_exception_error_quark"
GQuark
invalid_request_exception_error_quark (void)
{
  return g_quark_from_static_string (INVALID_REQUEST_EXCEPTION_ERROR_DOMAIN);
}

/* reads a unavailable_exception object */
gint32
unavailable_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UnavailableException * this_object = UNAVAILABLE_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
unavailable_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UnavailableException * this_object = UNAVAILABLE_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UnavailableException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
unavailable_exception_instance_init (UnavailableException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void 
unavailable_exception_finalize (GObject *object)
{
  UnavailableException *tobject = UNAVAILABLE_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
unavailable_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = unavailable_exception_finalize;
  cls->read = unavailable_exception_read;
  cls->write = unavailable_exception_write;
}

GType
unavailable_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UnavailableExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) unavailable_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UnavailableException),
      0, /* n_preallocs */
      (GInstanceInitFunc) unavailable_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UnavailableExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define UNAVAILABLE_EXCEPTION_ERROR_DOMAIN "unavailable_exception_error_quark"
GQuark
unavailable_exception_error_quark (void)
{
  return g_quark_from_static_string (UNAVAILABLE_EXCEPTION_ERROR_DOMAIN);
}

/* reads a timed_out_exception object */
gint32
timed_out_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimedOutException * this_object = TIMED_OUT_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
timed_out_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimedOutException * this_object = TIMED_OUT_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimedOutException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
timed_out_exception_instance_init (TimedOutException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void 
timed_out_exception_finalize (GObject *object)
{
  TimedOutException *tobject = TIMED_OUT_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
timed_out_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = timed_out_exception_finalize;
  cls->read = timed_out_exception_read;
  cls->write = timed_out_exception_write;
}

GType
timed_out_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimedOutExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) timed_out_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimedOutException),
      0, /* n_preallocs */
      (GInstanceInitFunc) timed_out_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimedOutExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define TIMED_OUT_EXCEPTION_ERROR_DOMAIN "timed_out_exception_error_quark"
GQuark
timed_out_exception_error_quark (void)
{
  return g_quark_from_static_string (TIMED_OUT_EXCEPTION_ERROR_DOMAIN);
}

/* reads a authentication_exception object */
gint32
authentication_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AuthenticationException * this_object = AUTHENTICATION_EXCEPTION(object);
  gboolean isset_why = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->why, error)) < 0)
            return -1;
          xfer += ret;
          isset_why = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_why)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
authentication_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AuthenticationException * this_object = AUTHENTICATION_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthenticationException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "why", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->why, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
authentication_exception_instance_init (AuthenticationException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->why = NULL;
}

void 
authentication_exception_finalize (GObject *object)
{
  AuthenticationException *tobject = AUTHENTICATION_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
authentication_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = authentication_exception_finalize;
  cls->read = authentication_exception_read;
  cls->write = authentication_exception_write;
}

GType
authentication_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AuthenticationExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) authentication_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AuthenticationException),
      0, /* n_preallocs */
      (GInstanceInitFunc) authentication_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AuthenticationExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define AUTHENTICATION_EXCEPTION_ERROR_DOMAIN "authentication_exception_error_quark"
GQuark
authentication_exception_error_quark (void)
{
  return g_quark_from_static_string (AUTHENTICATION_EXCEPTION_ERROR_DOMAIN);
}

/* reads a authorization_exception object */
gint32
authorization_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AuthorizationException * this_object = AUTHORIZATION_EXCEPTION(object);
  gboolean isset_why = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->why, error)) < 0)
            return -1;
          xfer += ret;
          isset_why = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_why)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
authorization_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AuthorizationException * this_object = AUTHORIZATION_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorizationException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "why", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->why, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
authorization_exception_instance_init (AuthorizationException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->why = NULL;
}

void 
authorization_exception_finalize (GObject *object)
{
  AuthorizationException *tobject = AUTHORIZATION_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
authorization_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = authorization_exception_finalize;
  cls->read = authorization_exception_read;
  cls->write = authorization_exception_write;
}

GType
authorization_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AuthorizationExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) authorization_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AuthorizationException),
      0, /* n_preallocs */
      (GInstanceInitFunc) authorization_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AuthorizationExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define AUTHORIZATION_EXCEPTION_ERROR_DOMAIN "authorization_exception_error_quark"
GQuark
authorization_exception_error_quark (void)
{
  return g_quark_from_static_string (AUTHORIZATION_EXCEPTION_ERROR_DOMAIN);
}

/* reads a schema_disagreement_exception object */
gint32
schema_disagreement_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaDisagreementException * this_object = SCHEMA_DISAGREEMENT_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
schema_disagreement_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaDisagreementException * this_object = SCHEMA_DISAGREEMENT_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaDisagreementException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
schema_disagreement_exception_instance_init (SchemaDisagreementException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void 
schema_disagreement_exception_finalize (GObject *object)
{
  SchemaDisagreementException *tobject = SCHEMA_DISAGREEMENT_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
schema_disagreement_exception_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = schema_disagreement_exception_finalize;
  cls->read = schema_disagreement_exception_read;
  cls->write = schema_disagreement_exception_write;
}

GType
schema_disagreement_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaDisagreementExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_disagreement_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SchemaDisagreementException),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_disagreement_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaDisagreementExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define SCHEMA_DISAGREEMENT_EXCEPTION_ERROR_DOMAIN "schema_disagreement_exception_error_quark"
GQuark
schema_disagreement_exception_error_quark (void)
{
  return g_quark_from_static_string (SCHEMA_DISAGREEMENT_EXCEPTION_ERROR_DOMAIN);
}

/* reads a column_parent object */
gint32
column_parent_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnParent * this_object = COLUMN_PARENT(object);
  gboolean isset_column_family = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->column_family, error)) < 0)
            return -1;
          xfer += ret;
          isset_column_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->super_column = g_byte_array_new();
          g_byte_array_append (this_object->super_column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_super_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_column_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_parent_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnParent * this_object = COLUMN_PARENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnParent", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->column_family, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_super_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "super_column", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->super_column)->data, ((GByteArray *) this_object->super_column)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
column_parent_instance_init (ColumnParent * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_family = NULL;
  object->super_column = NULL;
  object->__isset_super_column = FALSE;
}

void 
column_parent_finalize (GObject *object)
{
  ColumnParent *tobject = COLUMN_PARENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
column_parent_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = column_parent_finalize;
  cls->read = column_parent_read;
  cls->write = column_parent_write;
}

GType
column_parent_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnParentClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_parent_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnParent),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_parent_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnParentType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a column_path object */
gint32
column_path_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnPath * this_object = COLUMN_PATH(object);
  gboolean isset_column_family = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->column_family, error)) < 0)
            return -1;
          xfer += ret;
          isset_column_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->super_column = g_byte_array_new();
          g_byte_array_append (this_object->super_column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_super_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_column_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_path_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnPath * this_object = COLUMN_PATH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnPath", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->column_family, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_super_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "super_column", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->super_column)->data, ((GByteArray *) this_object->super_column)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->column)->data, ((GByteArray *) this_object->column)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
column_path_instance_init (ColumnPath * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_family = NULL;
  object->super_column = NULL;
  object->__isset_super_column = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
}

void 
column_path_finalize (GObject *object)
{
  ColumnPath *tobject = COLUMN_PATH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
column_path_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = column_path_finalize;
  cls->read = column_path_read;
  cls->write = column_path_write;
}

GType
column_path_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnPathClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_path_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnPath),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_path_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnPathType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a slice_range object */
gint32
slice_range_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SliceRange * this_object = SLICE_RANGE(object);
  gboolean isset_start = FALSE;
  gboolean isset_finish = FALSE;
  gboolean isset_reversed = FALSE;
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->start = g_byte_array_new();
          g_byte_array_append (this_object->start, (guint8 *) data, (guint) len);
          g_free (data);
          isset_start = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->finish = g_byte_array_new();
          g_byte_array_append (this_object->finish, (guint8 *) data, (guint) len);
          g_free (data);
          isset_finish = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->reversed, error)) < 0)
            return -1;
          xfer += ret;
          isset_reversed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_start)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_finish)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_reversed)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
slice_range_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SliceRange * this_object = SLICE_RANGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SliceRange", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "start", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->start)->data, ((GByteArray *) this_object->start)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "finish", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->finish)->data, ((GByteArray *) this_object->finish)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "reversed", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->reversed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
slice_range_instance_init (SliceRange * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->start = NULL;
  object->finish = NULL;
  object->reversed = 0;
  object->count = 100;
}

void 
slice_range_finalize (GObject *object)
{
  SliceRange *tobject = SLICE_RANGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
slice_range_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = slice_range_finalize;
  cls->read = slice_range_read;
  cls->write = slice_range_write;
}

GType
slice_range_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SliceRangeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) slice_range_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SliceRange),
      0, /* n_preallocs */
      (GInstanceInitFunc) slice_range_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SliceRangeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a slice_predicate object */
gint32
slice_predicate_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SlicePredicate * this_object = SLICE_PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem2 = NULL;
              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem2 = g_byte_array_new();
              g_byte_array_append (_elem2, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->column_names, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_column_names = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          this_object->slice_range = g_object_new (TYPE_SLICE_RANGE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->slice_range), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_slice_range = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
slice_predicate_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SlicePredicate * this_object = SLICE_PREDICATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SlicePredicate", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_column_names == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_names", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->column_names->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i;
      for (i=0; i<this_object->column_names->len; i++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) g_ptr_array_index ((GPtrArray *) this_object->column_names, i))->data, ((GByteArray *) g_ptr_array_index ((GPtrArray *) this_object->column_names, i))->len, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_slice_range == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "slice_range", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->slice_range), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
slice_predicate_instance_init (SlicePredicate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_names = g_ptr_array_new();
  object->__isset_column_names = FALSE;
  object->slice_range = NULL;
  object->__isset_slice_range = FALSE;
}

void 
slice_predicate_finalize (GObject *object)
{
  SlicePredicate *tobject = SLICE_PREDICATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->column_names, FALSE);
}

void 
slice_predicate_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = slice_predicate_finalize;
  cls->read = slice_predicate_read;
  cls->write = slice_predicate_write;
}

GType
slice_predicate_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SlicePredicateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) slice_predicate_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SlicePredicate),
      0, /* n_preallocs */
      (GInstanceInitFunc) slice_predicate_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SlicePredicateType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a index_expression object */
gint32
index_expression_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IndexExpression * this_object = INDEX_EXPRESSION(object);
  gboolean isset_column_name = FALSE;
  gboolean isset_op = FALSE;
  gboolean isset_value = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column_name = g_byte_array_new();
          g_byte_array_append (this_object->column_name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_column_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast3;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (IndexOperator)ecast3;
          isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_column_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_op)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_value)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
index_expression_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IndexExpression * this_object = INDEX_EXPRESSION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IndexExpression", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->column_name)->data, ((GByteArray *) this_object->column_name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->value)->data, ((GByteArray *) this_object->value)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
index_expression_instance_init (IndexExpression * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_name = NULL;
  object->value = NULL;
}

void 
index_expression_finalize (GObject *object)
{
  IndexExpression *tobject = INDEX_EXPRESSION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
index_expression_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = index_expression_finalize;
  cls->read = index_expression_read;
  cls->write = index_expression_write;
}

GType
index_expression_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IndexExpressionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) index_expression_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IndexExpression),
      0, /* n_preallocs */
      (GInstanceInitFunc) index_expression_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IndexExpressionType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a index_clause object */
gint32
index_clause_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IndexClause * this_object = INDEX_CLAUSE(object);
  gboolean isset_expressions = FALSE;
  gboolean isset_start_key = FALSE;
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              IndexExpression * _elem4;
              _elem4 = g_object_new (TYPE_INDEX_EXPRESSION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expressions, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_expressions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->start_key = g_byte_array_new();
          g_byte_array_append (this_object->start_key, (guint8 *) data, (guint) len);
          g_free (data);
          isset_start_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_expressions)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_start_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
index_clause_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IndexClause * this_object = INDEX_CLAUSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IndexClause", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expressions", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->expressions->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->expressions->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->expressions, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "start_key", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->start_key)->data, ((GByteArray *) this_object->start_key)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
index_clause_instance_init (IndexClause * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->expressions = g_ptr_array_new();
  object->start_key = NULL;
  object->count = 100;
}

void 
index_clause_finalize (GObject *object)
{
  IndexClause *tobject = INDEX_CLAUSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->expressions, FALSE);
}

void 
index_clause_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = index_clause_finalize;
  cls->read = index_clause_read;
  cls->write = index_clause_write;
}

GType
index_clause_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IndexClauseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) index_clause_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IndexClause),
      0, /* n_preallocs */
      (GInstanceInitFunc) index_clause_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IndexClauseType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a key_range object */
gint32
key_range_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KeyRange * this_object = KEY_RANGE(object);
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->start_key = g_byte_array_new();
          g_byte_array_append (this_object->start_key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_start_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->end_key = g_byte_array_new();
          g_byte_array_append (this_object->end_key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_end_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->start_token, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_start_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->end_token, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_end_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
key_range_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KeyRange * this_object = KEY_RANGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KeyRange", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_start_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "start_key", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->start_key)->data, ((GByteArray *) this_object->start_key)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_end_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "end_key", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->end_key)->data, ((GByteArray *) this_object->end_key)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_start_token == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "start_token", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->start_token, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_end_token == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "end_token", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->end_token, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
key_range_instance_init (KeyRange * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->start_key = NULL;
  object->__isset_start_key = FALSE;
  object->end_key = NULL;
  object->__isset_end_key = FALSE;
  object->start_token = NULL;
  object->__isset_start_token = FALSE;
  object->end_token = NULL;
  object->__isset_end_token = FALSE;
  object->count = 100;
}

void 
key_range_finalize (GObject *object)
{
  KeyRange *tobject = KEY_RANGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
key_range_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = key_range_finalize;
  cls->read = key_range_read;
  cls->write = key_range_write;
}

GType
key_range_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KeyRangeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) key_range_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KeyRange),
      0, /* n_preallocs */
      (GInstanceInitFunc) key_range_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KeyRangeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a key_slice object */
gint32
key_slice_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KeySlice * this_object = KEY_SLICE(object);
  gboolean isset_key = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              ColumnOrSuperColumn * _elem5;
              _elem5 = g_object_new (TYPE_COLUMN_OR_SUPER_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem5), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
key_slice_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KeySlice * this_object = KEY_SLICE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KeySlice", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->key)->data, ((GByteArray *) this_object->key)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->columns->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->columns->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->columns, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
key_slice_instance_init (KeySlice * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->columns = g_ptr_array_new();
}

void 
key_slice_finalize (GObject *object)
{
  KeySlice *tobject = KEY_SLICE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->columns, FALSE);
}

void 
key_slice_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = key_slice_finalize;
  cls->read = key_slice_read;
  cls->write = key_slice_write;
}

GType
key_slice_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KeySliceClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) key_slice_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KeySlice),
      0, /* n_preallocs */
      (GInstanceInitFunc) key_slice_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KeySliceType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a key_count object */
gint32
key_count_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KeyCount * this_object = KEY_COUNT(object);
  gboolean isset_key = FALSE;
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
key_count_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KeyCount * this_object = KEY_COUNT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KeyCount", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->key)->data, ((GByteArray *) this_object->key)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
key_count_instance_init (KeyCount * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->count = 0;
}

void 
key_count_finalize (GObject *object)
{
  KeyCount *tobject = KEY_COUNT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
key_count_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = key_count_finalize;
  cls->read = key_count_read;
  cls->write = key_count_write;
}

GType
key_count_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KeyCountClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) key_count_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KeyCount),
      0, /* n_preallocs */
      (GInstanceInitFunc) key_count_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KeyCountType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a deletion object */
gint32
deletion_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Deletion * this_object = DELETION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->super_column = g_byte_array_new();
          g_byte_array_append (this_object->super_column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_super_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          this_object->predicate = g_object_new (TYPE_SLICE_PREDICATE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
deletion_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Deletion * this_object = DELETION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Deletion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_super_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "super_column", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->super_column)->data, ((GByteArray *) this_object->super_column)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_predicate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
deletion_instance_init (Deletion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->super_column = NULL;
  object->__isset_super_column = FALSE;
  object->predicate = NULL;
  object->__isset_predicate = FALSE;
}

void 
deletion_finalize (GObject *object)
{
  Deletion *tobject = DELETION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
deletion_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = deletion_finalize;
  cls->read = deletion_read;
  cls->write = deletion_write;
}

GType
deletion_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeletionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) deletion_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Deletion),
      0, /* n_preallocs */
      (GInstanceInitFunc) deletion_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeletionType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a mutation object */
gint32
mutation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Mutation * this_object = MUTATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          this_object->column_or_supercolumn = g_object_new (TYPE_COLUMN_OR_SUPER_COLUMN, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column_or_supercolumn), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_or_supercolumn = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          this_object->deletion = g_object_new (TYPE_DELETION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->deletion), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deletion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
mutation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Mutation * this_object = MUTATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Mutation", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_column_or_supercolumn == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_or_supercolumn", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column_or_supercolumn), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deletion == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deletion", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->deletion), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
mutation_instance_init (Mutation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_or_supercolumn = NULL;
  object->__isset_column_or_supercolumn = FALSE;
  object->deletion = NULL;
  object->__isset_deletion = FALSE;
}

void 
mutation_finalize (GObject *object)
{
  Mutation *tobject = MUTATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
mutation_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = mutation_finalize;
  cls->read = mutation_read;
  cls->write = mutation_write;
}

GType
mutation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MutationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) mutation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Mutation),
      0, /* n_preallocs */
      (GInstanceInitFunc) mutation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MutationType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a endpoint_details object */
gint32
endpoint_details_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EndpointDetails * this_object = ENDPOINT_DETAILS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->host, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_host = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->datacenter, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_datacenter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->rack, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rack = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
endpoint_details_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EndpointDetails * this_object = ENDPOINT_DETAILS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EndpointDetails", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "host", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->host, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "datacenter", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->datacenter, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_rack == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rack", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->rack, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
endpoint_details_instance_init (EndpointDetails * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->host = NULL;
  object->__isset_host = FALSE;
  object->datacenter = NULL;
  object->__isset_datacenter = FALSE;
  object->rack = NULL;
  object->__isset_rack = FALSE;
}

void 
endpoint_details_finalize (GObject *object)
{
  EndpointDetails *tobject = ENDPOINT_DETAILS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

void 
endpoint_details_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = endpoint_details_finalize;
  cls->read = endpoint_details_read;
  cls->write = endpoint_details_write;
}

GType
endpoint_details_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EndpointDetailsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) endpoint_details_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EndpointDetails),
      0, /* n_preallocs */
      (GInstanceInitFunc) endpoint_details_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EndpointDetailsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a token_range object */
gint32
token_range_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TokenRange * this_object = TOKEN_RANGE(object);
  gboolean isset_start_token = FALSE;
  gboolean isset_end_token = FALSE;
  gboolean isset_endpoints = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->start_token, error)) < 0)
            return -1;
          xfer += ret;
          isset_start_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->end_token, error)) < 0)
            return -1;
          xfer += ret;
          isset_end_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * _elem6 = NULL;
              if ((ret = thrift_protocol_read_string (protocol, &_elem6, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->endpoints, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_endpoints = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * _elem7 = NULL;
              if ((ret = thrift_protocol_read_string (protocol, &_elem7, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->rpc_endpoints, _elem7);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_rpc_endpoints = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              EndpointDetails * _elem8;
              _elem8 = g_object_new (TYPE_ENDPOINT_DETAILS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem8), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->endpoint_details, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_endpoint_details = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_start_token)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_end_token)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_endpoints)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
token_range_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TokenRange * this_object = TOKEN_RANGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TokenRange", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "start_token", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->start_token, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "end_token", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->end_token, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "endpoints", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->endpoints->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->endpoints->len; i++)
    {
      if ((ret = thrift_protocol_write_string (protocol, g_ptr_array_index ((GPtrArray *) this_object->endpoints, i), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_rpc_endpoints == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rpc_endpoints", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->rpc_endpoints->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i;
      for (i=0; i<this_object->rpc_endpoints->len; i++)
      {
        if ((ret = thrift_protocol_write_string (protocol, g_ptr_array_index ((GPtrArray *) this_object->rpc_endpoints, i), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_endpoint_details == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "endpoint_details", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->endpoint_details->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i;
      for (i=0; i<this_object->endpoint_details->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->endpoint_details, i)), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
token_range_instance_init (TokenRange * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->start_token = NULL;
  object->end_token = NULL;
  object->endpoints = g_ptr_array_new();
  object->rpc_endpoints = g_ptr_array_new();
  object->__isset_rpc_endpoints = FALSE;
  object->endpoint_details = g_ptr_array_new();
  object->__isset_endpoint_details = FALSE;
}

void 
token_range_finalize (GObject *object)
{
  TokenRange *tobject = TOKEN_RANGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->endpoints, FALSE);
  g_ptr_array_free (tobject->rpc_endpoints, FALSE);
  g_ptr_array_free (tobject->endpoint_details, FALSE);
}

void 
token_range_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = token_range_finalize;
  cls->read = token_range_read;
  cls->write = token_range_write;
}

GType
token_range_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TokenRangeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) token_range_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TokenRange),
      0, /* n_preallocs */
      (GInstanceInitFunc) token_range_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TokenRangeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a authentication_request object */
gint32
authentication_request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AuthenticationRequest * this_object = AUTHENTICATION_REQUEST(object);
  gboolean isset_credentials = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key9;
              gchar * val10;
              if ((ret = thrift_protocol_read_string (protocol, &key9, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_string (protocol, &val10, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->credentials, (gpointer) &key9, (gpointer) &val10);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_credentials = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_credentials)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
authentication_request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AuthenticationRequest * this_object = AUTHENTICATION_REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthenticationRequest", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "credentials", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->credentials), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    gchar * key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->credentials, thrift_hash_table_get_keys, &key_list);
    gchar * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (gchar *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->credentials), (gpointer) key);

      if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
authentication_request_instance_init (AuthenticationRequest * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->credentials = g_hash_table_new (NULL, NULL);
}

void 
authentication_request_finalize (GObject *object)
{
  AuthenticationRequest *tobject = AUTHENTICATION_REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_hash_table_unref (tobject->credentials);
}

void 
authentication_request_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = authentication_request_finalize;
  cls->read = authentication_request_read;
  cls->write = authentication_request_write;
}

GType
authentication_request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AuthenticationRequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) authentication_request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AuthenticationRequest),
      0, /* n_preallocs */
      (GInstanceInitFunc) authentication_request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AuthenticationRequestType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a column_def object */
gint32
column_def_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnDef * this_object = COLUMN_DEF(object);
  gboolean isset_name = FALSE;
  gboolean isset_validation_class = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->validation_class, error)) < 0)
            return -1;
          xfer += ret;
          isset_validation_class = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast11;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->index_type = (IndexType)ecast11;
          this_object->__isset_index_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->index_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_index_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key12;
              gchar * val13;
              if ((ret = thrift_protocol_read_string (protocol, &key12, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_string (protocol, &val13, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->index_options, (gpointer) &key12, (gpointer) &val13);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_index_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_validation_class)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_def_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnDef * this_object = COLUMN_DEF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnDef", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->name)->data, ((GByteArray *) this_object->name)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "validation_class", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->validation_class, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_index_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_type", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->index_type, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_index_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_name", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->index_name, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_index_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_options", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->index_options), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) this_object->index_options, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->index_options), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
column_def_instance_init (ColumnDef * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->validation_class = NULL;
  object->__isset_index_type = FALSE;
  object->index_name = NULL;
  object->__isset_index_name = FALSE;
  object->index_options = g_hash_table_new (NULL, NULL);
  object->__isset_index_options = FALSE;
}

void 
column_def_finalize (GObject *object)
{
  ColumnDef *tobject = COLUMN_DEF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_hash_table_unref (tobject->index_options);
}

void 
column_def_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = column_def_finalize;
  cls->read = column_def_read;
  cls->write = column_def_write;
}

GType
column_def_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnDefClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_def_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnDef),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_def_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnDefType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a cf_def object */
gint32
cf_def_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CfDef * this_object = CF_DEF(object);
  gboolean isset_keyspace = FALSE;
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->keyspace, error)) < 0)
            return -1;
          xfer += ret;
          isset_keyspace = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->column_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->comparator_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_comparator_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->subcomparator_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_subcomparator_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->comment, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_comment = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->row_cache_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_row_cache_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->key_cache_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key_cache_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->read_repair_chance, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_read_repair_chance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              ColumnDef * _elem14;
              _elem14 = g_object_new (TYPE_COLUMN_DEF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->column_metadata, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_column_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->gc_grace_seconds, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_gc_grace_seconds = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->default_validation_class, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_default_validation_class = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->min_compaction_threshold, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_min_compaction_threshold = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->max_compaction_threshold, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_max_compaction_threshold = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->row_cache_save_period_in_seconds, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_row_cache_save_period_in_seconds = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->key_cache_save_period_in_seconds, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key_cache_save_period_in_seconds = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 24:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->replicate_on_write, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_replicate_on_write = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 25:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->merge_shards_chance, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_merge_shards_chance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 26:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->key_validation_class, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key_validation_class = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 27:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->row_cache_provider, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_row_cache_provider = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 28:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key_alias = g_byte_array_new();
          g_byte_array_append (this_object->key_alias, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key_alias = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 29:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->compaction_strategy, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compaction_strategy = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 30:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key15;
              gchar * val16;
              if ((ret = thrift_protocol_read_string (protocol, &key15, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_string (protocol, &val16, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->compaction_strategy_options, (gpointer) &key15, (gpointer) &val16);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_compaction_strategy_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 31:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->row_cache_keys_to_save, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_row_cache_keys_to_save = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 32:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key17;
              gchar * val18;
              if ((ret = thrift_protocol_read_string (protocol, &key17, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_string (protocol, &val18, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->compression_options, (gpointer) &key17, (gpointer) &val18);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_compression_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 33:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->bloom_filter_fp_chance, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloom_filter_fp_chance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_keyspace)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
cf_def_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CfDef * this_object = CF_DEF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CfDef", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "keyspace", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->keyspace, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_column_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_type", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->column_type, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_comparator_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comparator_type", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->comparator_type, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_subcomparator_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "subcomparator_type", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->subcomparator_type, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_comment == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comment", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->comment, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_row_cache_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "row_cache_size", T_DOUBLE, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->row_cache_size, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_key_cache_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_cache_size", T_DOUBLE, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->key_cache_size, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_read_repair_chance == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "read_repair_chance", T_DOUBLE, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->read_repair_chance, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_metadata", T_LIST, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->column_metadata->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i;
      for (i=0; i<this_object->column_metadata->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->column_metadata, i)), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_gc_grace_seconds == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "gc_grace_seconds", T_I32, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->gc_grace_seconds, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_default_validation_class == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "default_validation_class", T_STRING, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->default_validation_class, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_min_compaction_threshold == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "min_compaction_threshold", T_I32, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->min_compaction_threshold, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_max_compaction_threshold == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max_compaction_threshold", T_I32, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->max_compaction_threshold, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_row_cache_save_period_in_seconds == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "row_cache_save_period_in_seconds", T_I32, 19, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->row_cache_save_period_in_seconds, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_key_cache_save_period_in_seconds == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_cache_save_period_in_seconds", T_I32, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->key_cache_save_period_in_seconds, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_replicate_on_write == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "replicate_on_write", T_BOOL, 24, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->replicate_on_write, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_merge_shards_chance == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "merge_shards_chance", T_DOUBLE, 25, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->merge_shards_chance, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_key_validation_class == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_validation_class", T_STRING, 26, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->key_validation_class, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_row_cache_provider == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "row_cache_provider", T_STRING, 27, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->row_cache_provider, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_key_alias == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_alias", T_STRING, 28, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->key_alias)->data, ((GByteArray *) this_object->key_alias)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compaction_strategy == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compaction_strategy", T_STRING, 29, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->compaction_strategy, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compaction_strategy_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compaction_strategy_options", T_MAP, 30, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->compaction_strategy_options), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) this_object->compaction_strategy_options, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->compaction_strategy_options), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_row_cache_keys_to_save == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "row_cache_keys_to_save", T_I32, 31, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->row_cache_keys_to_save, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compression_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compression_options", T_MAP, 32, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->compression_options), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) this_object->compression_options, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->compression_options), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bloom_filter_fp_chance == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bloom_filter_fp_chance", T_DOUBLE, 33, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->bloom_filter_fp_chance, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
cf_def_instance_init (CfDef * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->keyspace = NULL;
  object->name = NULL;
  object->column_type = "Standard";
  object->__isset_column_type = FALSE;
  object->comparator_type = "BytesType";
  object->__isset_comparator_type = FALSE;
  object->subcomparator_type = NULL;
  object->__isset_subcomparator_type = FALSE;
  object->comment = NULL;
  object->__isset_comment = FALSE;
  object->row_cache_size = 0;
  object->__isset_row_cache_size = FALSE;
  object->key_cache_size = 200000;
  object->__isset_key_cache_size = FALSE;
  object->read_repair_chance = 1;
  object->__isset_read_repair_chance = FALSE;
  object->column_metadata = g_ptr_array_new();
  object->__isset_column_metadata = FALSE;
  object->gc_grace_seconds = 0;
  object->__isset_gc_grace_seconds = FALSE;
  object->default_validation_class = NULL;
  object->__isset_default_validation_class = FALSE;
  object->id = 0;
  object->__isset_id = FALSE;
  object->min_compaction_threshold = 0;
  object->__isset_min_compaction_threshold = FALSE;
  object->max_compaction_threshold = 0;
  object->__isset_max_compaction_threshold = FALSE;
  object->row_cache_save_period_in_seconds = 0;
  object->__isset_row_cache_save_period_in_seconds = FALSE;
  object->key_cache_save_period_in_seconds = 0;
  object->__isset_key_cache_save_period_in_seconds = FALSE;
  object->replicate_on_write = 0;
  object->__isset_replicate_on_write = FALSE;
  object->merge_shards_chance = 0;
  object->__isset_merge_shards_chance = FALSE;
  object->key_validation_class = NULL;
  object->__isset_key_validation_class = FALSE;
  object->row_cache_provider = NULL;
  object->__isset_row_cache_provider = FALSE;
  object->key_alias = NULL;
  object->__isset_key_alias = FALSE;
  object->compaction_strategy = NULL;
  object->__isset_compaction_strategy = FALSE;
  object->compaction_strategy_options = g_hash_table_new (NULL, NULL);
  object->__isset_compaction_strategy_options = FALSE;
  object->row_cache_keys_to_save = 0;
  object->__isset_row_cache_keys_to_save = FALSE;
  object->compression_options = g_hash_table_new (NULL, NULL);
  object->__isset_compression_options = FALSE;
  object->bloom_filter_fp_chance = 0;
  object->__isset_bloom_filter_fp_chance = FALSE;
}

void 
cf_def_finalize (GObject *object)
{
  CfDef *tobject = CF_DEF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->column_metadata, FALSE);
  g_hash_table_unref (tobject->compaction_strategy_options);
  g_hash_table_unref (tobject->compression_options);
}

void 
cf_def_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = cf_def_finalize;
  cls->read = cf_def_read;
  cls->write = cf_def_write;
}

GType
cf_def_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CfDefClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cf_def_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CfDef),
      0, /* n_preallocs */
      (GInstanceInitFunc) cf_def_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CfDefType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a ks_def object */
gint32
ks_def_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KsDef * this_object = KS_DEF(object);
  gboolean isset_name = FALSE;
  gboolean isset_strategy_class = FALSE;
  gboolean isset_cf_defs = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->strategy_class, error)) < 0)
            return -1;
          xfer += ret;
          isset_strategy_class = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              gchar * key19;
              gchar * val20;
              if ((ret = thrift_protocol_read_string (protocol, &key19, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_string (protocol, &val20, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->strategy_options, (gpointer) &key19, (gpointer) &val20);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_strategy_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->replication_factor, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_replication_factor = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              CfDef * _elem21;
              _elem21 = g_object_new (TYPE_CF_DEF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem21), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->cf_defs, _elem21);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_cf_defs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->durable_writes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_durable_writes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_strategy_class)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_cf_defs)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
ks_def_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KsDef * this_object = KS_DEF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KsDef", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "strategy_class", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->strategy_class, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_strategy_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "strategy_options", T_MAP, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->strategy_options), error)) < 0)
        return -1;
      xfer += ret;

      GList *key_list = NULL, *iter = NULL;
      gchar * key;
      gchar * value;
      g_hash_table_foreach ((GHashTable *) this_object->strategy_options, thrift_hash_table_get_keys, &key_list);
      gchar * keys[g_list_length (key_list)];
      int i=0, key_count = g_list_length (key_list);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
      {
        keys[i++] = (gchar *) iter->data;
      }
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key = keys[i];
        value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->strategy_options), (gpointer) key);

        if ((ret = thrift_protocol_write_string (protocol,  key, error)) < 0)
          return -1;
        if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_replication_factor == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "replication_factor", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->replication_factor, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "cf_defs", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->cf_defs->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->cf_defs->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->cf_defs, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_durable_writes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "durable_writes", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->durable_writes, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
ks_def_instance_init (KsDef * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->strategy_class = NULL;
  object->strategy_options = g_hash_table_new (NULL, NULL);
  object->__isset_strategy_options = FALSE;
  object->replication_factor = 0;
  object->__isset_replication_factor = FALSE;
  object->cf_defs = g_ptr_array_new();
  object->durable_writes = 1;
  object->__isset_durable_writes = FALSE;
}

void 
ks_def_finalize (GObject *object)
{
  KsDef *tobject = KS_DEF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_hash_table_unref (tobject->strategy_options);
  g_ptr_array_free (tobject->cf_defs, FALSE);
}

void 
ks_def_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = ks_def_finalize;
  cls->read = ks_def_read;
  cls->write = ks_def_write;
}

GType
ks_def_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KsDefClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ks_def_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KsDef),
      0, /* n_preallocs */
      (GInstanceInitFunc) ks_def_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KsDefType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a cql_row object */
gint32
cql_row_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CqlRow * this_object = CQL_ROW(object);
  gboolean isset_key = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              Column * _elem22;
              _elem22 = g_object_new (TYPE_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
cql_row_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CqlRow * this_object = CQL_ROW(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CqlRow", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->key)->data, ((GByteArray *) this_object->key)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->columns->len, error)) < 0)
      return -1;
    xfer += ret;
    guint i;
    for (i=0; i<this_object->columns->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->columns, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
cql_row_instance_init (CqlRow * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->columns = g_ptr_array_new();
}

void 
cql_row_finalize (GObject *object)
{
  CqlRow *tobject = CQL_ROW (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->columns, FALSE);
}

void 
cql_row_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = cql_row_finalize;
  cls->read = cql_row_read;
  cls->write = cql_row_write;
}

GType
cql_row_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CqlRowClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cql_row_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CqlRow),
      0, /* n_preallocs */
      (GInstanceInitFunc) cql_row_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CqlRowType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a cql_metadata object */
gint32
cql_metadata_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CqlMetadata * this_object = CQL_METADATA(object);
  gboolean isset_name_types = FALSE;
  gboolean isset_value_types = FALSE;
  gboolean isset_default_name_type = FALSE;
  gboolean isset_default_value_type = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GByteArray * key23;
              gchar * val24;
              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key23 = g_byte_array_new();
              g_byte_array_append (key23, (guint8 *) data, (guint) len);
              g_free (data);
              if ((ret = thrift_protocol_read_string (protocol, &val24, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->name_types, (gpointer) &key23, (gpointer) &val24);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_name_types = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              GByteArray * key25;
              gchar * val26;
              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key25 = g_byte_array_new();
              g_byte_array_append (key25, (guint8 *) data, (guint) len);
              g_free (data);
              if ((ret = thrift_protocol_read_string (protocol, &val26, error)) < 0)
                return -1;
              xfer += ret;
              g_hash_table_insert ((GHashTable *)this_object->value_types, (gpointer) &key25, (gpointer) &val26);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_value_types = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->default_name_type, error)) < 0)
            return -1;
          xfer += ret;
          isset_default_name_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->default_value_type, error)) < 0)
            return -1;
          xfer += ret;
          isset_default_value_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name_types)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_value_types)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_default_name_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_default_value_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
cql_metadata_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CqlMetadata * this_object = CQL_METADATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CqlMetadata", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name_types", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->name_types), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GByteArray * key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->name_types, thrift_hash_table_get_keys, &key_list);
    GByteArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GByteArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->name_types), (gpointer) key);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  key)->data, ((GByteArray *)  key)->len, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value_types", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, (gint32) g_hash_table_size ((GHashTable *) this_object->value_types), error)) < 0)
      return -1;
    xfer += ret;

    GList *key_list = NULL, *iter = NULL;
    GByteArray * key;
    gchar * value;
    g_hash_table_foreach ((GHashTable *) this_object->value_types, thrift_hash_table_get_keys, &key_list);
    GByteArray * keys[g_list_length (key_list)];
    int i=0, key_count = g_list_length (key_list);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
    {
      keys[i++] = (GByteArray *) iter->data;
    }
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key = keys[i];
      value = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->value_types), (gpointer) key);

      if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *)  key)->data, ((GByteArray *)  key)->len, error)) < 0)
        return -1;
      if ((ret = thrift_protocol_write_string (protocol,  value, error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "default_name_type", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->default_name_type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "default_value_type", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->default_value_type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
cql_metadata_instance_init (CqlMetadata * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name_types = g_hash_table_new (NULL, NULL);
  object->value_types = g_hash_table_new (NULL, NULL);
  object->default_name_type = NULL;
  object->default_value_type = NULL;
}

void 
cql_metadata_finalize (GObject *object)
{
  CqlMetadata *tobject = CQL_METADATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_hash_table_unref (tobject->name_types);
  g_hash_table_unref (tobject->value_types);
}

void 
cql_metadata_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = cql_metadata_finalize;
  cls->read = cql_metadata_read;
  cls->write = cql_metadata_write;
}

GType
cql_metadata_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CqlMetadataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cql_metadata_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CqlMetadata),
      0, /* n_preallocs */
      (GInstanceInitFunc) cql_metadata_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CqlMetadataType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a cql_result object */
gint32
cql_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CqlResult * this_object = CQL_RESULT(object);
  gboolean isset_type = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast27;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast27, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (CqlResultType)ecast27;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            ThriftType element_type;
            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            guint32 i;
            for (i = 0; i < size; i++)
            {
              CqlRow * _elem28;
              _elem28 = g_object_new (TYPE_CQL_ROW, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem28), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->rows, _elem28);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          this_object->schema = g_object_new (TYPE_CQL_METADATA, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
cql_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CqlResult * this_object = CQL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CqlResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_rows == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->rows->len, error)) < 0)
        return -1;
      xfer += ret;
      guint i;
      for (i=0; i<this_object->rows->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index ((GPtrArray *) this_object->rows, i)), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_num == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "num", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->num, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void 
cql_result_instance_init (CqlResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rows = g_ptr_array_new();
  object->__isset_rows = FALSE;
  object->num = 0;
  object->__isset_num = FALSE;
  object->schema = NULL;
  object->__isset_schema = FALSE;
}

void 
cql_result_finalize (GObject *object)
{
  CqlResult *tobject = CQL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  g_ptr_array_free (tobject->rows, FALSE);
}

void 
cql_result_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = cql_result_finalize;
  cls->read = cql_result_read;
  cls->write = cql_result_write;
}

GType
cql_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CqlResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cql_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CqlResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) cql_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CqlResultType",
                                   &type_info, 0);
  }

  return type;
}

