<?php

use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/vendor/autoload.php';

ob_start();
class ZbxApiTestBase extends PHPUnit_Framework_TestCase
{
	/**
	 * Current auth key
	 *
	 * @var string
	 */
	private $authKey = null;

	/**
	 * Current username
	 *
	 * @var
	 */
	private $username;

	/**
	 * Current password
	 *
	 * @var string
	 */
	private $password;

	/**
	 * Current settings file name
	 *
	 * @var string
	 */
	protected $config = 'settings';

	/**
	 * Parsed config file as defined by $config above
	 *
	 * @var array
	 */
	protected $parsedConfig;

	/**
	 * PDO instance
	 *
	 * @var \PDO
	 */
	private static $pdo;

	public function __construct($name = null, array $data = array(), $dataName = '') {
		$configFileName = __DIR__.'/config/'.$this->config.'.ini';

		if (!is_readable($configFileName)) {
			throw new \Exception(sprintf('Can not find config file "%s" for config "%s"', $configFileName, $this->config));
		}

		$config = parse_ini_file($configFileName);

		$this->username = $config['username'];
		$this->password = $config['password'];

		$this->parsedConfig = $config;

		parent::__construct($name, $data, $dataName); // TODO: Change the autogenerated stub
	}

	/**
	 * Sets credentials for use with api
	 *
	 * @param string $username
	 * @param string $password
	 */
	protected function setCredentials($username, $password) {
		$this->username = $username;
		$this->password = $password;
		$this->authKey = null;
	}

	protected function setUp() {
		$annotations = $this->getAnnotations();

		if (isset($annotations['method']['fixtures'])) {
			$fixtures = explode(' ', implode(' ', $annotations['method']['fixtures']));
			$fixtures = array_map(function ($value) {
				return trim($value);
			}, $fixtures);

			foreach ($fixtures as $file) {
				$this->loadDatabaseFixtures($file);
			}
		}
	}

	protected function loadDatabaseFixtures($file)
	{
		$path = __DIR__ . '/fixtures/'.$file.'.yml';

		if (!is_readable($path)) {
			throw new Exception(sprintf('Can not find fixture file "%s" (expected location "%s")', $file, $path));
		}

		$pdo = $this->getPdo();

		$fixtures = Yaml::parse(file_get_contents($path));

		// todo: validate here

		foreach ($fixtures as $suite => $data) {
			foreach ($data['cleanup'] as $table) {
				// todo: pre-define truncate order
				$pdo->query('DELETE FROM '.$table);
			}

			foreach ($data['rows'] as $table => $rows) {
				foreach ($rows as $objectName => $fields) {
					$query = 'INSERT INTO '.$table.' (';
					$query .= implode(', ', array_keys($fields));
					$query .= ') VALUES (';
					$query .= implode(', ', array_map(function ($value) {
						return ':'.$value;
					}, array_keys($fields)));
					$query .= ')';

					$query = $pdo->prepare($query);
					$query->execute($fields);
				}
			}
		}

	}

	/**
	 * @return PDO
	 */
	protected function getPdo()
	{
		if (!self::$pdo) {
			self::$pdo = new \PDO($this->parsedConfig['database_dsn'], $this->parsedConfig['database_user'],
				$this->parsedConfig['database_password']
			);

			self::$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
		}

		return self::$pdo;
	}

	/**
	 * Executes api request and checks if it throws exception with the expected message/data.
	 *
	 * @param $callable callable to wrap your code
	 * @param string $message expected exception message
	 * @param string $messageData expected exception data
	 * @throws PHPUnit_Framework_ExpectationFailedException
	 * @internal param array|string $fixtures fixtures to load, can be JSON string, array or fixture file path
	 */
	protected function expectApiException($callable, $message, $messageData) {
		// if the callable returns an exception
		try {
			$response = $callable();
		} catch (ZabbixApiException $e) {
			if ($e->getOriginalMessage() != $message || $e->getOriginalData() != $messageData) {
				throw new PHPUnit_Framework_ExpectationFailedException(
					sprintf(
						'API returned wrong exception ("%s/%s" expected, "%s/%s" actual)',
						$message,
						$messageData,
						$e->getOriginalMessage(),
						$e->getOriginalData()
					)
				);
			} else {
				$this->addToAssertionCount(1);

				return;
			}
		}

		// if the callable just returns parsed json
		if (!isset($response['error'])) {
			throw new PHPUnit_Framework_ExpectationFailedException(
				'API response does not look like exception (and it should be)'
			);
		}

		if ($response['error']['message'] !== $message || $response['error']['data'] !== $messageData) {
			throw new PHPUnit_Framework_ExpectationFailedException(
				sprintf(
					'API returned wrong exception ("%s/%s" expected, "%s/%s" actual)',
					$message,
					$messageData,
					$response['error']['message'],
					$response['error']['data']
				)
			);
		}

		$this->addToAssertionCount(1);
	}

	protected function processJsonFixtures($file) {
		$fixtures = $this->loadJsonFixtures($file);

		$response = $this->apiRequest($fixtures);

		return $response;
	}

	/**
	 * Detects fixture type and loads them into array
	 * (so they can be modified on request with auth variables, id and so on)
	 *
	 * @param string|array $fixtures
	 * @throws PHPUnit_Framework_ExpectationFailedException
	 *
	 * @return array
	 */
	protected function loadJsonFixtures($fixtures) {
		if (is_string($fixtures)) {
			// TODO: make more sane check
			if (strpos($fixtures, '/') !== false && is_readable($this->getTestRoot().'/'.$fixtures)) {
				$fixtures = file_get_contents($this->getTestRoot() . '/' . $fixtures);
			}

			$json = json_decode($fixtures, true);

			if (null === $json) {
				throw new PHPUnit_Framework_ExpectationFailedException(
					'The data provided for test is not a valid json text or fixture path.'
				);
			}

			return $json;
		}

		return $fixtures;
	}

	protected function request($method, $params = array(), $data = array(), $version = '2.0') {
		$data = array_merge(
			array(
				'method' => $method,
				'jsonrpc' => $version,
				'params' => $params
			),
			$data
		);

		$result = $this->apiRequest($data);

		if (!is_array($result) || !isset($result['result'])) {
			if (is_array($result) && isset($result['error'])) {
				throw new ZabbixApiException($result['error']['message'], $result['error']['data'], $result['error']['code']);
			}

			throw new RuntimeException('API returned garbaged result: '.json_encode($result));
		}

		return $result;
	}

	protected function apiRequest(array $data) {
		if (!isset($data['method'])) {
			throw new \InvalidArgumentException('No "method" field for json request');
		}

		if ($this->isMethodSecure($data['method'])) {
			$data['auth'] = $this->authorize();
		}

		if (!isset($data['id'])) {
			$data['id'] = rand(1, 655536);
		}

		$this->setStreamWrapper(json_encode($data));

		$_SERVER['HTTP_CONTENT_TYPE'] = 'application/json';

		ob_start();
		require $this->getApiEntryPoint();
		$contents = ob_get_contents();
		ob_end_clean();

		$json = json_decode($contents, true);

		if (null === $json) {
			throw new \Exception(sprintf('JSON returned by API call is not decodable ("%s" given)', $contents));
		}

		$this->restoreStreamWrapper();

		return $json;
	}

	/**
	 * Returns path to api_jsonrpc.php
	 *
	 * @throws Exception
	 * @return string
	 */
	protected function getApiEntryPoint() {
		$path = realpath(__DIR__);

		if (strpos($path, 'frontends/php') === false) {
			throw new \Exception('Oops. Don\'t know where I am, is Zabbix file structure changed?');
		}

		$base = substr($path, 0, strpos($path, 'frontends/php') + strlen('frontends/php'));

		return realpath($base . '/api_jsonrpc.php');
	}

	/**
	 * Restores stream wrapper for php:// streams
	 */
	protected function restoreStreamWrapper() {
		stream_wrapper_restore('php');
	}

	/**
	 * Sets wrapper for php://input and fills it with contents provided
	 *
	 * @param $contents
	 */
	protected function setStreamWrapper($contents) {
		stream_wrapper_unregister('php');
		stream_wrapper_register('php', 'ZbxInputStreamWrapper');

		file_put_contents('php://input', $contents);
	}

	/**
	 * Authorizes user and caches auth key for future use
	 *
	 * @throws RuntimeException
	 * @return string
	 */
	protected function authorize() {
		if (null !== $this->authKey) {
			return $this->authKey;
		}

		$result = $this->request('user.login', array(
				'user' => $this->username,
				'password' => $this->password
			)
		);

		if (!preg_match('/^[a-z0-9]{32}$/', $result['result'])) {
			throw new \RuntimeException('API auth token does not much expected format');
		}

		$this->authKey = $result['result'];

		return $this->authKey;
	}

	/**
	 * Checks if method is secure.
	 * TODO; return false for ALL public methods
	 *
	 * @param $method
	 *
	 * @return bool
	 */
	protected function isMethodSecure($method)
	{
		return !in_array($method, array('user.login'));
	}

	/**
	 * Resolves test root
	 * TODO: move this into config
	 *
	 * @return string
	 */
	protected function getTestRoot()
	{
		return realpath(__DIR__.'/tests');
	}
}

class ZabbixApiException extends Exception
{
	protected $originalMessage;

	protected $originalData;

	public function __construct($message = '', $data = '', $code = 0, Exception $previous = null)
	{
		$this->originalMessage = $message;
		$this->originalData = $data;

		parent::__construct($message.' : '.$data, $code, $previous); // TODO: Change the autogenerated stub
	}

	final public function getOriginalMessage()
	{
		return $this->originalMessage;
	}

	final public function getOriginalData()
	{
		return $this->originalData;
	}
}

/**
 * TODO: document this
 */
class ZbxInputStreamWrapper
{
	protected static $data;
	protected static $length;
	protected static $position = 0;

	public function stream_open($path, $mode, $options, &$opened_path) {
		if ($path !== 'php://input') {
			throw new \Exception('Sorry, we support nothing but php://input at the moment');
		}

		self::$position = 0;

		return true;
	}

	public function stream_write($data) {
		self::$data = $data;

		self::$length = strlen($data);

		return self::$length;
	}

	public function stream_read($index) {
		// check this code for really long data
		$chunk = min($index, self::$length - self::$position);

		$data = substr(self::$data, self::$position, $chunk);

		self::$position += $chunk;

		return $data;
	}

	public function stream_stat() {
		return array();
	}

	public function stream_eof() {
		return self::$position >= self::$length;
	}
}
