<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
   <version>5.0</version>
   <date>2021-04-24T21:00:17Z</date>
   <groups>
      <group>
         <name>Templates/Databases</name>
      </group>
   </groups>
   <templates>
      <template>
         <template>Template DB MSSQL by ODBC</template>
         <name>Template DB MSSQL by ODBC</name>
         <description>1. Create an MSSQL user for monitoring.&#13;
  View Server State and View Any Definition permissions should be granted to the user.&#13;
  Grant this user read permissions to the sysjobschedules, sysjobhistory, sysjobs tables.  &#13;
  For more information, see MSSQL documentation.&#13;
2. Set the user name and password in host macros ({$MSSQL.USER} and {$MSSQL.PASSWORD}).&#13;
  Do not forget to install Microsoft ODBC driver on Zabbix server or Zabbix proxy.&#13;
  See Microsoft documentation for instructions: https://docs.microsoft.com/en-us/sql/connect/odbc/linux-mac/installing-the-microsoft-odbc-driver-for-sql-server?view=sql-server-ver15.&#13;
  Note! Credentials in the odbc.ini do not work for MSSQL.&#13;
3. For named instance set the value of {$MSSQL.INSTANCE} macro as MSSQL$instance name.&#13;
The "Service's TCP port state" item uses {HOST.CONN} and {$MSSQL.PORT} macros to check the availability of the MSSQL instance.&#13;
&#13;
&#13;
You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/&#13;
&#13;
Template tooling version used: 0.38</description>
         <groups>
            <group>
               <name>Templates/Databases</name>
            </group>
         </groups>
         <applications>
            <application>
               <name>MSSQL</name>
            </application>
            <application>
               <name>Zabbix raw items</name>
            </application>
         </applications>
         <items>
            <item>
               <name>MSSQL: Get job status</name>
               <type>ODBC</type>
               <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
               <delay>10m</delay>
               <history>0</history>
               <trends>0</trends>
               <status>ENABLED</status>
               <value_type>TEXT</value_type>
               <params>SELECT sj.name AS JobName
, sj.enabled AS Enabled
, sjs.last_run_outcome AS RunStatus
, sjs.last_outcome_message AS LastRunStatusMessage
, sjs.last_run_duration/10000*3600 + sjs.last_run_duration/100%100*60 + sjs.last_run_duration%100 AS RunDuration
, CASE sjs.last_run_date
    WHEN 0 THEN NULL
    ELSE msdb.dbo.agent_datetime(sjs.last_run_date,sjs.last_run_time)
    END AS LastRunDateTime
, sja.next_scheduled_run_date AS NextRunDateTime
FROM msdb..sysjobs AS sj
LEFT JOIN msdb..sysjobservers AS sjs ON sj.job_id = sjs.job_id
LEFT JOIN ( SELECT job.job_id,
    max(act.session_id) AS s_id,
    max(act.next_scheduled_run_date) AS next_scheduled_run_date
    FROM msdb..sysjobs AS job
    LEFT JOIN msdb..sysjobactivity AS act ON act.job_id = job.job_id
    GROUP BY job.job_id ) AS sja ON sja.job_id = sj.job_id
WHERE Enabled = 1</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>The item gets sql agent job status.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
            </item>
            <item>
               <name>MSSQL: Get last backup</name>
               <type>ODBC</type>
               <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
               <delay>10m</delay>
               <history>0</history>
               <trends>0</trends>
               <status>ENABLED</status>
               <value_type>TEXT</value_type>
               <params>SELECT bs.database_name as dbname,[type], DATEDIFF(SECOND, bs.backup_finish_date, getdate()) as timesincelastbackup, (DATEDIFF(SECOND, bs.backup_start_date, bs.backup_finish_date)) as duration
FROM msdb.dbo.backupset as bs WHERE bs.database_name not in (
SELECT
AGDatabases.database_name AS Databasename
FROM sys.dm_hadr_availability_group_states States
INNER JOIN master.sys.availability_groups Groups ON States.group_id = Groups.group_id
INNER JOIN sys.availability_databases_cluster AGDatabases ON Groups.group_id = AGDatabases.group_id
WHERE primary_replica != @@Servername OR primary_replica is NULL
)
GROUP BY bs.database_name, backup_finish_date, [type], backup_start_date
HAVING backup_finish_date = (SELECT MAX(backup_finish_date) from msdb.dbo.backupset WHERE database_name = bs.database_name AND bs.type = [type])
ORDER BY bs.database_name</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>The item gets information about backup processes.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
            </item>
            <item>
               <name>MSSQL: Get performance counters</name>
               <type>ODBC</type>
               <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               <delay>0;m0-59</delay>
               <history>0</history>
               <trends>0</trends>
               <status>ENABLED</status>
               <value_type>TEXT</value_type>
               <params>SELECT object_name,counter_name,instance_name,cntr_value
FROM sys.dm_os_performance_counters
UNION
SELECT '{$MSSQL.INSTANCE}' as object_name,'Version' as counter_name,@@version as instance_name,0 as cntr_value
UNION
SELECT '{$MSSQL.INSTANCE}' as object_name,'Uptime' as counter_name,'' as instance_name,DATEDIFF(second,sqlserver_start_time,GETDATE()) as cntr_value
FROM sys.dm_os_sys_info
UNION
SELECT '{$MSSQL.INSTANCE}:Databases' as object_name,'State' as counter_name,name as instance_name,state as cntr_value
FROM sys.databases
UNION
SELECT a.object_name,'BufferCacheHitRatio' as counter_name,'' as instance_name,cast(a.cntr_value*100.0/b.cntr_value as dec(3,0)) as cntr_value
FROM sys.dm_os_performance_counters a
JOIN (SELECT cntr_value,OBJECT_NAME
FROM sys.dm_os_performance_counters
WHERE counter_name='Buffer cache hit ratio base' AND OBJECT_NAME='{$MSSQL.INSTANCE}:Buffer Manager') b
ON a.OBJECT_NAME=b.OBJECT_NAME
WHERE a.counter_name='Buffer cache hit ratio' AND a.OBJECT_NAME='{$MSSQL.INSTANCE}:Buffer Manager'
UNION
SELECT a.object_name,'WorktablesFromCacheRatio' as counter_name,'' as instance_name,cast(a.cntr_value*100.0/b.cntr_value as dec(3,0)) as cntr_value
FROM sys.dm_os_performance_counters a
JOIN (SELECT cntr_value,OBJECT_NAME
FROM sys.dm_os_performance_counters
WHERE counter_name='Worktables From Cache Base' AND OBJECT_NAME='{$MSSQL.INSTANCE}:Access Methods') b
ON a.OBJECT_NAME=b.OBJECT_NAME
WHERE a.counter_name='Worktables From Cache Ratio' AND a.OBJECT_NAME='{$MSSQL.INSTANCE}:Access Methods'
UNION
SELECT a.object_name,'CacheHitRatio' as counter_name,'_Total' as instance_name,cast(a.cntr_value*100.0/b.cntr_value as dec(3,0)) as cntr_value
FROM sys.dm_os_performance_counters a
JOIN (SELECT cntr_value,OBJECT_NAME
FROM sys.dm_os_performance_counters
WHERE counter_name='Cache Hit Ratio base' AND OBJECT_NAME='{$MSSQL.INSTANCE}:Plan Cache' AND instance_name='_Total') b
ON a.OBJECT_NAME=b.OBJECT_NAME
WHERE a.counter_name='Cache Hit Ratio' AND a.OBJECT_NAME='{$MSSQL.INSTANCE}:Plan Cache' AND instance_name='_Total'</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>The item gets server global status information.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
            </item>
            <item>
               <name>MSSQL: Auto-param attempts per second</name>
               <type>DEPENDENT</type>
               <key>mssql.autoparam_attempts_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of auto-parameterization attempts per second. The total should be the sum of the failed, safe, and unsafe auto-parameterizations. Auto-parameterization occurs when an instance of SQL Server tries to parameterize a Transact-SQL request by replacing some literals with parameters to me reuse of the resulting cached execution plan across multiple similar-looking requests possible. Note that auto-parameterizations are also known as simple parameterizations in the newer versions of SQL Server. This counter does not include forced parameterizations.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='Auto-Param Attempts/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Average latch wait time</name>
               <type>CALCULATED</type>
               <key>mssql.average_latch_wait_time</key>
               <delay>0;m0-59s3</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>ms</units>
               <params>(last(mssql.average_latch_wait_time_raw) - prev(mssql.average_latch_wait_time_raw)) /
(last(mssql.average_latch_wait_time_base) - prev(mssql.average_latch_wait_time_base) + 
(last(mssql.average_latch_wait_time_base) - prev(mssql.average_latch_wait_time_base)=0))</params>
               <description>Average latch wait time (in milliseconds) for latch requests that had to wait.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
            </item>
            <item>
               <name>MSSQL: Average latch wait time base</name>
               <type>DEPENDENT</type>
               <key>mssql.average_latch_wait_time_base</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>For internal use only.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Latches' &amp;&amp; @.counter_name=='Average Latch Wait Time Base')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Average latch wait time raw</name>
               <type>DEPENDENT</type>
               <key>mssql.average_latch_wait_time_raw</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>ms</units>
               <description>Average latch wait time (in milliseconds) for latch requests that had to wait.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Latches' &amp;&amp; @.counter_name=='Average Latch Wait Time (ms)')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total average wait time</name>
               <type>CALCULATED</type>
               <key>mssql.average_wait_time</key>
               <delay>0;m0-59s3</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>ms</units>
               <params>(last(mssql.average_wait_time_raw) - prev(mssql.average_wait_time_raw)) /
(last(mssql.average_wait_time_base) - prev(mssql.average_wait_time_base) + 
(last(mssql.average_wait_time_base) - prev(mssql.average_wait_time_base)=0))</params>
               <description>The average wait time, in milliseconds, for each lock request that had to wait.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.AVERAGE_WAIT_TIME.MAX}</expression>
                     <name>MSSQL: Total average wait time for locks is high (over {$MSSQL.AVERAGE_WAIT_TIME.MAX}ms for 5m)</name>
                     <priority>WARNING</priority>
                     <description>An average wait time longer than 500ms may indicate excessive blocking. This value should generally correlate to 'Lock Waits/sec' and move up or down with it accordingly.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Total average wait time base</name>
               <type>DEPENDENT</type>
               <key>mssql.average_wait_time_base</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>For internal use only.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Average Wait Time Base' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total average wait time raw</name>
               <type>DEPENDENT</type>
               <key>mssql.average_wait_time_raw</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>ms</units>
               <description>Average amount of wait time (in milliseconds) for each lock request that resulted in a wait. Information for all locks.</description>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Average Wait Time (ms)' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Batch requests per second</name>
               <type>DEPENDENT</type>
               <key>mssql.batch_requests_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Number of Transact-SQL command batches received per second. This statistic is affected by all constraints (such as I/O, number of users, cache size, complexity of requests, and so on). High batch requests mean good throughput.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='Batch Requests/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Buffer cache hit ratio</name>
               <type>DEPENDENT</type>
               <key>mssql.buffer_cache_hit_ratio</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>%</units>
               <description>Indicates the percentage of pages found in the buffer cache without having to read from disk. The ratio is the total number of cache hits divided by the total number of cache lookups over the last few thousand page accesses. After a long period of time, the ratio changes very little. Since reading from the cache is much less expensive than reading from the disk, a higher value is preferred for this item. To increase the buffer cache hit ratio, consider increasing the amount of memory available to SQL Server or using the buffer pool extension feature.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='BufferCacheHitRatio')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{max(5m)}&lt;{$MSSQL.BUFFER_CACHE_RATIO.MIN.CRIT}</expression>
                     <name>MSSQL: Percentage of the buffer cache efficiency is low (below {$MSSQL.BUFFER_CACHE_RATIO.MIN.CRIT}% for 5m)</name>
                     <priority>HIGH</priority>
                     <description>Too low buffer cache hit ratio.</description>
                  </trigger>
                  <trigger>
                     <expression>{max(5m)}&lt;{$MSSQL.BUFFER_CACHE_RATIO.MIN.WARN}</expression>
                     <name>MSSQL: Percentage of the buffer cache efficiency is low (below {$MSSQL.BUFFER_CACHE_RATIO.MIN.WARN}% for 5m)</name>
                     <priority>WARNING</priority>
                     <description>Low buffer cache hit ratio.</description>
                     <dependencies>
                        <dependency>
                           <name>MSSQL: Percentage of the buffer cache efficiency is low (below {$MSSQL.BUFFER_CACHE_RATIO.MIN.CRIT}% for 5m)</name>
                           <expression>{Template DB MSSQL by ODBC:mssql.buffer_cache_hit_ratio.max(5m)}&lt;{$MSSQL.BUFFER_CACHE_RATIO.MIN.CRIT}</expression>
                        </dependency>
                     </dependencies>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Cache hit ratio</name>
               <type>DEPENDENT</type>
               <key>mssql.cache_hit_ratio</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>%</units>
               <description>Ratio between cache hits and lookups.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Plan Cache' &amp;&amp; @.counter_name=='CacheHitRatio' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Cache object counts</name>
               <type>DEPENDENT</type>
               <key>mssql.cache_object_counts</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Number of cache objects in the cache.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Plan Cache' &amp;&amp; @.counter_name=='Cache Object Counts' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Cache objects in use</name>
               <type>DEPENDENT</type>
               <key>mssql.cache_objects_in_use</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Number of cache objects in use.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Plan Cache' &amp;&amp; @.counter_name=='Cache Objects in use' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Cache pages</name>
               <type>DEPENDENT</type>
               <key>mssql.cache_pages</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Number of 8-kilobyte (KB) pages used by cache objects.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Plan Cache' &amp;&amp; @.counter_name=='Cache Pages' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Checkpoint pages per second</name>
               <type>DEPENDENT</type>
               <key>mssql.checkpoint_pages_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Indicates the number of pages flushed to disk per second by a checkpoint or other operation which required all dirty pages to be flushed.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Checkpoint pages/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total data file size</name>
               <type>DEPENDENT</type>
               <key>mssql.data_files_size</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Total size of all data files.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Data File(s) Size (KB)' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Database pages</name>
               <type>DEPENDENT</type>
               <key>mssql.database_pages</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Indicates the number of pages in the buffer pool with database content.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Database pages')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total errors per second</name>
               <type>DEPENDENT</type>
               <key>mssql.errors_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of errors per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Errors' &amp;&amp; @.counter_name=='Errors/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Failed auto-params per second</name>
               <type>DEPENDENT</type>
               <key>mssql.failed_autoparams_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of failed auto-parameterization attempts per second. This number should be small. Note that auto-parameterizations are also known as simple parameterizations in the newer versions of SQL Server.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='Failed Auto-Params/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Forwarded records per second</name>
               <type>DEPENDENT</type>
               <key>mssql.forwarded_records_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of records per second fetched through forwarded record pointers.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Forwarded Records/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Free list stalls per second</name>
               <type>DEPENDENT</type>
               <key>mssql.free_list_stalls_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Indicates the number of requests per second that had to wait for a free page.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Free list stalls/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.FREE_LIST_STALLS.MAX}</expression>
                     <name>MSSQL: Number of rps waiting for a free page is high (over {$MSSQL.FREE_LIST_STALLS.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>Some requests have to wait for a free page.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Full scans per second</name>
               <type>DEPENDENT</type>
               <key>mssql.full_scans_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of unrestricted full scans per second. These can be either base-table or full-index scans. Values greater than 1 or 2 indicate that there are table / Index page scans. If that is combined with high CPU, this counter requires further investigation, otherwise, if the full scans are on small tables, it can be ignored.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Full Scans/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Granted Workspace Memory</name>
               <type>DEPENDENT</type>
               <key>mssql.granted_workspace_memory</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Specifies the total amount of memory currently granted to executing processes, such as hash, sort, bulk copy, and index creation operations.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Granted Workspace Memory (KB)')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Index searches per second</name>
               <type>DEPENDENT</type>
               <key>mssql.index_searches_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of index searches per second. These are used to start a range scan, reposition a range scan, revalidate a scan point, fetch a single index record, and search down the index to locate where to insert a new row.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Index Searches/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Errors per second (Info errors)</name>
               <type>DEPENDENT</type>
               <key>mssql.info_errors_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of errors per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Errors' &amp;&amp; @.counter_name=='Errors/sec' &amp;&amp; @.instance_name=='Info Errors')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Errors per second (Kill connection errors)</name>
               <type>DEPENDENT</type>
               <key>mssql.kill_connection_errors_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of errors per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Errors' &amp;&amp; @.counter_name=='Errors/sec' &amp;&amp; @.instance_name=='Kill Connection Errors')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Latch waits per second</name>
               <type>DEPENDENT</type>
               <key>mssql.latch_waits_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>The number of latch requests that could not be granted immediately. Latches are lightweight means of holding a very transient server resource, such as an address in memory.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Latches' &amp;&amp; @.counter_name=='Latch Waits/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Lazy writes per second</name>
               <type>DEPENDENT</type>
               <key>mssql.lazy_writes_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Indicates the number of buffers written per second by the buffer manager's lazy writer. The lazy writer is a system process that flushes out batches of dirty, aged buffers (buffers that contain changes that must be written back to disk before the buffer can be reused for a different page) and makes them available to user processes. The lazy writer eliminates the need to perform frequent checkpoints in order to create available buffers.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Lazy writes/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.LAZY_WRITES.MAX}</expression>
                     <name>MSSQL: Number of buffers written per second by the lazy writer is high (over {$MSSQL.LAZY_WRITES.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>The number of buffers written per second by the buffer manager's lazy writer exceeds the threshold.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Total lock requests per second</name>
               <type>DEPENDENT</type>
               <key>mssql.lock_requests_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Number of new locks and lock conversions per second requested from the lock manager.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Lock Requests/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.LOCK_REQUESTS.MAX}</expression>
                     <name>MSSQL: Total number of locks per second is high (over {$MSSQL.LOCK_REQUESTS.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>Number of new locks and lock conversions per second requested from the lock manager is high.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Total lock requests per second that timed out</name>
               <type>DEPENDENT</type>
               <key>mssql.lock_timeouts_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Number of timed out lock requests per second, including requests for NOWAIT locks.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Lock Timeouts/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.LOCK_TIMEOUTS.MAX}</expression>
                     <name>MSSQL: Total lock requests per second that timed out is high (over {$MSSQL.LOCK_TIMEOUTS.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>The total number of timed out lock requests per second, including requests for NOWAIT locks, is high.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Lock wait time</name>
               <type>DEPENDENT</type>
               <key>mssql.lock_wait_time</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>ms</units>
               <description>Average of total wait time (in milliseconds) for locks in the last second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Lock Wait Time (ms)' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total lock requests per second that required waiting</name>
               <type>DEPENDENT</type>
               <key>mssql.lock_waits_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Number of lock requests per second that required the caller to wait.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Lock Waits/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;0</expression>
                     <name>MSSQL: Some blocking is occurring for 5m</name>
                     <priority>AVERAGE</priority>
                     <description>Values greater than zero indicate at least some blocking is occurring, while a value of zero can quickly eliminate blocking as a potential root-cause problem.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Total log file size</name>
               <type>DEPENDENT</type>
               <key>mssql.log_files_size</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Total size of all the transaction log files.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log File(s) Size (KB)' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total log file used size</name>
               <type>DEPENDENT</type>
               <key>mssql.log_files_used_size</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>The cumulative used size of all the log files in the database.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log File(s) Used Size (KB)' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Logins per second</name>
               <type>DEPENDENT</type>
               <key>mssql.logins_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Total number of logins started per second. This does not include pooled connections. Any value over 2 may indicate insufcient connection pooling.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:General Statistics' &amp;&amp; @.counter_name=='Logins/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Logouts per second</name>
               <type>DEPENDENT</type>
               <key>mssql.logouts_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Total number of logout operations started per second. Any value over 2 may indicate insufcient connection pooling.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:General Statistics' &amp;&amp; @.counter_name=='Logouts/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Maximum workspace memory</name>
               <type>DEPENDENT</type>
               <key>mssql.maximum_workspace_memory</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Indicates the maximum amount of memory available for executing processes, such as hash, sort, bulk copy, and index creation operations.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Maximum Workspace Memory (KB)')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Memory grants outstanding</name>
               <type>DEPENDENT</type>
               <key>mssql.memory_grants_outstanding</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Specifies the total number of processes that have successfully acquired a workspace memory grant.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Memory Grants Outstanding')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Memory grants pending</name>
               <type>DEPENDENT</type>
               <key>mssql.memory_grants_pending</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Specifies the total number of processes waiting for a workspace memory grant.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Memory Grants Pending')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total lock requests per second that have deadlocks</name>
               <type>DEPENDENT</type>
               <key>mssql.number_deadlocks_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Number of lock requests per second that resulted in a deadlock.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Locks' &amp;&amp; @.counter_name=='Number of Deadlocks/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.DEADLOCKS.MAX}</expression>
                     <name>MSSQL: Number of deadlock is high (over {$MSSQL.DEADLOCKS.MAX} for 5m)</name>
                     <priority>AVERAGE</priority>
                     <description>Too many deadlocks are occurring currently.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Errors per second (DB offline errors)</name>
               <type>DEPENDENT</type>
               <key>mssql.offline_errors_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of errors per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Errors' &amp;&amp; @.counter_name=='Errors/sec' &amp;&amp; @.instance_name=='DB Offline Errors')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Page life expectancy</name>
               <type>DEPENDENT</type>
               <key>mssql.page_life_expectancy</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>s</units>
               <description>Indicates the number of seconds a page will stay in the buffer pool without references.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Page life expectancy')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{max(15m)}&lt;{$MSSQL.PAGE_LIFE_EXPECTANCY.MIN}</expression>
                     <name>MSSQL: Page life expectancy is low (less {$MSSQL.PAGE_LIFE_EXPECTANCY.MIN}min for 15m)</name>
                     <priority>HIGH</priority>
                     <description>The page stays in the buffer pool without references of less time than the threshold value.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Page lookups per second</name>
               <type>DEPENDENT</type>
               <key>mssql.page_lookups_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>rps</units>
               <description>Indicates the number of requests per second to find a page in the buffer pool.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Page lookups/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Page reads per second</name>
               <type>DEPENDENT</type>
               <key>mssql.page_reads_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Indicates the number of physical database page reads that are issued per second. This statistic displays the total number of physical page reads across all databases. Because physical I/O is expensive, you may be able to minimize the cost, either by using a larger data cache, intelligent indexes, and more efficient queries, or by changing the database design.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Page reads/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.PAGE_READS.MAX}</expression>
                     <name>MSSQL: Number of physical database page reads per second is high (over {$MSSQL.PAGE_READS.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>The physical database page reads are issued too frequently.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Page splits per second</name>
               <type>DEPENDENT</type>
               <key>mssql.page_splits_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of page splits per second that occur as the result of overflowing index pages.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Page Splits/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Page writes per second</name>
               <type>DEPENDENT</type>
               <key>mssql.page_writes_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Indicates the number of physical database page writes that are issued per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Page writes/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.PAGE_WRITES.MAX}</expression>
                     <name>MSSQL: Number of physical database page writes per second is high (over {$MSSQL.PAGE_WRITES.MAX} for 5m)</name>
                     <priority>WARNING</priority>
                     <description>The physical database page writes are issued too frequently.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Percent of Adhoc queries running</name>
               <type>CALCULATED</type>
               <key>mssql.percent_of_adhoc_queries</key>
               <delay>0;m0-59s3</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>%</units>
               <params>last(mssql.sql_compilations_sec.rate) * 100 /
(last(mssql.batch_requests_sec.rate) + (last(mssql.batch_requests_sec.rate)=0))</params>
               <description>The ratio of SQL compilations per second to Batch requests per second in percentage.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <triggers>
                  <trigger>
                     <expression>{min(15m)} &gt; {$MSSQL.PERCENT_COMPILATIONS.MAX}</expression>
                     <name>MSSQL: Percent of adhoc queries running is over {$MSSQL.PERCENT_COMPILATIONS.MAX}% for 15m</name>
                     <priority>WARNING</priority>
                     <description>The lower this value is the better. High values often indicate excessive adhoc querying and should be as low as possible. If excessive adhoc querying is happening, try rewriting the queries as procedures or invoke the queries using sp_executeSQL. When rewriting isnt possible, consider using a plan guide or setting the database to parameterization forced mode.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Percent of Recompiled Transact-SQL Objects</name>
               <type>CALCULATED</type>
               <key>mssql.percent_recompilations_to_compilations</key>
               <delay>0;m0-59s3</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>%</units>
               <params>last(mssql.sql_recompilations_sec.rate) * 100 /
(last(mssql.sql_compilations_sec.rate) + (last(mssql.sql_compilations_sec.rate)=0))</params>
               <description>The ratio of SQL re-compilations per second to SQL compilations per second in percentage.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <triggers>
                  <trigger>
                     <expression>{min(15m)} &gt; {$MSSQL.PERCENT_RECOMPILATIONS.MAX}</expression>
                     <name>MSSQL: Percent of times statement recompiles is over {$MSSQL.PERCENT_RECOMPILATIONS.MAX}% for 15m</name>
                     <priority>WARNING</priority>
                     <description>This number should be at or near zero, since recompiles can cause deadlocks and exclusive compile locks. This counters value should follow in proportion to Batch Requests/sec and SQL Compilations/sec.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Number of blocked processes</name>
               <type>DEPENDENT</type>
               <key>mssql.processes_blocked</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Number of currently blocked processes.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:General Statistics' &amp;&amp; @.counter_name=='Processes blocked')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Read-ahead pages per second</name>
               <type>DEPENDENT</type>
               <key>mssql.readahead_pages_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Indicates the number of pages read per second in anticipation of use.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Readahead pages/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Safe auto-params per second</name>
               <type>DEPENDENT</type>
               <key>mssql.safe_autoparams_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of safe auto-parameterization attempts per second. Safe refers to a determination that a cached execution plan can be shared between different similar-looking Transact-SQL statements. SQL Server makes many auto-parameterization attempts some of which turn out to be safe and others fail. Note that auto-parameterizations are also known as simple parameterizations in the newer versions of SQL Server. This does not include forced parameterizations.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='Safe Auto-Params/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Full scans to Index searches ratio</name>
               <type>CALCULATED</type>
               <key>mssql.scan_to_search</key>
               <delay>0;m0-59s3</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <params>last(mssql.full_scans_sec.rate) / (last(mssql.index_searches_sec.rate) + (last(mssql.index_searches_sec.rate)=0))</params>
               <description>The ratio of Full scans per second to Index searches per second. The threshold recommendation is strictly for OLTP workloads.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <triggers>
                  <trigger>
                     <expression>{min(15m)} &gt; 0.001</expression>
                     <name>MSSQL: Index and table scans are often than index searches for 15m</name>
                     <priority>WARNING</priority>
                     <description>Index searches are preferable to index and table scans. For OLTP applications, optimize for more index searches and less scans (preferably, 1 full scan for every 1000 index searches). Index and table scans are expensive I/O operations.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: SQL compilations per second</name>
               <type>DEPENDENT</type>
               <key>mssql.sql_compilations_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of SQL compilations per second. Indicates the number of times the compile code path is entered. Includes compiles caused by statement-level recompilations in SQL Server. After SQL Server user activity is stable, this value reaches a steady state.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='SQL Compilations/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: SQL re-compilations per second</name>
               <type>DEPENDENT</type>
               <key>mssql.sql_recompilations_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of statement recompiles per second. Counts the number of times statement recompiles are triggered. Generally, you want the recompiles to be low.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='SQL Re-Compilations/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Table lock escalations per second</name>
               <type>DEPENDENT</type>
               <key>mssql.table_lock_escalations.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of times locks on a table were escalated to the TABLE or HoBT granularity.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Table Lock Escalations/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Target pages</name>
               <type>DEPENDENT</type>
               <key>mssql.target_pages</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>The optimal number of pages in the buffer pool.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Buffer Manager' &amp;&amp; @.counter_name=='Target pages')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Target server memory</name>
               <type>DEPENDENT</type>
               <key>mssql.target_server_memory</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Indicates the ideal amount of memory the server can consume.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Target Server Memory (KB)')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total latch wait Time</name>
               <type>DEPENDENT</type>
               <key>mssql.total_latch_wait_time</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>ms</units>
               <description>Total latch wait time (in milliseconds) for latch requests in the last second. This value should stay stable compared to the number of latch waits per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Latches' &amp;&amp; @.counter_name=='Total Latch Wait Time (ms)')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total server memory</name>
               <type>DEPENDENT</type>
               <key>mssql.total_server_memory</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <units>B</units>
               <description>Specifies the amount of memory the server has committed using the memory manager.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Memory Manager' &amp;&amp; @.counter_name=='Total Server Memory (KB)')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>1024</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total transactions number</name>
               <type>DEPENDENT</type>
               <key>mssql.transactions</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>The number of currently active transactions of all types.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Transactions' &amp;&amp; @.counter_name=='Transactions')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Total transactions per second</name>
               <type>DEPENDENT</type>
               <key>mssql.transactions_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Total number of transactions started for all databases per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Transactions/sec' &amp;&amp; @.instance_name=='_Total')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Unsafe auto-params per second</name>
               <type>DEPENDENT</type>
               <key>mssql.unsafe_autoparams_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of unsafe auto-parameterization attempts per second. For example, the query has some characteristics that prevent the cached plan from being shared. These are designated as unsafe. This does not count the number of forced parameterizations.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Statistics' &amp;&amp; @.counter_name=='Unsafe Auto-Params/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Uptime</name>
               <type>DEPENDENT</type>
               <key>mssql.uptime</key>
               <delay>0</delay>
               <history>2w</history>
               <trends>0d</trends>
               <status>ENABLED</status>
               <units>uptime</units>
               <description>MS SQL Server uptime in 'N days, hh:mm:ss' format.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}' &amp;&amp; @.counter_name=='Uptime')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{last()}&lt;10m</expression>
                     <name>MSSQL: has been restarted (uptime &lt; 10m)</name>
                     <priority>INFO</priority>
                     <description>Uptime is less than 10 minutes</description>
                     <manual_close>YES</manual_close>
                  </trigger>
                  <trigger>
                     <expression>{nodata(30m)}=1</expression>
                     <name>MSSQL: Failed to fetch info data (or no data for 30m)</name>
                     <priority>INFO</priority>
                     <description>Zabbix has not received data for items for the last 30 minutes.</description>
                     <dependencies>
                        <dependency>
                           <name>MSSQL: Service is unavailable</name>
                           <expression>{Template DB MSSQL by ODBC:net.tcp.service[tcp,{HOST.CONN},{$MSSQL.PORT}].last()}=0</expression>
                        </dependency>
                     </dependencies>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Number users connected</name>
               <type>DEPENDENT</type>
               <key>mssql.user_connections</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Number of users connected to MS SQL Server.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:General Statistics' &amp;&amp; @.counter_name=='User Connections')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Errors per second (User errors)</name>
               <type>DEPENDENT</type>
               <key>mssql.user_errors_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of errors per second.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:SQL Errors' &amp;&amp; @.counter_name=='Errors/sec' &amp;&amp; @.instance_name=='User Errors')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
            </item>
            <item>
               <name>MSSQL: Version</name>
               <type>DEPENDENT</type>
               <key>mssql.version</key>
               <delay>0</delay>
               <history>2w</history>
               <trends>0</trends>
               <status>ENABLED</status>
               <value_type>CHAR</value_type>
               <description>MS SQL Server version.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}' &amp;&amp; @.counter_name=='Version')].instance_name.first()</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{diff()}=1 and {strlen()}&gt;0</expression>
                     <name>MSSQL: Version has changed (new version value received: {ITEM.VALUE})</name>
                     <priority>INFO</priority>
                     <description>MSSQL version has changed. Ack to close.</description>
                     <manual_close>YES</manual_close>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Work files created per second</name>
               <type>DEPENDENT</type>
               <key>mssql.workfiles_created_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of work files created per second. For example, work files can be used to store temporary results for hash joins and hash aggregates.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Workfiles Created/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.WORK_FILES.MAX}</expression>
                     <name>MSSQL: Number of work files created per second is high (over {$MSSQL.WORK_FILES.MAX} for 5m)</name>
                     <priority>AVERAGE</priority>
                     <description>Too many work files created per second to store temporary results for hash joins and hash aggregates.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Work tables created per second</name>
               <type>DEPENDENT</type>
               <key>mssql.worktables_created_sec.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <description>Number of work tables created per second. For example, work tables can be used to store temporary results for query spool, lob variables, XML variables, and cursors.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='Worktables Created/sec')].cntr_value.first()</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{min(5m)}&gt;{$MSSQL.WORK_TABLES.MAX}</expression>
                     <name>MSSQL: Number of work tables created per second is high (over {$MSSQL.WORK_TABLES.MAX} for 5m)</name>
                     <priority>AVERAGE</priority>
                     <description>Too many work tables created per second to store temporary results for query spool, lob variables, XML variables, and cursors.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Worktables from cache ratio</name>
               <type>DEPENDENT</type>
               <key>mssql.worktables_from_cache_ratio</key>
               <delay>0</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <value_type>FLOAT</value_type>
               <units>%</units>
               <description>Percentage of work tables created where the initial two pages of the work table were not allocated but were immediately available from the work table cache.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Access Methods' &amp;&amp; @.counter_name=='WorktablesFromCacheRatio')].cntr_value.first()</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{max(5m)}&lt;{$MSSQL.WORKTABLES_FROM_CACHE_RATIO.MIN.CRIT}</expression>
                     <name>MSSQL: Percentage of work tables available from the work table cache is low (below {$MSSQL.WORKTABLES_FROM_CACHE_RATIO.MIN.CRIT}% for 5m)</name>
                     <priority>HIGH</priority>
                     <description>A value less than 90% may indicate insufcient memory, since execution plans are being dropped, or on 32-bit systems, may indicate the need for an upgrade to a 64-bit system</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>MSSQL: Service's TCP port state</name>
               <type>SIMPLE</type>
               <key>net.tcp.service[tcp,{HOST.CONN},{$MSSQL.PORT}]</key>
               <delay>30s</delay>
               <history>7d</history>
               <status>ENABLED</status>
               <description>Test the availability of MS SQL Server on a TCP port.</description>
               <applications>
                  <application>
                     <name>MSSQL</name>
                  </application>
               </applications>
               <valuemap>
                  <name>Service state</name>
               </valuemap>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>10m</params>
                  </step>
               </preprocessing>
               <triggers>
                  <trigger>
                     <expression>{last()}=0</expression>
                     <name>MSSQL: Service is unavailable</name>
                     <priority>DISASTER</priority>
                     <description>The TCP port of the MS SQL Server service is currently unavailable.</description>
                  </trigger>
               </triggers>
            </item>
         </items>
         <discovery_rules>
            <discovery_rule>
               <name>Availability groups discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[availability_groups,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT name as group_name 
FROM sys.availability_groups</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>Discovery of the existing availability groups.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}': Get replica states</name>
                     <type>ODBC</type>
                     <key>db.odbc.get[{#GROUP_NAME}_replica_states,"{$MSSQL.DSN}"]</key>
                     <history>0h</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <params>SELECT ag.name as group_name,
ISNULL(ags.primary_recovery_health, 2) as primary_recovery_health,
ISNULL(ags.primary_replica, 'Unknown') as primary_replica,
ISNULL(ags.secondary_recovery_health, 2) as secondary_recovery_health,
ags.synchronization_health as synchronization_health
FROM sys.dm_hadr_availability_group_states ags JOIN sys.availability_groups ag ON ag.group_id = ags.group_id</params>
                     <username>{$MSSQL.USER}</username>
                     <password>{$MSSQL.PASSWORD}</password>
                     <description>Getting replica states - name, primary and secondary health, synchronization health.</description>
                     <applications>
                        <application>
                           <name>Zabbix raw items</name>
                        </application>
                     </applications>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}': Primary replica recovery health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.primary_recovery_health["{#GROUP_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Indicates the recovery health of the primary replica:&#13;
0 = In progress&#13;
1 = Online&#13;
2 = Unavailable</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Availability Group '{#GROUP_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Recovery health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}')].primary_recovery_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[{#GROUP_NAME}_replica_states,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}': Primary replica recovery health in progress</name>
                           <priority>WARNING</priority>
                           <description>The primary replica is in the synchronization process.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}': Primary replica name</name>
                     <type>DEPENDENT</type>
                     <key>mssql.primary_replica["{#GROUP_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>CHAR</value_type>
                     <description>Name of the server instance that is hosting the current primary replica.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Availability Group '{#GROUP_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}')].primary_replica.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>3h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[{#GROUP_NAME}_replica_states,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}': Secondary replica recovery health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.secondary_recovery_health["{#GROUP_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Indicates the recovery health of a secondary replica replica:&#13;
0 = In progress&#13;
1 = Online&#13;
2 = Unavailable</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Availability Group '{#GROUP_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Recovery health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}')].secondary_recovery_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[{#GROUP_NAME}_replica_states,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}': Secondary replica recovery health in progress</name>
                           <priority>WARNING</priority>
                           <description>The secondary replica is in the synchronization process.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}': Synchronization health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.synchronization_health["{#GROUP_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Reflects a rollup of the synchronization_health of all availability replicas in the availability group:&#13;
0: Not healthy. None of the availability replicas have a healthy synchronization.&#13;
1: Partially healthy. The synchronization of some, but not all, availability replicas is healthy.&#13;
2: Healthy. The synchronization of every availability replica is healthy.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Availability Group '{#GROUP_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Synchronization health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}')].synchronization_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[{#GROUP_NAME}_replica_states,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}': All replicas unhealthy</name>
                           <priority>DISASTER</priority>
                           <description>None of the availability replicas have a healthy synchronization.</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=1</expression>
                           <name>MSSQL AG '{#GROUP_NAME}': Some replicas unhealthy</name>
                           <priority>HIGH</priority>
                           <description>The synchronization health of some, but not all, availability replicas is healthy.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Database discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[dbname,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT name as dbname 
FROM sys.databases</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <filter>
                  <evaltype>AND</evaltype>
                  <conditions>
                     <condition>
                        <macro>{#DBNAME}</macro>
                        <value>{$MSSQL.DBNAME.MATCHES}</value>
                        <formulaid>A</formulaid>
                     </condition>
                     <condition>
                        <macro>{#DBNAME}</macro>
                        <value>{$MSSQL.DBNAME.NOT_MATCHES}</value>
                        <operator>NOT_MATCHES_REGEX</operator>
                        <formulaid>B</formulaid>
                     </condition>
                  </conditions>
               </filter>
               <description>Scanning databases in DBMS.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last diff backup duration</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.diff.duration["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>Duration of the last differential backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='I')].duration.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last diff backup (time ago)</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.diff["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>The amount of time since the last differential backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='I')].timesincelastbackup.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_DIFF.CRIT:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Diff backup older than {$MSSQL.BACKUP_DIFF.CRIT:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>HIGH</priority>
                           <description>The differential backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_DIFF.WARN:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Diff backup older than {$MSSQL.BACKUP_DIFF.WARN:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>WARNING</priority>
                           <description>The differential backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                           <dependencies>
                              <dependency>
                                 <name>MSSQL DB '{#DBNAME}': Diff backup older than {$MSSQL.BACKUP_DIFF.CRIT:"{#DBNAME}"}</name>
                                 <expression>{Template DB MSSQL by ODBC:mssql.backup.diff["{#DBNAME}"].last()}&gt;{$MSSQL.BACKUP_DIFF.CRIT:"{#DBNAME}"}</expression>
                              </dependency>
                           </dependencies>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last full backup duration</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.full.duration["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>Duration of the last full backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='D')].duration.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last full backup (time ago)</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.full["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>The amount of time since the last full backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='D')].timesincelastbackup.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_FULL.CRIT:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Full backup older than {$MSSQL.BACKUP_FULL.CRIT:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>HIGH</priority>
                           <description>The full backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_FULL.WARN:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Full backup older than {$MSSQL.BACKUP_FULL.WARN:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>WARNING</priority>
                           <description>The full backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                           <dependencies>
                              <dependency>
                                 <name>MSSQL DB '{#DBNAME}': Full backup older than {$MSSQL.BACKUP_FULL.CRIT:"{#DBNAME}"}</name>
                                 <expression>{Template DB MSSQL by ODBC:mssql.backup.full["{#DBNAME}"].last()}&gt;{$MSSQL.BACKUP_FULL.CRIT:"{#DBNAME}"}</expression>
                              </dependency>
                           </dependencies>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last log backup duration</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.log.duration["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>Duration of the last log backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='L')].duration.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Last log backup</name>
                     <type>DEPENDENT</type>
                     <key>mssql.backup.log["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>The amount of time since the last log backup.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}' &amp;&amp; @.type=='L')].timesincelastbackup.first()</params>
                           <error_handler>CUSTOM_VALUE</error_handler>
                           <error_handler_params>0</error_handler_params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_last_backup,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_LOG.CRIT:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Log backup older than {$MSSQL.BACKUP_LOG.CRIT:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>HIGH</priority>
                           <description>The log backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_LOG.WARN:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Log backup older than {$MSSQL.BACKUP_LOG.WARN:"{#DBNAME}"}</name>
                           <opdata>Time since last backup: {ITEM.LASTVALUE1}</opdata>
                           <priority>WARNING</priority>
                           <description>The log backup has not been executed for a long time.</description>
                           <manual_close>YES</manual_close>
                           <dependencies>
                              <dependency>
                                 <name>MSSQL DB '{#DBNAME}': Log backup older than {$MSSQL.BACKUP_LOG.CRIT:"{#DBNAME}"}</name>
                                 <expression>{Template DB MSSQL by ODBC:mssql.backup.log["{#DBNAME}"].last()}&gt;{$MSSQL.BACKUP_LOG.CRIT:"{#DBNAME}"}</expression>
                              </dependency>
                           </dependencies>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Active transactions</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.active_transactions["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Number of active transactions for the database.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Active Transactions' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Data file size</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.data_files_size["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>B</units>
                     <description>Cumulative size of all the data files in the database including any automatic growth. Monitoring this counter is useful, for example, for determining the correct size of tempdb.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Data File(s) Size (KB)' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>1024</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log bytes flushed per second</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_bytes_flushed_sec.rate["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <units>Bps</units>
                     <description>Total number of log bytes flushed per second. Useful for determining trends and utilization of the transaction log.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Bytes Flushed/sec' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log file size</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_files_size["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>B</units>
                     <description>Cumulative size of all the transaction log files in the database.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log File(s) Size (KB)' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>1024</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log file used size</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_files_used_size["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>B</units>
                     <description>Cumulative used size of all the log files in the database.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log File(s) Used Size (KB)' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>1024</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log flush wait time</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_flush_wait_time["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <units>ms</units>
                     <description>Total wait time (in milliseconds) to flush the log. On an AlwaysOn secondary database, this value indicates the wait time for log records to be hardened to disk.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Flush Wait Time' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{min(5m)}&gt;{$MSSQL.LOG_FLUSH_WAIT_TIME.MAX:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Total wait time to flush the log is high (over {$MSSQL.LOG_FLUSH_WAIT_TIME.MAX:"{#DBNAME}"}ms for 5m)</name>
                           <priority>WARNING</priority>
                           <description>The wait time to flush the log is too long.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log flush waits per second</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_flush_waits_sec.rate["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <description>Number of commits per second waiting for the log flush.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Flush Waits/sec' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{min(5m)}&gt;{$MSSQL.LOG_FLUSH_WAITS.MAX:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Number of commits waiting for the log flush is high (over {$MSSQL.LOG_FLUSH_WAITS.MAX:"{#DBNAME}"}/sec for 5m)</name>
                           <priority>WARNING</priority>
                           <description>Too many commits are waiting for the log flush.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log flushes per second</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_flushes_sec.rate["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <description>Number of log flushes per second.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Flushes/sec' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log growths</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_growths["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Total number of times the transaction log for the database has been expanded.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Growths' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log shrinks</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_shrinks["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Total number of times the transaction log for the database has been shrunk.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Shrinks' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log truncations</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.log_truncations["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Number of times the transaction log has been shrunk.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Log Truncations' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Percent log used</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.percent_log_used["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <units>%</units>
                     <description>Percentage of space in the log that is in use.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Percent Log Used' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{min(5m)}&gt;{$MSSQL.PERCENT_LOG_USED.MAX:"{#DBNAME}"}</expression>
                           <name>MSSQL DB '{#DBNAME}': Percent of log using is high (over {$MSSQL.PERCENT_LOG_USED.MAX:"{#DBNAME}"}% for 5m)</name>
                           <priority>WARNING</priority>
                           <description>There's not enough space left in the log.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': State</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.state["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>0 = ONLINE&#13;
1 = RESTORING&#13;
2 = RECOVERING | SQL Server 2008 and later&#13;
3 = RECOVERY_PENDING | SQL Server 2008 and later&#13;
4 = SUSPECT&#13;
5 = EMERGENCY | SQL Server 2008 and later&#13;
6 = OFFLINE | SQL Server 2008 and later&#13;
7 = COPYING | Azure SQL Database Active Geo-Replication&#13;
10 = OFFLINE_SECONDARY | Azure SQL Database Active Geo-Replication</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL DB state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='State' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>15m</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;1</expression>
                           <name>MSSQL DB '{#DBNAME}': State is {ITEM.VALUE}</name>
                           <priority>HIGH</priority>
                           <description>The DB has a non-working state.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL DB '{#DBNAME}': Transactions per second</name>
                     <type>DEPENDENT</type>
                     <key>mssql.db.transactions_sec.rate["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <value_type>FLOAT</value_type>
                     <description>Number of transactions started for the database per second.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Database '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.object_name=='{$MSSQL.INSTANCE}:Databases' &amp;&amp; @.counter_name=='Transactions/sec' &amp;&amp; @.instance_name=='{#DBNAME}')].cntr_value.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_status_variables,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <graph_prototypes>
                  <graph_prototype>
                     <name>MSSQL DB '{#DBNAME}': Log size</name>
                     <graph_items>
                        <graph_item>
                           <color>1A7C11</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.log_files_size["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                        <graph_item>
                           <sortorder>1</sortorder>
                           <color>2774A4</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.log_files_used_size["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                     </graph_items>
                  </graph_prototype>
                  <graph_prototype>
                     <name>MSSQL DB '{#DBNAME}': Number of Log changes</name>
                     <graph_items>
                        <graph_item>
                           <color>1A7C11</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.log_growths["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                        <graph_item>
                           <sortorder>1</sortorder>
                           <color>2774A4</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.log_shrinks["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                        <graph_item>
                           <sortorder>2</sortorder>
                           <color>F63100</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.log_truncations["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                     </graph_items>
                  </graph_prototype>
                  <graph_prototype>
                     <name>MSSQL DB '{#DBNAME}': Size</name>
                     <graph_items>
                        <graph_item>
                           <color>1A7C11</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.db.data_files_size["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                     </graph_items>
                  </graph_prototype>
               </graph_prototypes>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Job discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[jobname,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT name AS jobname FROM msdb..sysjobs WHERE enabled = 1</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <filter>
                  <evaltype>AND_OR</evaltype>
                  <conditions>
                     <condition>
                        <macro>{#JOBNAME}</macro>
                        <value>{$MSSQL.JOB.MATCHES}</value>
                        <formulaid>A</formulaid>
                     </condition>
                     <condition>
                        <macro>{#JOBNAME}</macro>
                        <value>{$MSSQL.JOB.NOT_MATCHES}</value>
                        <operator>NOT_MATCHES_REGEX</operator>
                        <formulaid>B</formulaid>
                     </condition>
                  </conditions>
               </filter>
               <description>Scanning jobs in DBMS.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL Job '{#JOBNAME}': Last run date-time</name>
                     <type>DEPENDENT</type>
                     <key>mssql.job.lastrundatetime["{#JOBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <description>The last date-time of the job run.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Job '{#JOBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.JobName=='{#JOBNAME}')].LastRunDateTime.first()</params>
                           <error_handler>DISCARD_VALUE</error_handler>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1d</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Job '{#JOBNAME}': Last run status message</name>
                     <type>DEPENDENT</type>
                     <key>mssql.job.lastrunstatusmessage["{#JOBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <description>The informational message about the last run of the job.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Job '{#JOBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.JobName=='{#JOBNAME}')].LastRunStatusMessage.first()</params>
                           <error_handler>DISCARD_VALUE</error_handler>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>15m</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Job '{#JOBNAME}': Next run date-time</name>
                     <type>DEPENDENT</type>
                     <key>mssql.job.nextrundatetime["{#JOBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <description>The next date-time of the job run.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Job '{#JOBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.JobName=='{#JOBNAME}')].NextRunDateTime.first()</params>
                           <error_handler>DISCARD_VALUE</error_handler>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>15m</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Job '{#JOBNAME}': Run duration</name>
                     <type>DEPENDENT</type>
                     <key>mssql.job.run_duration["{#JOBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>s</units>
                     <description>Duration of the last run job.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Job '{#JOBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.JobName=='{#JOBNAME}')].RunDuration.first()</params>
                           <error_handler>DISCARD_VALUE</error_handler>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>15m</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;{$MSSQL.BACKUP_DURATION.WARN:"{#JOBNAME}"}</expression>
                           <name>MSSQL Job '{#JOBNAME}': Job duration is greater than {$MSSQL.BACKUP_DURATION.WARN:"{#JOBNAME}"}</name>
                           <opdata>Job duration: {ITEM.LASTVALUE1}</opdata>
                           <priority>WARNING</priority>
                           <description>The job is taking too long.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Job '{#JOBNAME}': Run status</name>
                     <type>DEPENDENT</type>
                     <key>mssql.job.runstatus["{#JOBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>The job status possible values:&#13;
0  Failed&#13;
1  Succeeded&#13;
2  Retry&#13;
3  Canceled&#13;
4  Running</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Job '{#JOBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL Job Run Status</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.JobName=='{#JOBNAME}')].RunStatus.first()</params>
                           <error_handler>DISCARD_VALUE</error_handler>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>15m</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get[get_job_status,"{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL Job '{#JOBNAME}': Failed to run</name>
                           <priority>WARNING</priority>
                           <description>The last run of the job has failed.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Local database discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[local_db,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT ag.name AS group_name, arcs.replica_server_name AS replica_name,
db_name(drs.database_id) AS dbname, drs.is_local
FROM sys.dm_hadr_database_replica_states drs JOIN sys.dm_hadr_availability_replica_cluster_states arcs
ON arcs.replica_id = drs.replica_id
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id
WHERE drs.is_local = 1</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>Discovery of the local availability databases.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': Get local DB states</name>
                     <type>ODBC</type>
                     <key>db.odbc.get["{#GROUP_NAME}_{#DBNAME}_local_db.states","{$MSSQL.DSN}"]</key>
                     <history>0h</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <params>SELECT drs.database_state as database_state, 
drs.is_suspended as is_suspended, 
drs.synchronization_health as synchronization_health, 
ag.name as group_name,
arcs.replica_server_name as replica_name,
db_name(drs.database_id) as dbname
FROM sys.dm_hadr_database_replica_states drs 
JOIN sys.dm_hadr_availability_replica_cluster_states arcs ON arcs.replica_id = drs.replica_id 
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id 
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id</params>
                     <username>{$MSSQL.USER}</username>
                     <password>{$MSSQL.PASSWORD}</password>
                     <description>Getting the states of the local availability database.</description>
                     <applications>
                        <application>
                           <name>Zabbix raw items</name>
                        </application>
                     </applications>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': Suspended</name>
                     <type>DEPENDENT</type>
                     <key>mssql.local_db.is_suspended["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Database state:&#13;
0 = Resumed&#13;
1 = Suspended</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Local DB '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}' &amp;&amp; @.dbname=='{#DBNAME}')].is_suspended.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#DBNAME}_local_db.states","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': State</name>
                     <type>DEPENDENT</type>
                     <key>mssql.local_db.state["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>0 = Online&#13;
1 = Restoring&#13;
2 = Recovering&#13;
3 = Recovery pending&#13;
4 = Suspect&#13;
5 = Emergency&#13;
6 = Offline</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Local DB '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL DB state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}' &amp;&amp; @.dbname=='{#DBNAME}')].database_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#DBNAME}_local_db.states","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': "{#DBNAME}" is {ITEM.VALUE}</name>
                           <priority>WARNING</priority>
                           <description>The local availability database has a non-working state.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': Synchronization health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.local_db.synchronization_health["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Reflects the intersection of the synchronization state of a database that is joined to the availability group on the availability replica and the availability mode of the availability replica (synchronous-commit or asynchronous-commit mode):&#13;
0 = Not healthy. The synchronization_state of the database is 0 (NOT SYNCHRONIZING).&#13;
1 = Partially healthy. A database on a synchronous-commit availability replica is considered &#13;
partially healthy if synchronization_state is 1 (SYNCHRONIZING).&#13;
2 = Healthy. A database on an synchronous-commit availability replica is considered healthy if synchronization_state is 2 (SYNCHRONIZED), and a database on an asynchronous-commit availability replica is considered healthy if synchronization_state is 1 (SYNCHRONIZING).</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Local DB '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Synchronization health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}' &amp;&amp; @.dbname=='{#DBNAME}')].synchronization_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#DBNAME}_local_db.states","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': "{#DBNAME}" is Not healthy</name>
                           <priority>HIGH</priority>
                           <description>The synchronization state of the local availability database is NOT SYNCHRONIZING.</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=1</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Local DB '{#DBNAME}': "{#DBNAME}" is Partially healthy</name>
                           <priority>AVERAGE</priority>
                           <description>A database on a synchronous-commit availability replica is considered partially healthy if synchronization state is SYNCHRONIZING.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Mirroring discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[mirrors,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT db_name(database_id) as dbname
FROM sys.database_mirroring
WHERE mirroring_state_desc IS NOT NULL</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>To see the row for a database other than master or tempdb, you must&#13;
either be the database owner or have at least ALTER ANY DATABASE or VIEW ANY&#13;
DATABASE server-level permission or CREATE DATABASE permission in the master&#13;
database. To see non-NULL values on a mirror database, you must be a member&#13;
of the sysadmin fixed server role.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': Get the mirror state</name>
                     <type>ODBC</type>
                     <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     <history>0h</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <params>SELECT ISNULL(m.mirroring_role,0) as mirroring_role,
ISNULL(m.mirroring_role_sequence,0) as mirroring_role_sequence,
ISNULL(m.mirroring_state,7) as mirroring_state,
ISNULL(m.mirroring_witness_state,3) as mirroring_witness_state,
ISNULL(m.mirroring_safety_level,3) as mirroring_safety_level,
db_name(m.database_id) as dbname 
FROM sys.database_mirroring as m
WHERE m.mirroring_state_desc IS NOT NULL</params>
                     <username>{$MSSQL.USER}</username>
                     <password>{$MSSQL.PASSWORD}</password>
                     <description>Getting mirrors state</description>
                     <applications>
                        <application>
                           <name>Zabbix raw items</name>
                        </application>
                     </applications>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': Role sequence</name>
                     <type>DEPENDENT</type>
                     <key>mssql.mirroring.role_sequence["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>The number of times that mirroring partners have switched the principal and mirror roles due to a failover or forced service.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Mirroring '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}')].mirroring_role_sequence.first()</params>
                        </step>
                        <step>
                           <type>SIMPLE_CHANGE</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': Role</name>
                     <type>DEPENDENT</type>
                     <key>mssql.mirroring.role["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Current role of the local database plays in the database mirroring session.&#13;
1 = Principal&#13;
2 = Mirror</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Mirroring '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL Mirroring Role</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}')].mirroring_role.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': Safety level</name>
                     <type>DEPENDENT</type>
                     <key>mssql.mirroring.safety_level["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Safety setting for updates on the mirror database:&#13;
0 = Unknown state&#13;
1 = Off [asynchronous]&#13;
2 = Full [synchronous]</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Mirroring '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL Safety level</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}')].mirroring_safety_level.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': State</name>
                     <type>DEPENDENT</type>
                     <key>mssql.mirroring.state["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>State of the mirror database and of the database mirroring session.&#13;
0 = Suspended&#13;
1 = Disconnected from the other partner&#13;
2 = Synchronizing&#13;
3 = Pending Failover&#13;
4 = Synchronized&#13;
5 = The partners are not synchronized. Failover is not possible now.&#13;
6 = The partners are synchronized. Failover is potentially possible. For information about the requirements for the failover, see Database Mirroring Operating Modes.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Mirroring '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL Mirroring State</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}')].mirroring_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&gt;=0 and {last()}&lt;=2</expression>
                           <name>MSSQL Mirroring '{#DBNAME}': "{#DBNAME}" is {ITEM.VALUE}</name>
                           <priority>INFO</priority>
                           <description>The state of the mirror database and of the database mirroring session is "Suspended", "Disconnected from the other partner", or "Synchronizing".</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=3</expression>
                           <name>MSSQL Mirroring '{#DBNAME}': "{#DBNAME}" is {ITEM.VALUE}</name>
                           <priority>WARNING</priority>
                           <description>The state of the mirror database and of the database mirroring session is "Pending Failover".</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=5</expression>
                           <name>MSSQL Mirroring '{#DBNAME}': "{#DBNAME}" is {ITEM.VALUE}</name>
                           <priority>HIGH</priority>
                           <description>The state of the mirror database and of the database mirroring session is "Not synchronized". The partners are not synchronized. A failover is not possible now.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': Witness state</name>
                     <type>DEPENDENT</type>
                     <key>mssql.mirroring.witness_state["{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>State of the witness in the database mirroring session of the database:&#13;
0 = Unknown&#13;
1 = Connected&#13;
2 = Disconnected</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Mirroring '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL Witness state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.dbname=='{#DBNAME}')].mirroring_witness_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#DBNAME}_mirroring_state","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=2</expression>
                           <name>MSSQL Mirroring '{#DBNAME}': "{#DBNAME}" Witness is disconnected</name>
                           <priority>WARNING</priority>
                           <description>The state of the witness in the database mirroring session of the database is "Disconnected".</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <graph_prototypes>
                  <graph_prototype>
                     <name>MSSQL Mirroring '{#DBNAME}': States</name>
                     <graph_items>
                        <graph_item>
                           <color>1A7C11</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.mirroring.state["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                        <graph_item>
                           <sortorder>1</sortorder>
                           <color>2774A4</color>
                           <item>
                              <host>Template DB MSSQL by ODBC</host>
                              <key>mssql.mirroring.witness_state["{#DBNAME}"]</key>
                           </item>
                        </graph_item>
                     </graph_items>
                  </graph_prototype>
               </graph_prototypes>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Non-local database discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[non-local_db,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT ag.name AS group_name, arcs.replica_server_name AS replica_name,
db_name(drs.database_id) AS dbname, drs.is_local
FROM sys.dm_hadr_database_replica_states drs JOIN sys.dm_hadr_availability_replica_cluster_states arcs 
ON arcs.replica_id = drs.replica_id 
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id
WHERE drs.is_local = 0</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>Discovery of the non-local (not local to the SQL Server instance) availability databases.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Non-Local DB '*{#REPLICA_NAME}*{#DBNAME}': Get non-local DB states</name>
                     <type>ODBC</type>
                     <key>db.odbc.get["{#GROUP_NAME}*{#REPLICA_NAME}*{#DBNAME}_non-local_db.states","{$MSSQL.DSN}"]</key>
                     <history>0h</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <params>SELECT drs.log_send_queue_size as log_send_queue_size,
drs.redo_queue_size as redo_queue_size,
ag.name as group_name,
arcs.replica_server_name as replica_name,
db_name(drs.database_id) as dbname
FROM sys.dm_hadr_database_replica_states drs 
JOIN sys.dm_hadr_availability_replica_cluster_states arcs ON arcs.replica_id = drs.replica_id 
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id 
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id</params>
                     <username>{$MSSQL.USER}</username>
                     <password>{$MSSQL.PASSWORD}</password>
                     <description>Getting the states of the non-local availability database.</description>
                     <applications>
                        <application>
                           <name>Zabbix raw items</name>
                        </application>
                     </applications>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Non-Local DB '*{#REPLICA_NAME}*{#DBNAME}': Log queue size</name>
                     <type>DEPENDENT</type>
                     <key>mssql.non-local_db.log_send_queue_size["{#GROUP_NAME}*{#REPLICA_NAME}*{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>B</units>
                     <description>Amount of the log records of the primary database that has not been sent to the secondary databases.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Non-Local DB '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}' &amp;&amp; @.dbname=='{#DBNAME}')].log_send_queue_size.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>1024</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}*{#REPLICA_NAME}*{#DBNAME}_non-local_db.states","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last(#1)}&gt;{last(#2)} and {last(#2)}&gt;{last(#3)}</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Non-Local DB '*{#REPLICA_NAME}*{#DBNAME}': Log queue size is growing</name>
                           <priority>HIGH</priority>
                           <description>The log records of the primary database are not sent to the secondary databases.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Non-Local DB '*{#REPLICA_NAME}*{#DBNAME}': Redo log queue size</name>
                     <type>DEPENDENT</type>
                     <key>mssql.non-local_db.redo_queue_size["{#GROUP_NAME}*{#REPLICA_NAME}*{#DBNAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <units>B</units>
                     <description>Amount of log records in the log files of the secondary replica that has not yet been redone.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Non-Local DB '{#DBNAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}' &amp;&amp; @.dbname=='{#DBNAME}')].redo_queue_size.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>1024</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}*{#REPLICA_NAME}*{#DBNAME}_non-local_db.states","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last(#1)}&gt;{last(#2)} and {last(#2)}&gt;{last(#3)}</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Non-Local DB '*{#REPLICA_NAME}*{#DBNAME}': Redo log queue size is growing</name>
                           <priority>HIGH</priority>
                           <description>The log records in the log files of the secondary replica have not yet been redone.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Replication discovery</name>
               <type>ODBC</type>
               <key>db.odbc.discovery[replicas,"{$MSSQL.DSN}"]</key>
               <delay>1h</delay>
               <params>SELECT ag.name as group_name, 
arcs.replica_server_name as replica_name
FROM sys.dm_hadr_availability_replica_cluster_states as arcs 
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id</params>
               <username>{$MSSQL.USER}</username>
               <password>{$MSSQL.PASSWORD}</password>
               <description>Discovery of the database replicas.</description>
               <item_prototypes>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Get the replica state</name>
                     <type>ODBC</type>
                     <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     <history>0h</history>
                     <trends>0</trends>
                     <status>ENABLED</status>
                     <value_type>TEXT</value_type>
                     <params>SELECT ars.connected_state as connected_state,
ars.is_local as is_local,
arcs.join_state as join_state,
ISNULL(ars.operational_state,6) as operational_state,
ISNULL(ars.recovery_health,2) as recovery_health,
ars.role as role,
ars.synchronization_health as synchronization_health,
ag.name as group_name, 
arcs.replica_server_name as replica_name
FROM sys.dm_hadr_availability_replica_cluster_states as arcs 
JOIN sys.availability_groups ag ON ag.group_id = arcs.group_id
JOIN sys.dm_hadr_availability_replica_states ars ON ars.replica_id = arcs.replica_id
WHERE ag.name = '{#GROUP_NAME}' AND arcs.replica_server_name = '{#REPLICA_NAME}'</params>
                     <username>{$MSSQL.USER}</username>
                     <password>{$MSSQL.PASSWORD}</password>
                     <description>Getting the database replica states.</description>
                     <applications>
                        <application>
                           <name>Zabbix raw items</name>
                        </application>
                     </applications>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Connected state</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.connected_state["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Whether a secondary replica is currently connected to the primary replica:&#13;
0 : Disconnected. The response of an availability replica to the DISCONNECTED state depends on its role:&#13;
On the primary replica, if a secondary replica is disconnected, its secondary databases are marked as NOT SYNCHRONIZED on the primary replica, which waits for the secondary to reconnect;&#13;
On a secondary replica, upon detecting that it is disconnected, the secondary replica attempts to reconnect to the primary replica.&#13;
1 : Connected. Each primary replica tracks the connection state for every secondary replica in the same availability group. Secondary replicas track the connection state of only the primary replica.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Connected state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].connected_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Is local</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.is_local["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Whether the replica is local:&#13;
0 = Indicates a remote secondary replica in an availability group whose primary replica is hosted by the local server instance. This value occurs only on the primary replica location.&#13;
1 = Indicates a local replica. On secondary replicas, this is the only available value for the availability group to which the replica belongs.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL - Yes / No</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].is_local.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Join state</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.join_state["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>0 = Not joined&#13;
1 = Joined, standalone instance&#13;
2 = Joined, failover cluster instance</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Join state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].join_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Operational state</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.operational_state["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Current operational state of the replica:&#13;
0 = Pending failover&#13;
1 = Pending&#13;
2 = Online&#13;
3 = Offline&#13;
4 = Failed&#13;
5 = Failed, no quorum&#13;
6 = Not local</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Operational state</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].operational_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0 or {last()}=1 or {last()}=3</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is {ITEM.VALUE}</name>
                           <priority>WARNING</priority>
                           <description>The operational state of the replica in a given availability group is "Pending" or "Offline".</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=4</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is {ITEM.VALUE}</name>
                           <priority>AVERAGE</priority>
                           <description>The operational state of the replica in a given availability group is "Failed".</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=5</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is {ITEM.VALUE}</name>
                           <priority>HIGH</priority>
                           <description>The operational state of the replica in a given availability group is "Failed, no quorum".</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Recovery health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.recovery_health["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Rollup of the database_state column of the sys.dm_hadr_database_replica_states dynamic management view:&#13;
0 : In progress. At least one joined database has a database state other than ONLINE &#13;
(database_state is not 0).&#13;
1 : Online. All the joined databases have a database state of ONLINE (database_state is 0).</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Recovery health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].recovery_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} Recovery in progress</name>
                           <priority>INFO</priority>
                           <description>At least one joined database has a database state other than ONLINE.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Role</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.role["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Current Always On availability groups role of a local replica or a connected remote replica:&#13;
0 = Resolving&#13;
1 = Primary&#13;
2 = Secondary</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Role</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].role.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': Sync health</name>
                     <type>DEPENDENT</type>
                     <key>mssql.replica.synchronization_health["{#GROUP_NAME}_{#REPLICA_NAME}"]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <status>ENABLED</status>
                     <description>Reflects a rollup of the database synchronization state (synchronization_state)of all joined availability databases (also known as replicas) and the availability mode of the replica (synchronous-commit or asynchronous-commit mode). The rollup will reflect the least healthy accumulated state of the databases on the replica:&#13;
0 : Not healthy. At least one joined database is in the NOT SYNCHRONIZING state.&#13;
1 : Partially healthy. Some replicas are not in the target synchronization state: synchronous-commit replicas should be synchronized, and asynchronous-commit replicas should be synchronizing.&#13;
2 : Healthy. All replicas are in the target synchronization state: synchronous-commit replicas are synchronized, and asynchronous-commit replicas are synchronizing.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>MSSQL Available Group '{#GROUP_NAME}' Replica '{#REPLICA_NAME}'</name>
                        </application_prototype>
                     </application_prototypes>
                     <valuemap>
                        <name>MSSQL AG Synchronization health</name>
                     </valuemap>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.group_name=='{#GROUP_NAME}' &amp;&amp; @.replica_name=='{#REPLICA_NAME}')].synchronization_health.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>1h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>db.odbc.get["{#GROUP_NAME}_{#REPLICA_NAME}_replica.state","{$MSSQL.DSN}"]</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}=0</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is Not healthy</name>
                           <priority>AVERAGE</priority>
                           <description>At least one joined database is in the NOT SYNCHRONIZING state.</description>
                        </trigger_prototype>
                        <trigger_prototype>
                           <expression>{last()}=1</expression>
                           <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is Partially healthy</name>
                           <priority>WARNING</priority>
                           <description>Some replicas are not in the target synchronization state: synchronous-commit replicas should be synchronized, and asynchronous-commit replicas should be synchronizing.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <trigger_prototypes>
                  <trigger_prototype>
                     <expression>{Template DB MSSQL by ODBC:mssql.replica.connected_state["{#GROUP_NAME}_{#REPLICA_NAME}"].last()}=0 and {Template DB MSSQL by ODBC:mssql.replica.role["{#GROUP_NAME}_{#REPLICA_NAME}"].last()}=2</expression>
                     <name>MSSQL AG '{#GROUP_NAME}' Replica '{#REPLICA_NAME}': {#REPLICA_NAME} is disconnected</name>
                     <priority>WARNING</priority>
                     <description>The response of an availability replica to the DISCONNECTED state depends on its role: &#13;
On the primary replica, if a secondary replica is disconnected, its secondary databases are marked as NOT SYNCHRONIZED on the primary replica, which waits for the secondary to reconnect; On a secondary replica, upon detecting that it is disconnected, the secondary replica attempts to reconnect to the primary replica.</description>
                  </trigger_prototype>
               </trigger_prototypes>
               <preprocessing>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>1d</params>
                  </step>
               </preprocessing>
            </discovery_rule>
         </discovery_rules>
         <macros>
            <macro>
               <macro>{$MSSQL.AVERAGE_WAIT_TIME.MAX}</macro>
               <value>500</value>
               <description>The maximum average wait time in ms - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_DIFF.CRIT}</macro>
               <value>6d</value>
               <description>The maximum days without a differential backup - for the High trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_DIFF.WARN}</macro>
               <value>3d</value>
               <description>The maximum days without a differential backup - for the Warning trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_DURATION.WARN}</macro>
               <value>1h</value>
               <description>The maximum job duration - for the Warning trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_FULL.CRIT}</macro>
               <value>10d</value>
               <description>The maximum days without a full backup - for the High trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_FULL.WARN}</macro>
               <value>9d</value>
               <description>The maximum days without a full backup - for the Warning trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_LOG.CRIT}</macro>
               <value>8h</value>
               <description>The maximum days without a log backup - for the High trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BACKUP_LOG.WARN}</macro>
               <value>4h</value>
               <description>The maximum days without a log backup - for the Warning trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BUFFER_CACHE_RATIO.MIN.CRIT}</macro>
               <value>30</value>
               <description>The minimum % buffer cache hit ratio - for the High trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.BUFFER_CACHE_RATIO.MIN.WARN}</macro>
               <value>50</value>
               <description>The minimum % buffer cache hit ratio - for the Warning trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.DBNAME.MATCHES}</macro>
               <value>.*</value>
               <description>This macro is used in database discovery. It can be overridden on a host or linked template level.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.DBNAME.NOT_MATCHES}</macro>
               <value>master|tempdb|model|msdb</value>
               <description>This macro is used in database discovery. It can be overridden on a host or linked template level.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.DEADLOCKS.MAX}</macro>
               <value>1</value>
               <description>The maximum deadlocks per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.DSN}</macro>
               <value>&lt;Put your DSN here&gt;</value>
               <description>System data source name.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.FREE_LIST_STALLS.MAX}</macro>
               <value>2</value>
               <description>The maximum free list stalls per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.INSTANCE}</macro>
               <value>SQLServer</value>
               <description>The instance name for the default instance is SQLServer. For named instance set the macro value as MSSQL$instance name.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.JOB.MATCHES}</macro>
               <value>.*</value>
               <description>This macro is used in job discovery. It can be overridden on a host or linked template level.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.JOB.NOT_MATCHES}</macro>
               <value>CHANGE_IF_NEEDED</value>
               <description>This macro is used in job discovery. It can be overridden on a host or linked template level.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.LAZY_WRITES.MAX}</macro>
               <value>20</value>
               <description>The maximum lazy writes per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.LOCK_REQUESTS.MAX}</macro>
               <value>1000</value>
               <description>The maximum lock requests per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.LOCK_TIMEOUTS.MAX}</macro>
               <value>1</value>
               <description>The maximum lock timeouts per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.LOG_FLUSH_WAIT_TIME.MAX}</macro>
               <value>1</value>
               <description>The maximum log flush wait time in ms - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.LOG_FLUSH_WAITS.MAX}</macro>
               <value>1</value>
               <description>The maximum log flush waits per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PAGE_LIFE_EXPECTANCY.MIN}</macro>
               <value>300</value>
               <description>The minimum page life expectancy - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PAGE_READS.MAX}</macro>
               <value>90</value>
               <description>The maximum page reads per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PAGE_WRITES.MAX}</macro>
               <value>90</value>
               <description>The maximum page writes per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PASSWORD}</macro>
               <value>&lt;Put your password here&gt;</value>
               <description>MSSQL user password.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PERCENT_COMPILATIONS.MAX}</macro>
               <value>10</value>
               <description>The maximum percentage of Transact-SQL compilations - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PERCENT_LOG_USED.MAX}</macro>
               <value>80</value>
               <description>The maximum percentage of log used - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PERCENT_READAHEAD.MAX}</macro>
               <value>20</value>
               <description>The maximum percentage of pages read/sec in anticipation of use - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PERCENT_RECOMPILATIONS.MAX}</macro>
               <value>10</value>
               <description>The maximum percentage of Transact-SQL recompilations - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.PORT}</macro>
               <value>1433</value>
               <description>MSSQL TCP port.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.USER}</macro>
               <value>&lt;Put your username here&gt;</value>
               <description>MSSQL username.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.WORK_FILES.MAX}</macro>
               <value>20</value>
               <description>The maximum number of work files created per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.WORK_TABLES.MAX}</macro>
               <value>20</value>
               <description>The maximum number of work tables created per second - for the trigger expression.</description>
            </macro>
            <macro>
               <macro>{$MSSQL.WORKTABLES_FROM_CACHE_RATIO.MIN.CRIT}</macro>
               <value>90</value>
               <description>The minimum percentage of the worktables from cache ratio - for the High trigger expression.</description>
            </macro>
         </macros>
      </template>
   </templates>
   <triggers>
      <trigger>
         <expression>{Template DB MSSQL by ODBC:mssql.forwarded_records_sec.rate.last()} * 100 &gt; 10 * {Template DB MSSQL by ODBC:mssql.batch_requests_sec.rate.last()}</expression>
         <name>MSSQL: Too frequently pointers using</name>
         <priority>WARNING</priority>
         <description>Rows with varchar columns can experience expansion when varchar values are updated with a longer string.  In the case where the row cannot fit in the existing page, the row migrates and access to the row will traverse a pointer.  This only happens on heaps (tables without clustered indexes). Evaluate clustered index for heap tables.  In cases where clustered indexes cannot be used, drop non-clustered indexes, build a clustered index to reorg pages and rows, drop the clustered index, then recreate non-clustered indexes.</description>
      </trigger>
      <trigger>
         <expression>{Template DB MSSQL by ODBC:mssql.readahead_pages_sec.rate.last()} &gt; {$MSSQL.PERCENT_READAHEAD.MAX} / 100 * {Template DB MSSQL by ODBC:mssql.page_reads_sec.rate.last()}</expression>
         <name>MSSQL: Too many physical reads occurring</name>
         <priority>WARNING</priority>
         <description>If this value makes up even a sizeable minority of the total Page Reads/sec (say, greater than 20% of the total page reads), you may have too many physical reads occurring.</description>
      </trigger>
   </triggers>
   <graphs>
      <graph>
         <name>MSSQL: Access methods</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.forwarded_records_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.full_scans_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.index_searches_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.page_splits_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>4</sortorder>
               <color>FC6EA3</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.workfiles_created_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>5</sortorder>
               <color>6C59DC</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.worktables_created_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Auto-params</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.autoparam_attempts_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.failed_autoparams_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.safe_autoparams_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.unsafe_autoparams_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Cache objects</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.cache_object_counts</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.cache_objects_in_use</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Compilations</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.sql_compilations_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.sql_compilations_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Database pages</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.database_pages</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.target_pages</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Errors</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.errors_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.offline_errors_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.info_errors_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.kill_connection_errors_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>4</sortorder>
               <color>FC6EA3</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.user_errors_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Locks</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lock_requests_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lock_timeouts_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.number_deadlocks_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lock_waits_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>4</sortorder>
               <color>FC6EA3</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.average_wait_time</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Logins per second and Logouts per second</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.logins_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.logouts_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Memory/cache load</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.cache_hit_ratio</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.buffer_cache_hit_ratio</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Memory grants outstanding and pending</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.memory_grants_outstanding</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.memory_grants_pending</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Page life expectancy</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.page_life_expectancy</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Pages</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.page_lookups_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.page_reads_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.page_writes_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.readahead_pages_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>4</sortorder>
               <color>FC6EA3</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.checkpoint_pages_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>5</sortorder>
               <color>6C59DC</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.free_list_stalls_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>6</sortorder>
               <color>AC8C14</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lazy_writes_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Processes blocked</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.processes_blocked</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Server memory</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.target_server_memory</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.total_server_memory</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.granted_workspace_memory</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.maximum_workspace_memory</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Transactions</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.transactions_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.batch_requests_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Waits per second</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.latch_waits_sec.rate</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lock_waits_sec.rate</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
      <graph>
         <name>MSSQL: Wait times</name>
         <graph_items>
            <graph_item>
               <color>1A7C11</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.average_latch_wait_time</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>1</sortorder>
               <color>2774A4</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.total_latch_wait_time</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>2</sortorder>
               <color>F63100</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.average_wait_time</key>
               </item>
            </graph_item>
            <graph_item>
               <sortorder>3</sortorder>
               <color>A54F10</color>
               <item>
                  <host>Template DB MSSQL by ODBC</host>
                  <key>mssql.lock_wait_time</key>
               </item>
            </graph_item>
         </graph_items>
      </graph>
   </graphs>
   <value_maps>
      <value_map>
         <name>Service state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Down</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Up</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL DB state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>ONLINE</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>RESTORING</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>RECOVERING</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>RECOVERY_PENDING</newvalue>
            </mapping>
            <mapping>
               <value>4</value>
               <newvalue>SUSPECT</newvalue>
            </mapping>
            <mapping>
               <value>5</value>
               <newvalue>EMERGENCY</newvalue>
            </mapping>
            <mapping>
               <value>6</value>
               <newvalue>OFFLINE</newvalue>
            </mapping>
            <mapping>
               <value>7</value>
               <newvalue>COPYING</newvalue>
            </mapping>
            <mapping>
               <value>10</value>
               <newvalue>OFFLINE_SECONDARY</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Connected state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Disconnected</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Connected</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Join state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Not joined</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Joined, standalone instance</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Joined, failover cluster instance</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Operational state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Pending failover</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Pending</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Online</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>Offline</newvalue>
            </mapping>
            <mapping>
               <value>4</value>
               <newvalue>Failed</newvalue>
            </mapping>
            <mapping>
               <value>5</value>
               <newvalue>Failed, no quorum</newvalue>
            </mapping>
            <mapping>
               <value>6</value>
               <newvalue>Replica is not local</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Recovery health</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>In progress</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Online</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Replica is not local</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Role</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Resolving</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Primary</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Secondary</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Suspend state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Resumed</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Suspended</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL AG Synchronization health</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Not healthy</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Partially healthy</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Healthy</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL - Yes / No</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>No</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Yes</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL Mirroring State</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Suspended</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Disconnected from the other partner</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Synchronizing</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>Pending Failover</newvalue>
            </mapping>
            <mapping>
               <value>4</value>
               <newvalue>Synchronized</newvalue>
            </mapping>
            <mapping>
               <value>5</value>
               <newvalue>The partners are not synchronized. Failover is not possible now.</newvalue>
            </mapping>
            <mapping>
               <value>6</value>
               <newvalue>The partners are synchronized. Failover is potentially possible.</newvalue>
            </mapping>
            <mapping>
               <value>7</value>
               <newvalue>Database is inaccessible or is not mirrored</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL Mirroring Role</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Database is inaccessible or is not mirrored</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Principal</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Mirror</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL Safety level</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Unknown state</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Off [asynchronous]</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Full [synchronous]</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>Database is inaccessible or is not mirrored</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL Witness state</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Unknown</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Connected</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Disconnected</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>No witness exists</newvalue>
            </mapping>
         </mappings>
      </value_map>
      <value_map>
         <name>MSSQL Job Run Status</name>
         <mappings>
            <mapping>
               <value>0</value>
               <newvalue>Failed</newvalue>
            </mapping>
            <mapping>
               <value>1</value>
               <newvalue>Succeeded</newvalue>
            </mapping>
            <mapping>
               <value>2</value>
               <newvalue>Retry</newvalue>
            </mapping>
            <mapping>
               <value>3</value>
               <newvalue>Canceled</newvalue>
            </mapping>
            <mapping>
               <value>4</value>
               <newvalue>Running</newvalue>
            </mapping>
            <mapping>
               <value>5</value>
               <newvalue>Unknown</newvalue>
            </mapping>
         </mappings>
      </value_map>
   </value_maps>
</zabbix_export>
