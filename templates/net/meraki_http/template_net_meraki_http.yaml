zabbix_export:
  version: '8.0'
  template_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Templates/Applications
    - uuid: 36bff6c29af64692839d077febfc7079
      name: 'Templates/Network devices'
  host_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Applications
  templates:
    - uuid: 2fca6b60914b4fa98132b1a7885ab014
      template: 'Cisco Meraki dashboard by HTTP'
      name: 'Cisco Meraki dashboard by HTTP'
      description: |
        Template for monitoring Cisco Meraki dashboard https://meraki.cisco.com/products/meraki-dashboard/
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/
        
        Generated by official Zabbix template tool "Templator"
      wizard_ready: 'YES'
      readme: |
        ## Setup
        
        You must set `Meraki API token` and `Meraki API URL` host wizard configuration fields.
        
        Create the token in the Meraki dashboard (see Meraki [documentation](https://developer.cisco.com/meraki/api-latest/#!authorization/authorization) for instructions). Set this token as `Meraki API token` host wizard configuration field value in Zabbix.
        
        Set your Meraki dashboard URL as `Meraki API URL` host wizard configuration field value in Zabbix (e.g., api.meraki.com/api/v1).
        
        Set filters with host wizard configuration fields if you want to override default filter parameters.
      vendor:
        name: Zabbix
        version: 8.0-2
      groups:
        - name: Templates/Applications
        - name: 'Templates/Network devices'
      items:
        - uuid: d1a5f3c79a604bae98c314d2aed64ff4
          name: 'Get data'
          type: SCRIPT
          key: meraki.get.data
          delay: 1h
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var r_match = '{$MERAKI.ORGANIZATION.NAME.MATCHES}';
            var r_not_match = '{$MERAKI.ORGANIZATION.NAME.NOT_MATCHES}';
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	organizations = [],
            	devices = [];
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = 1 * 60 * 60 * 1000;
            	var waitFor = 1000;
            	
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            		var status = request.getStatus();
            	
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            	
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            	
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            	
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            	
            		return response;
            	}
            };
            
            try {
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	organizations = getHttpData(params.url + 'organizations');
            
            	organizations = organizations.filter(function (x) {
            		return new RegExp(r_match).test(x.name) & !new RegExp(r_not_match).test(x.name);
            	});
            
            	if (Array.isArray(organizations) && organizations.length > 0) {
            		for (i in organizations) {
            			if ('id' in organizations[i] && 'name' in organizations[i]) {
            				try {
            					organization_devices = getHttpData(params.url + 'organizations/' + encodeURIComponent(organizations[i].id) + '/devices/availabilities');
            
            					if (Array.isArray(organization_devices) && organization_devices.length > 0) {
            						for (j in organization_devices) {
            							organization_devices[j].organizationId = organizations[i].id;
            							organization_devices[j].organizationName = organizations[i].name;
            							if (!organization_devices[j].name) {
            								organization_devices[j].name = organization_devices[j].serial;
            							}
            							devices.push(organization_devices[j]);
            						}
            					}
            				} catch (error) {
            					error_msg += organizations[i].name + " organization's devices retrieval error: " + error + '\n';
            				}
            			} else {
            				error_msg += 'There is no ID or organization name in the API response.';
            			}
            		}
            	}
            } catch (error) {
            	error_msg += 'Organizations data retrieval error: ' + error;
            }
            
            return JSON.stringify({
            	organizations: organizations,
            	devices: devices,
            	error: error_msg.toString()
            });
          description: 'Item for gathering all the organizations and devices from Meraki API.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: 6fdd764d820341e7bd2a24f42802c58a
          name: 'Data item errors'
          type: DEPENDENT
          key: meraki.get.data.errors
          value_type: TEXT
          description: 'Item for gathering all the data item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: 2bf9355f548e4e9b9b8581fb43f175fe
              expression: 'length(last(/Cisco Meraki dashboard by HTTP/meraki.get.data.errors))>0'
              name: 'Meraki: There are errors in ''Get data'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
      discovery_rules:
        - uuid: 6488b49e692e4fe8b6a1c57f56b6ba7d
          name: 'Devices discovery'
          type: DEPENDENT
          key: meraki.devices.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$MERAKI.DEVICE.NAME.MATCHES}'
              - macro: '{#NAME}'
                value: '{$MERAKI.DEVICE.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#STATUS}'
                value: '{$MERAKI.DEVICE.STATUS.MATCHES}'
              - macro: '{#STATUS}'
                value: '{$MERAKI.DEVICE.STATUS.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          host_prototypes:
            - uuid: 86d599f384d94b368508a170911213ec
              host: '{#SERIAL}'
              name: '[{#SERIAL}] [{#PRODUCT_TYPE}] {#NAME}'
              group_links:
                - group:
                    name: Applications
              templates:
                - name: 'Cisco Meraki device by HTTP'
              macros:
                - macro: '{$MAC}'
                  value: '{#MAC}'
                  description: 'MAC address of the device.'
                - macro: '{$NETWORK.ID}'
                  value: '{#NETWORK.ID}'
                  description: 'Network ID of the device.'
                - macro: '{$ORGANIZATION_ID}'
                  value: '{#ORGANIZATION_ID}'
                  description: 'Organization ID of the device.'
                - macro: '{$SERIAL}'
                  value: '{#SERIAL}'
                  description: 'Serial number of the device.'
              tags:
                - tag: organization
                  value: '{#ORGANIZATION_NAME}'
                - tag: serial-number
                  value: '{#SERIAL}'
                - tag: type
                  value: '{#PRODUCT_TYPE}'
          master_item:
            key: meraki.get.data
          lld_macro_paths:
            - lld_macro: '{#MAC}'
              path: $.mac
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#NETWORK.ID}'
              path: $.network.id
            - lld_macro: '{#ORGANIZATION_ID}'
              path: $.organizationId
            - lld_macro: '{#ORGANIZATION_NAME}'
              path: $.organizationName
            - lld_macro: '{#PRODUCT_TYPE}'
              path: $.productType
            - lld_macro: '{#SERIAL}'
              path: $.serial
            - lld_macro: '{#STATUS}'
              path: $.status
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.devices
        - uuid: 30f38d19659646009ca436d48f9598b0
          name: 'Organizations discovery'
          type: DEPENDENT
          key: meraki.organization.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$MERAKI.ORGANIZATION.NAME.MATCHES}'
              - macro: '{#NAME}'
                value: '{$MERAKI.ORGANIZATION.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          host_prototypes:
            - uuid: 59cd2e995b814d7e9f8411dbc7420c76
              host: 'meraki-organization-{#ID}'
              name: '[{#REGION}] {#NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#REGION}'
              templates:
                - name: 'Cisco Meraki organization by HTTP'
              macros:
                - macro: '{$ID}'
                  value: '{#ID}'
                  description: 'ID of the organization.'
          master_item:
            key: meraki.get.data
          lld_macro_paths:
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#REGION}'
              path: $.cloud.region.name
            - lld_macro: '{#URL}'
              path: $.url
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.organizations
      tags:
        - tag: class
          value: cloud
        - tag: class
          value: network
        - tag: subclass
          value: camera
        - tag: subclass
          value: firewall
        - tag: subclass
          value: modem
        - tag: subclass
          value: security
        - tag: target
          value: cisco-meraki-dashboard
      macros:
        - macro: '{$MERAKI.API.URL}'
          value: api.meraki.com/api/v1
          description: 'Cisco Meraki dashboard API URL, e.g., api.meraki.com/api/v1'
          config:
            type: TEXT
            priority: '2'
            label: URL
            description: 'Cisco Meraki dashboard API URL, e.g., api.meraki.com/api/v1'
            required: 'YES'
        - macro: '{$MERAKI.DATA.TIMEOUT}'
          value: '60'
          description: 'Response timeout for an API.'
          config:
            type: TEXT
            priority: '3'
            section_name: Other
            label: Timeout
            description: 'Response timeout for an API.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$MERAKI.DEVICE.NAME.MATCHES}'
          value: .+
          description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '6'
            section_name: Filters
            label: 'Filter for device by name'
            description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '7'
            section_name: Filters
            label: 'Filter for device  by name (exclude)'
            description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.STATUS.MATCHES}'
          value: '.*'
          description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '8'
            section_name: Filters
            label: 'Filter for device by status'
            description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.STATUS.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '9'
            section_name: Filters
            label: 'Filter for device by status (exclude)'
            description: 'This macro is used in devices discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.HTTP_PROXY}'
          description: 'HTTP proxy for API requests. You can specify it using the format [protocol://][username[:password]@]proxy.example.com[:port]. See documentation at https://www.zabbix.com/documentation/8.0/manual/config/items/itemtypes/http'
          config:
            type: TEXT
            priority: '10'
            section_name: Other
            label: 'HTTP proxy'
            description: 'HTTP proxy for API requests. You can specify it using the format [protocol://][username[:password]@]proxy.example.com[:port]. See documentation at https://www.zabbix.com/documentation/8.0/manual/config/items/itemtypes/http'
        - macro: '{$MERAKI.ORGANIZATION.NAME.MATCHES}'
          value: .+
          description: 'This macro is used in organizations discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '4'
            section_name: Filters
            label: 'Filter for organization'
            description: 'This macro is used in organizations discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.ORGANIZATION.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in organizations discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '5'
            section_name: Filters
            label: 'Filter for organization (exclude)'
            description: 'This macro is used in organizations discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.TOKEN}'
          type: SECRET_TEXT
          description: 'Cisco Meraki dashboard API token.'
          config:
            type: TEXT
            priority: '1'
            label: Token
            description: 'Cisco Meraki dashboard API token.'
            required: 'YES'
    - uuid: 2cae7d2eeca04e6fa7419759ac9ad814
      template: 'Cisco Meraki device by HTTP'
      name: 'Cisco Meraki device by HTTP'
      description: 'Generated by official Zabbix template tool "Templator"'
      vendor:
        name: Zabbix
        version: 8.0-3
      groups:
        - name: Templates/Applications
        - name: 'Templates/Network devices'
      items:
        - uuid: a45187d4bd154072bc75d76df09708d9
          name: 'Device address'
          type: DEPENDENT
          key: meraki.device.address
          value_type: TEXT
          description: |
            Device location address
            Network: {$NETWORK.ID}
          inventory_link: LOCATION
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.address
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 92b275569cff4013b545b5c251a318ab
          name: Firmware
          type: DEPENDENT
          key: meraki.device.firmware
          value_type: CHAR
          description: |
            Device firmware
            Network: {$NETWORK.ID}
          inventory_link: SOFTWARE
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.firmware
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 0c97a8fcad764133b4e7c35d0134665c
          name: 'Get status'
          type: SCRIPT
          key: meraki.device.get.status
          delay: '{$MERAKI.GET.STATUS.INTERVAL}'
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            function parseTime(timeString) {
            	var match = timeString.match(/^(\d+)([h|m|s])$/);
            	if (match) {
            		var value = parseInt(match[1], 10);
            		var unit = match[2];
            
            		switch (unit) {
            			case 'h':
            				return value * 3600;
            			case 'm':
            				return value * 60;
            			case 's':
            				return value;
            			default:
            				return 0;
            		}
            	}
            
            	return 0;
            };
            
            var response,
            	error_msg = '',
            	response = [],
            	timespan;
            
            	function getHttpData(url) {
            		var startTime = new Date().getTime();
            		var maxWait = parseInt(timespan, 10) * 1000;
            		var waitFor = 1000;
            	
            		while (true) {
            			response = request.get(url);
            			Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            			var status = request.getStatus();
            	
            			if (response !== null) {
            				try {
            					response = JSON.parse(response);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            				}
            			}
            	
            			if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            				response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            				var now = new Date().getTime();
            				var headers = request.getHeaders(false);
            	
            				if ('Retry-After' in headers) {
            					var retryAfter = headers['Retry-After'];
            					Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            					waitFor = parseInt(retryAfter) * 1000;
            				}
            				else {
            					Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            				}
            				if (now - startTime + waitFor > maxWait) {
            					throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            				}
            				Zabbix.sleep(waitFor);
            				continue;
            			}
            	
            			if (status !== 200) {
            				if (response.errors) {
            					throw response.errors.join(', ');
            				}
            				else {
            					throw 'Failed to receive data: invalid response status code.';
            				}
            			}
            	
            			if (typeof (response) !== 'object' || response === null) {
            				throw 'Cannot process response data: received data is not an object.';
            			}
            	
            			return response;
            		}
            	};
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	timespan = parseTime('{$MERAKI.GET.STATUS.INTERVAL}');
            
            	response = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/devices/availabilities?serials[]=' + encodeURIComponent(params.serial));
            	if (Array.isArray(response) & response.length > 0) {
            		response = response[0]
            	}
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'data': response,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering device status from Meraki API.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ORGANIZATION_ID}'
            - name: serial
              value: '{$SERIAL}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: b1873bc0a185452dbede07373e0e4a93
          name: 'Device status item errors'
          type: DEPENDENT
          key: meraki.device.get.status.errors
          value_type: TEXT
          description: 'Item for gathering errors of the device status item.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.device.get.status
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: 0f629d0aef6b456fb3d5b1a20ece54ac
              expression: 'length(last(/Cisco Meraki device by HTTP/meraki.device.get.status.errors))>0'
              name: 'Meraki: There are errors in ''Get status'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 878cbc22039b4fab9949c1997041b1a8
          name: 'Device latitude'
          type: DEPENDENT
          key: meraki.device.latitude
          value_type: CHAR
          description: |
            Latitude of the device location
            Network: {$NETWORK.ID}
          inventory_link: LOCATION_LAT
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.lat
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: de69a544bf9047da9f47b0b8f6c61bf2
          name: 'Device longitude'
          type: DEPENDENT
          key: meraki.device.longitude
          value_type: CHAR
          description: |
            Longitude of the device location
            Network: {$NETWORK.ID}
          inventory_link: LOCATION_LON
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.lng
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 3867fdab6af941ab9958b05b197419df
          name: 'MAC address'
          type: DEPENDENT
          key: meraki.device.mac.address
          value_type: CHAR
          description: |
            Device MAC address
            Network: {$NETWORK.ID}
          inventory_link: MACADDRESS_A
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.mac
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: network
        - uuid: e66780872dba46dc9265c4dad022a799
          name: 'Device model'
          type: DEPENDENT
          key: meraki.device.model
          value_type: CHAR
          description: |
            Device model
            Network: {$NETWORK.ID}
          inventory_link: MODEL
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.model
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 514db363389741619b3103fd57ec0675
          name: 'Device notes'
          type: DEPENDENT
          key: meraki.device.notes
          value_type: TEXT
          description: |
            Notes about the device
            Network: {$NETWORK.ID}
          inventory_link: NOTES
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.notes
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 9c36f19a2d72418dbef579142722372f
          name: 'Device OS'
          type: DEPENDENT
          key: meraki.device.os
          value_type: CHAR
          description: |
            Device operation system
            Network: {$NETWORK.ID}
          inventory_link: OS
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.deviceInfo.details[0].value'
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 2280b9212c474d99835ec1334ff780eb
          name: 'Public IP'
          type: DEPENDENT
          key: meraki.device.public.ip
          value_type: CHAR
          description: |
            Device public IP
            Network: {$NETWORK.ID}
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.ip
            - type: NOT_MATCHES_REGEX
              parameters:
                - ^null$
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: network
        - uuid: fa98beea4eca47859cc53a7d6bcf2008
          name: 'Serial number'
          type: DEPENDENT
          key: meraki.device.serialnumber
          value_type: CHAR
          description: |
            Device serial number
            Network: {$NETWORK.ID}
          inventory_link: SERIALNO_A
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.deviceInfo.serial
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: system
        - uuid: 324b748bfe2e4383927176046e246acb
          name: Status
          type: DEPENDENT
          key: meraki.device.status
          description: |
            Device operational status
            Network: {$NETWORK.ID}
          valuemap:
            name: 'Device status'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.status
              error_handler: DISCARD_VALUE
            - type: JAVASCRIPT
              parameters:
                - |
                  switch (value) {
                  	case 'offline':
                  		return 0
                  	case 'online':
                  		return 1
                  	case 'dormant':
                  		return 2
                  	default:
                  		return 10
                  }
          master_item:
            key: meraki.device.get.status
          tags:
            - tag: component
              value: health
          triggers:
            - uuid: 00583ac9e9824f7db22a1685421f0be9
              expression: 'last(/Cisco Meraki device by HTTP/meraki.device.status)<>1'
              name: 'Meraki: Status is not online'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: e4963b68cdde453f91767ff9e3a31d16
          name: 'Get device data'
          type: SCRIPT
          key: meraki.get.device
          delay: '{$MERAKI.UPLINK.LL.TIMESPAN}'
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	device = [],
            	uplinksLL = [],
            	timespan;
            
            function isFloat(n) {
            	n = parseFloat(n);
            	return Number(n) === n && n % 1 !== 0;
            };
            
            function checkNumber(string) {
            	if (typeof string !== "string" || isNaN(string) || isFloat(string)) {
            		throw 'Incorrect "timespan" parameter given: ' + string + ' Must be an unsigned number';
            	}
            	return string;
            };
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = (parseInt(timespan, 10) - 10) * 1000;
            	var waitFor = 1000;
            
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		var status = request.getStatus();
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	timespan = checkNumber('{$MERAKI.UPLINK.LL.TIMESPAN}');
            
            	if (timespan > 86400 || timespan < 1) {
            		throw 'Incorrect "timespan" parameter given: ' + timespan + ' Must be between 1 and 86400 seconds.';
            	}
            
            	uplinksLL = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/devices/uplinksLossAndLatency?timespan=' + timespan);
            
            	if (uplinksLL.length > 0) {
            		uplinksLL = uplinksLL.filter(function (device) {
            			return device.serial == params.serial;
            		});
            	}
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'uplinksLL': uplinksLL,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering device data from Meraki API.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ORGANIZATION_ID}'
            - name: serial
              value: '{$SERIAL}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: b673516073354c9aaaf60cf3ce2e2fa6
          name: 'Device data item errors'
          type: DEPENDENT
          key: meraki.get.device.errors
          value_type: TEXT
          description: 'Item for gathering errors of the device item.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.device
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: c8f8af6c92f14dc0bcdf426b124c7344
              expression: 'length(last(/Cisco Meraki device by HTTP/meraki.get.device.errors))>0'
              name: 'Meraki: There are errors in ''Get device data'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: ae461bc520a840d9b0f0847011f52bce
          name: 'Get inventory data'
          type: SCRIPT
          key: meraki.get.inventory
          delay: '{$MERAKI.GET.INVENTORY.INTERVAL}'
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            function parseTime(timeString) {
            	var match = timeString.match(/^(\d+)([h|m|s])$/);
            	if (match) {
            		var value = parseInt(match[1], 10);
            		var unit = match[2];
            
            		switch (unit) {
            			case 'h':
            				return value * 3600;
            			case 'm':
            				return value * 60;
            			case 's':
            				return value;
            			default:
            				return 0;
            		}
            	}
            
            	return 0;
            };
            
            var response,
            	error_msg = '',
            	deviceInfo = [],
            	timespan;
            
            	function getHttpData(url) {
            		var startTime = new Date().getTime();
            		var maxWait = parseInt(timespan, 10) * 1000;
            		var waitFor = 1000;
            	
            		while (true) {
            			response = request.get(url);
            			Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            			var status = request.getStatus();
            	
            			if (response !== null) {
            				try {
            					response = JSON.parse(response);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            				}
            			}
            	
            			if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            				response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            				var now = new Date().getTime();
            				var headers = request.getHeaders(false);
            	
            				if ('Retry-After' in headers) {
            					var retryAfter = headers['Retry-After'];
            					Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            					waitFor = parseInt(retryAfter) * 1000;
            				}
            				else {
            					Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            				}
            				if (now - startTime + waitFor > maxWait) {
            					throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            				}
            				Zabbix.sleep(waitFor);
            				continue;
            			}
            	
            			if (status !== 200) {
            				if (response.errors) {
            					throw response.errors.join(', ');
            				}
            				else {
            					throw 'Failed to receive data: invalid response status code.';
            				}
            			}
            	
            			if (typeof (response) !== 'object' || response === null) {
            				throw 'Cannot process response data: received data is not an object.';
            			}
            	
            			return response;
            		}
            	};
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	timespan = parseTime('{$MERAKI.GET.INVENTORY.INTERVAL}');
            
            	deviceInfo = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/devices?serial=' + encodeURIComponent(params.serial));
            	deviceInfo = (deviceInfo && Array.isArray(deviceInfo) && deviceInfo.length > 0) ? deviceInfo[0] : [];
            	deviceInfo['ip'] = (typeof deviceInfo.lanIp !== 'undefined') ? deviceInfo['lanIp'] : deviceInfo['wan1Ip'];
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'deviceInfo': deviceInfo,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering device inventory data from Meraki API.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ORGANIZATION_ID}'
            - name: serial
              value: '{$SERIAL}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: eb8c1772e6b940998b5eaa9fc95f92a5
          name: 'Device inventory data item errors'
          type: DEPENDENT
          key: meraki.get.inventory.errors
          value_type: TEXT
          description: 'Item for gathering errors of the inventory data item.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.inventory
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: af0fa91e3e03415683c3fa2761ad7328
              expression: 'length(last(/Cisco Meraki device by HTTP/meraki.get.inventory.errors))>0'
              name: 'Meraki: There are errors in ''Get inventory data'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
      discovery_rules:
        - uuid: 9c7e5d2ccad7416b8d58237be4218154
          name: 'Uplinks loss and quality discovery'
          type: DEPENDENT
          key: meraki.device.uplinks.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#IP}'
                value: '{$MERAKI.DEVICE.LOSS.LATENCY.IP.MATCHES}'
              - macro: '{#IP}'
                value: '{$MERAKI.DEVICE.LOSS.LATENCY.IP.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#UPLINK}'
                value: '{$MERAKI.DEVICE.UPLINK.MATCHES}'
              - macro: '{#UPLINK}'
                value: '{$MERAKI.DEVICE.UPLINK.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: abf642b1bb944d16bebf90dcf58dbd86
              name: 'Uplink [{#IP}]: [{#UPLINK}]: Latency'
              type: DEPENDENT
              key: 'meraki.device.latency[{#IP},{#UPLINK}]'
              value_type: FLOAT
              units: s
              description: |
                Latency of the device uplink. 
                Network: {#NETWORK.ID}. 
                Device serial: {#SERIAL}.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.uplinksLL[?(@.ip == ''{#IP}'' && @.uplink== ''{#UPLINK}'')].timeSeries.[0].latencyMs.first()'
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '-1000'
                - type: MULTIPLIER
                  parameters:
                    - '0.001'
              master_item:
                key: meraki.get.device
              tags:
                - tag: component
                  value: network
                - tag: ip
                  value: '{#IP}'
                - tag: network
                  value: '{#NETWORK.ID}'
                - tag: serial-number
                  value: '{#SERIAL}'
                - tag: uplink
                  value: '{#UPLINK}'
              trigger_prototypes:
                - uuid: b559ad94b15848089d89e85e4d9db7ff
                  expression: 'min(/Cisco Meraki device by HTTP/meraki.device.latency[{#IP},{#UPLINK}],#3)>{$MERAKI.DEVICE.LATENCY}'
                  name: 'Meraki: Uplink [{#IP}]: [{#UPLINK}]: latency > {$MERAKI.DEVICE.LATENCY}'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: performance
            - uuid: bded34f64113486ab0672210e5a8eb1d
              name: 'Uplink [{#IP}]: [{#UPLINK}]: Loss, %'
              type: DEPENDENT
              key: 'meraki.device.loss.pct[{#IP},{#UPLINK}]'
              value_type: FLOAT
              units: '%'
              description: |
                Loss percent of the device uplink. 
                Network: {#NETWORK.ID}. 
                Device serial: {#SERIAL}.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.uplinksLL[?(@.ip == ''{#IP}'' && @.uplink== ''{#UPLINK}'')].timeSeries.[0].lossPercent.first()'
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '-1'
              master_item:
                key: meraki.get.device
              tags:
                - tag: component
                  value: network
                - tag: ip
                  value: '{#IP}'
                - tag: network
                  value: '{#NETWORK.ID}'
                - tag: serial-number
                  value: '{#SERIAL}'
                - tag: uplink
                  value: '{#UPLINK}'
              trigger_prototypes:
                - uuid: 1309e71025614ce4bb4242e6e291ae48
                  expression: 'min(/Cisco Meraki device by HTTP/meraki.device.loss.pct[{#IP},{#UPLINK}],#3)>{$MERAKI.DEVICE.LOSS}'
                  name: 'Meraki: Uplink [{#IP}]: [{#UPLINK}]: loss > {$MERAKI.DEVICE.LOSS}%'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: performance
          graph_prototypes:
            - uuid: 4e9d84e08b32489c8c3a2cbbd4c6119a
              name: 'Uplink [{#IP}]: [{#UPLINK}]: Latency'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki device by HTTP'
                    key: 'meraki.device.latency[{#IP},{#UPLINK}]'
            - uuid: ebf262afc6d94d29b9831d418fb07edb
              name: 'Uplink [{#IP}]: [{#UPLINK}]: Loss'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki device by HTTP'
                    key: 'meraki.device.loss.pct[{#IP},{#UPLINK}]'
          master_item:
            key: meraki.get.device
          lld_macro_paths:
            - lld_macro: '{#IP}'
              path: $.ip
            - lld_macro: '{#NETWORK.ID}'
              path: $.networkId
            - lld_macro: '{#SERIAL}'
              path: $.serial
            - lld_macro: '{#UPLINK}'
              path: $.uplink
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.uplinksLL
      tags:
        - tag: class
          value: cloud
        - tag: class
          value: network
        - tag: subclass
          value: camera
        - tag: subclass
          value: firewall
        - tag: subclass
          value: modem
        - tag: subclass
          value: security
        - tag: target
          value: cisco-meraki-dashboard
      macros:
        - macro: '{$MERAKI.API.URL}'
          value: api.meraki.com/api/v1
          description: 'Cisco Meraki dashboard API URL, e.g., api.meraki.com/api/v1'
        - macro: '{$MERAKI.DATA.TIMEOUT}'
          value: '60'
          description: 'Response timeout for an API.'
        - macro: '{$MERAKI.DEVICE.LATENCY}'
          value: '0.15'
          description: 'Devices uplink latency threshold, in seconds.'
        - macro: '{$MERAKI.DEVICE.LOSS}'
          value: '15'
          description: 'Devices uplink loss threshold, in percent.'
        - macro: '{$MERAKI.DEVICE.LOSS.LATENCY.IP.MATCHES}'
          value: '^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$'
          description: 'This macro is used in loss and latency checks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.LOSS.LATENCY.IP.NOT_MATCHES}'
          value: ^null$
          description: 'This macro is used in loss and latency checks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.UPLINK.MATCHES}'
          value: '.*'
          description: 'This macro is used in loss and latency checks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.DEVICE.UPLINK.NOT_MATCHES}'
          value: ^null$
          description: 'This macro is used in loss and latency checks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.GET.INVENTORY.INTERVAL}'
          value: 12h
          description: 'The update interval for the script item that retrieves inventory data from API.'
        - macro: '{$MERAKI.GET.STATUS.INTERVAL}'
          value: '300'
          description: 'Update interval for get status item.'
        - macro: '{$MERAKI.HTTP_PROXY}'
          description: 'HTTP proxy for API requests. You can specify it using the format [protocol://][username[:password]@]proxy.example.com[:port]. See documentation at https://www.zabbix.com/documentation/8.0/manual/config/items/itemtypes/http'
        - macro: '{$MERAKI.TOKEN}'
          type: SECRET_TEXT
          description: 'Cisco Meraki dashboard API token.'
        - macro: '{$MERAKI.UPLINK.LL.TIMESPAN}'
          value: '180'
          description: 'Timespan in seconds for getting device uplinks loss and quality stats. Used in the metric configuration and in the JavaScript API query. Must be between 1 and 86400 seconds.'
      dashboards:
        - uuid: 76c4525eacc64f268572fefd76accc2f
          name: 'Meraki: General'
          pages:
            - name: 'Meraki: Uplinks'
              widgets:
                - type: graphprototype
                  name: Loss
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki device by HTTP'
                        name: 'Uplink [{#IP}]: [{#UPLINK}]: Loss'
                    - type: STRING
                      name: reference
                      value: AAAAA
                - type: graphprototype
                  name: Latency
                  x: '36'
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki device by HTTP'
                        name: 'Uplink [{#IP}]: [{#UPLINK}]: Latency'
                    - type: STRING
                      name: reference
                      value: AAAAB
      valuemaps:
        - uuid: 24967dff65a048578eae18b2485907cb
          name: 'Device status'
          mappings:
            - value: '0'
              newvalue: offline
            - value: '1'
              newvalue: online
            - value: '2'
              newvalue: dormant
            - value: '10'
              newvalue: unknown
    - uuid: 39e2f742d0b24ea489b7f61d27a5df1c
      template: 'Cisco Meraki organization by HTTP'
      name: 'Cisco Meraki organization by HTTP'
      description: 'Generated by official Zabbix template tool "Templator"'
      vendor:
        name: Zabbix
        version: 8.0-2
      groups:
        - name: Templates/Applications
        - name: 'Templates/Network devices'
      items:
        - uuid: 495f3a6047644dadadbbc676ba6900f9
          name: 'Account lockout attempts'
          type: DEPENDENT
          key: meraki.account.lockout.attempts
          description: 'Number of consecutive failed login attempts after which users'' accounts will be locked.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.accountLockoutAttempts
            - type: NOT_MATCHES_REGEX
              parameters:
                - ^null$
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: 25f8f61ddf964f39b39cc38b23b017b9
          name: 'Get list of adaptive policy aggregate statistics'
          type: SCRIPT
          key: meraki.get.adaptive.policy
          delay: 20m
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	result = [];
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = 10 * 60 * 1000;
            	
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            		var status = request.getStatus();
            	
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            	
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			if (now - startTime + 1000 > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(1000);
            			continue;
            		}
            	
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			} else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            	
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            	
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	result = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/adaptivePolicy/overview');
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'data': result,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering adaptive policy aggregate statistics for the organization.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: fb9d953ca0d7446d9a8056ce9e716d92
          name: 'Adaptive policy item errors'
          type: DEPENDENT
          key: meraki.get.adaptive.policy.errors
          value_type: TEXT
          description: 'Item for gathering all the adaptive policy item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: 8312e99efbca4a4bbbba8858076186a9
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.adaptive.policy.errors))>0'
              name: 'Meraki: There are errors in ''Get adaptive policy'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: cf5733581c00445b9598ad23e48d34d8
          name: 'Configuration change log'
          type: DEPENDENT
          key: meraki.get.configuration.changelog
          value_type: TEXT
          description: 'Item for viewing the change log for your organization.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 2h
          master_item:
            key: meraki.get.configuration.changes
          tags:
            - tag: component
              value: log
          triggers:
            - uuid: 2fc56ad4baef4796a3ad7d097cad918f
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.configuration.changelog))>3'
              name: 'Meraki: Configuration has been changed'
              priority: WARNING
              tags:
                - tag: scope
                  value: security
        - uuid: f2a65bce3adf4511a3f37ed4caa66b3d
          name: 'Get list of configuration changes'
          type: SCRIPT
          key: meraki.get.configuration.changes
          delay: '{$MERAKI.CONFIG.CHANGE.TIMESPAN}'
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	result = [],
            	timespan;
            
            function isFloat(n) {
            	n = parseFloat(n);
            	return Number(n) === n && n % 1 !== 0;
            };
            
            function checkNumber(string) {
            	if (typeof string !== "string" || isNaN(string) || isFloat(string)) {
            		throw 'Incorrect "timespan" parameter given: ' + string + ' Must be an unsigned number';
            	}
            	return string;
            };
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = parseInt(timespan, 10) * 1000;
            	var waitFor = 1000;
            
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		var status = request.getStatus();
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	timespan = checkNumber('{$MERAKI.CONFIG.CHANGE.TIMESPAN}');
            
            	if (timespan > 86400 || timespan < 1) {
            		throw 'Incorrect "timespan" parameter given: ' + timespan + ' Must be between 1 and 86400 seconds.';
            	}
            
            	result = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/configurationChanges?timespan=' + timespan);
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'data': result,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering all the configuration changes for the organization. Gathering once per 20m by default.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: 05038571b3c04743bb808da343f335b6
          name: 'Configuration changes item errors'
          type: DEPENDENT
          key: meraki.get.configuration.changes.errors
          value_type: TEXT
          description: 'Item for gathering all the configuration changes item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.configuration.changes
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: ce83cc3e1a8a44168df7809d239743c3
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.configuration.changes.errors))>0'
              name: 'Meraki: There are errors in ''Get configuration changes'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 3306da0ec0d749829db2f5f42e4e7876
          name: 'Get data'
          type: SCRIPT
          key: meraki.get.data
          delay: 12h
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	licenseStates = [],
            	samlSSO = [],
            	samlRoles = [],
            	adminAccount = [],
            	loginSecurity = [];
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = 1 * 60 * 60 * 1000;
            	var waitFor = 1000;
            	
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            		var status = request.getStatus();
            	
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            	
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            	
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            	
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            	
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	licenseStates = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/licenses/overview');
            	samlSSO = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/saml');
            	samlRoles = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/samlRoles');
            	adminAccount = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/admins');
            	loginSecurity = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/loginSecurity');
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'licenseStates': licenseStates,
            	'samlSSO': samlSSO,
            	'samlRoles': samlRoles,
            	'adminAccount': adminAccount,
            	'loginSecurity': loginSecurity,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering data for the organization.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: 8ce70f6703cd49e594a723040d17ee3b
          name: 'Get data item errors'
          type: DEPENDENT
          key: meraki.get.data.errors
          value_type: TEXT
          description: 'Item for gathering all the ''Get data'' item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: adef482dadf240fbb211fe4c9b638fbc
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.data.errors))>0'
              name: 'Meraki: There are errors in ''Get data'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 8ea56a7338f040fcbb9016da892dec90
          name: 'Get list licenses'
          type: SCRIPT
          key: meraki.get.list.licenses
          delay: 12h
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	organization_devices = [],
            	licenses = [];
            
            function getField(data, path) {
            	var steps = path.split('.');
            	for (var i = 0; i < steps.length; i++) {
            		var step = steps[i];
            		if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            			throw 'Required field was not found: ' + path;
            		}
            		data = data[step];
            	}
            
            	return data;
            
            };
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = 1 * 60 * 60 * 1000;
            	var waitFor = 1000;
            	
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            	
            		var status = request.getStatus();
            	
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            	
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            	
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            	
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            	
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	licenses = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/licenses');
            
            	organization_devices = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/devices/statuses');
            
            	licenses.forEach(function (license) {
            
            		license.deviceName = getField(license, 'deviceSerial');
            
            		for (i in organization_devices) {
            
            			if (getField(license, 'deviceSerial') === getField(organization_devices[i], 'serial')) {
            
            				device_name = getField(organization_devices[i], 'name');
            
            				if (!device_name) {
            					device_name = getField(organization_devices[i], 'serial');
            				}
            				license.deviceName = device_name;
            			}
            		}
            	});
            
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'licenses': licenses,
            	'error': error_msg.toString()
            });
          description: 'Return list of the licenses for the organization.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: efe8853443d44eed8daeecee5ab9e481
          name: 'Get list of the networks'
          type: SCRIPT
          key: meraki.get.networks
          delay: 3m
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	networks = [],
            	uplinks = [];
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = 1 * 60 * 1000;
            	var waitFor = 1000;
            		
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            		
            		var status = request.getStatus();
            		
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            		
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            		
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            		
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            		
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !==  'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	networks = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/networks');
            
            	responseUplinks = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/appliance/uplink/statuses');
            
            	if (typeof responseUplinks !== 'undefined' && Array.isArray(responseUplinks)) {
            		for (var i in responseUplinks) {
            			if ('networkId' in responseUplinks[i] && typeof networks !== 'undefined' && Array.isArray(networks)) {
            				network = networks.filter(function (x) { return x.id == responseUplinks[i].networkId; });
            			}
            
            			if (typeof responseUplinks[i].uplinks !== 'undefined' && Array.isArray(responseUplinks[i].uplinks)) {
            				for (var p in responseUplinks[i].uplinks) {
            					if (typeof network[0].name !== 'undefined') {
            						responseUplinks[i].uplinks[p].networkName = network[0].name;
            					}
            					if (typeof network[0].timeZone !== 'undefined') {
            						responseUplinks[i].uplinks[p].timeZone = network[0].timeZone;
            					}
            					if ('highAvailability' in responseUplinks[i] && 'role' in responseUplinks[i].highAvailability) {
            						responseUplinks[i].uplinks[p].role = responseUplinks[i].highAvailability.role;
            					}
            					if ('serial' in responseUplinks[i]) {
            						responseUplinks[i].uplinks[p].serial = responseUplinks[i].serial;
            					}
            
            					uplinks.push(responseUplinks[i].uplinks[p]);
            				}
            			}
            		}
            	}
            
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'uplinks': uplinks,
            	'networks': networks,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering all the networks of organization from Meraki API.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: b2bb422b7d794a03a93c8d46209cd3fb
          name: 'Networks item errors'
          type: DEPENDENT
          key: meraki.get.networks.errors
          value_type: TEXT
          description: 'Item for gathering all the networks item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.networks
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: c149d21e19f3453b8e569c549ed2c78a
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.networks.errors))>0'
              name: 'Meraki: There are errors in ''Get networks'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: b33608b4c24d4c7bbf1f76f639890715
          name: 'SAML SSO Settings'
          type: DEPENDENT
          key: meraki.get.saml
          description: 'Return the enabled SAML SSO settings for the organization.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.samlSSO.enabled
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: saml
        - uuid: bb653e6dba3f489494a7143b74fe8f4f
          name: 'Get list of the VPN stats'
          type: SCRIPT
          key: meraki.get.vpn.stats
          delay: '{$MERAKI.VPN.STATS.TIMESPAN}'
          history: '0'
          value_type: TEXT
          params: |
            var params = JSON.parse(value);
            
            var request = new HttpRequest();
            
            request.addHeader('X-Cisco-Meraki-API-Key:' + params.token);
            request.addHeader('User-Agent: ZabbixServer/1.2 Zabbix');
            
            var response,
            	error_msg = '',
            	vpnStats = [],
            	vpnStatuses = [],
            	result = [];
            
            function isFloat(n) {
            	n = parseFloat(n);
            	return Number(n) === n && n % 1 !== 0;
            };
            
            function checkNumber(string) {
            	if (typeof string !== "string" || isNaN(string) || isFloat(string)) {
            		throw 'Incorrect "timespan" parameter given: ' + string + ' Must be an unsigned number';
            	}
            	return string;
            };
            
            function getHttpData(url) {
            	var startTime = new Date().getTime();
            	var maxWait = parseInt(timespan, 10) * 1000;
            	var waitFor = 1000;
            
            	while (true) {
            		response = request.get(url);
            		Zabbix.log(4, '[ Meraki API ] [ ' + url + ' ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		var status = request.getStatus();
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from Meraki API. Check debug log for more information.';
            			}
            		}
            
            		if (status === 429 && response && response.errors && Array.isArray(response.errors) &&
            			response.errors.indexOf("API rate limit exceeded for organization") !== -1) {
            			var now = new Date().getTime();
            			var headers = request.getHeaders(false);
            
            			if ('Retry-After' in headers) {
            				var retryAfter = headers['Retry-After'];
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. Retrying after ' + retryAfter + ' seconds.');				 
            				waitFor = parseInt(retryAfter) * 1000;
            			}
            			else {
            				Zabbix.log(4, '[ Meraki API ] API rate limit exceeded. No Retry-After header. Retrying after 1 second.');
            			}
            			if (now - startTime + waitFor > maxWait) {
            				throw 'Failed to receive data: API rate limit exceeded and retry timeout reached.';
            			}
            			Zabbix.sleep(waitFor);
            			continue;
            		}
            
            		if (status !== 200) {
            			if (response.errors) {
            				throw response.errors.join(', ');
            			}
            			else {
            				throw 'Failed to receive data: invalid response status code.';
            			}
            		}
            
            		if (typeof (response) !== 'object' || response === null) {
            			throw 'Cannot process response data: received data is not an object.';
            		}
            
            		return response;
            	}
            };
            
            try {
            
            	if (params.token === '{' + '$MERAKI.TOKEN}') {
            		throw 'Please change {' + '$MERAKI.TOKEN} macro to the proper value.';
            	}
            
            	if (params.url.indexOf('http://') === -1 && params.url.indexOf('https://') === -1) {
            		params.url = 'https://' + params.url;
            	}
            
            	if (!params.url.endsWith('/')) {
            		params.url += '/';
            	}
            
            	if (typeof params.httpproxy !== 'undefined' && params.httpproxy !== '') {
            		request.setProxy(params.httpproxy);
            	}
            
            	timespan = checkNumber('{$MERAKI.VPN.STATS.TIMESPAN}');
            
            	if (timespan > 86400 || timespan < 1) {
            		throw 'Incorrect "timespan" parameter given: ' + timespan + ' Must be between 1 and 86400 seconds.';
            	}
            
            	vpnStats = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/appliance/vpn/stats?timespan=' + timespan);
            
            	for (i in vpnStats) {
            		if (typeof vpnStats[i].merakiVpnPeers !== 'undefined' && Array.isArray(vpnStats[i].merakiVpnPeers)) {
            			for (u in vpnStats[i].merakiVpnPeers) {
            				if (typeof vpnStats[i].merakiVpnPeers[u].latencySummaries !== 'undefined' && Array.isArray(vpnStats[i].merakiVpnPeers[u].latencySummaries)) {
            					vpn_stats = vpnStats[i].merakiVpnPeers[u].latencySummaries.map(function (x) {
            
            						lps = vpnStats[i].merakiVpnPeers[u].lossPercentageSummaries.filter(function (y) { return y.senderUplink == x.senderUplink && y.receiverUplink == x.receiverUplink; });
            						js = vpnStats[i].merakiVpnPeers[u].jitterSummaries.filter(function (y) { return y.senderUplink == x.senderUplink && y.receiverUplink == x.receiverUplink; });
            						ms = vpnStats[i].merakiVpnPeers[u].mosSummaries.filter(function (y) { return y.senderUplink == x.senderUplink && y.receiverUplink == x.receiverUplink; });
            						Object.assign(x, lps[0], js[0], ms[0]);
            
            						if ('networkId' in vpnStats[i]) {
            							x.networkId = vpnStats[i].networkId;
            						}
            						if ('networkName' in vpnStats[i]) {
            							x.networkName = vpnStats[i].networkName;
            						}
            
            						if ('networkId' in vpnStats[i].merakiVpnPeers[u]) {
            							x.peerNetworkId = vpnStats[i].merakiVpnPeers[u].networkId;
            						}
            						if ('networkName' in vpnStats[i].merakiVpnPeers[u]) {
            							x.peerNetworkName = vpnStats[i].merakiVpnPeers[u].networkName;
            						}
            
            						return x;
            					});
            					result = result.concat(vpn_stats);
            				}
            			}
            		}
            	}
            
            	vpnStatuses = getHttpData(params.url + 'organizations/' + encodeURIComponent(params.organizationId) + '/appliance/vpn/statuses');
            
            } catch (error) {
            	error_msg = error;
            };
            
            return JSON.stringify({
            	'vpnStats': result,
            	'vpnStatuses': vpnStatuses,
            	'error': error_msg.toString()
            });
          description: 'Item for gathering all the VPN stats of the organization.'
          timeout: '{$MERAKI.DATA.TIMEOUT}'
          parameters:
            - name: httpproxy
              value: '{$MERAKI.HTTP_PROXY}'
            - name: organizationId
              value: '{$ID}'
            - name: token
              value: '{$MERAKI.TOKEN}'
            - name: url
              value: '{$MERAKI.API.URL}'
          tags:
            - tag: component
              value: raw
        - uuid: a5106f644c4e46fc963cc953dafaeb4e
          name: 'VPN item errors'
          type: DEPENDENT
          key: meraki.get.vpn.stats.errors
          value_type: TEXT
          description: 'Item for gathering all the VPN item errors.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          master_item:
            key: meraki.get.vpn.stats
          tags:
            - tag: component
              value: error
          triggers:
            - uuid: f65ff582e1a84f5a9e9d6a9c0501b013
              expression: 'length(last(/Cisco Meraki organization by HTTP/meraki.get.vpn.stats.errors))>0'
              name: 'Meraki: There are errors in ''Get VPNs'' metric'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 3e79a9319f0146c5b5aefeba13ec722c
          name: 'Idle timeout minutes'
          type: DEPENDENT
          key: meraki.idle.timeout.minutes
          description: 'Number of minutes users can remain idle before being logged out of their accounts.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.idleTimeoutMinutes
              error_handler: DISCARD_VALUE
            - type: NOT_MATCHES_REGEX
              parameters:
                - ^null$
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: bd6eca7b707a4bee8e2302765afa6074
          name: 'License expire'
          type: DEPENDENT
          key: meraki.license.expire
          value_type: FLOAT
          units: s
          description: 'Meraki license expire time, in seconds left.'
          valuemap:
            name: 'License status'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.licenseStates.expirationDate
              error_handler: DISCARD_VALUE
            - type: JAVASCRIPT
              parameters:
                - |
                  function parseDate(date) {
                  	months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                  	date = date.split(',');
                  	date[1] = date[1].match(/[0-9]{4}/)[0];
                  	date = date.concat(date[0].split(' '));
                  	month = 1 + months.indexOf(date[2]);
                  	return Date.parse(date[1] + "-" + month + "-" + date[3]);
                  }
                  
                  if (value === "N/A") {
                  	return -1;
                  } else {
                  	value = parseDate(value);
                  	now = Date.now();
                  	return Math.floor((value - now) / 1000);
                  }
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: license
          triggers:
            - uuid: 8694c7fc18904004978a3ce46f06a67e
              expression: 'last(/Cisco Meraki organization by HTTP/meraki.license.expire)<{$MERAKI.LICENSE.EXPIRE} and last(/Cisco Meraki organization by HTTP/meraki.license.expire)>=0'
              name: 'Meraki: License expires in less than {$MERAKI.LICENSE.EXPIRE} seconds'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 2b8e2c4093074dbaa88db3df57eb2cd1
          name: 'License status'
          type: DEPENDENT
          key: meraki.license.status
          description: 'Meraki license status.'
          valuemap:
            name: 'License status'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.licenseStates.status
              error_handler: DISCARD_VALUE
            - type: JAVASCRIPT
              parameters:
                - |
                  switch (value) {
                  	case 'License Required':
                  		return 0
                  	case 'OK':
                  		return 1
                  	default:
                  		return 10
                  }
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: license
          triggers:
            - uuid: d4f71dd53bf8495789b53e063db3555b
              expression: 'last(/Cisco Meraki organization by HTTP/meraki.license.status)<>1'
              name: 'Meraki: License status is not OK'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: c313fa31777a42d29d874f46f00ac82f
          name: 'Enforce account lockout'
          type: DEPENDENT
          key: meraki.login.enforce.account.lockout
          description: 'Boolean indicating whether users'' dashboard accounts will be locked out after a specified number of consecutive failed login attempts.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforceAccountLockout
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: d71eb53c76e84ce1ad65959e381c358f
          name: 'Enforce different passwords'
          type: DEPENDENT
          key: meraki.login.enforce.different.passwords
          description: 'Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforceDifferentPasswords
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: bd9423ea744f4855926e0edf677ef2a6
          name: 'Enforce idle timeout'
          type: DEPENDENT
          key: meraki.login.enforce.idle.timeout
          description: 'Boolean indicating whether users will be logged out after being idle for the specified number of minutes.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforceIdleTimeout
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: f7b88a64223c4b2992f15d0b6807f55f
          name: 'Enforce login IP ranges'
          type: DEPENDENT
          key: meraki.login.enforce.login.ip.ranges
          description: 'Boolean indicating whether organization will restrict access to the dashboard (including the API) from certain IP addresses.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforceLoginIpRanges
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: 09dc6f6619ea4a1dba1b17d9803bbe7a
          name: 'Enforce password expiration'
          type: DEPENDENT
          key: meraki.login.enforce.password.expiration
          description: 'Boolean indicating whether users are forced to change their password every X days.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforcePasswordExpiration
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: cae90669ec7b4b2d9743b2f60fe6f99e
          name: 'Enforce 2FA'
          type: DEPENDENT
          key: meraki.login.enforce.two.factor.auth
          description: 'Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to the dashboard. This code will be sent to their mobile phones via SMS or can be generated by the authenticator application.'
          valuemap:
            name: 'Boolean format'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.enforceTwoFactorAuth
              error_handler: DISCARD_VALUE
            - type: BOOL_TO_DECIMAL
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: 903cca42650f489f80ae5ace3adecb69
          name: 'Number of different passwords'
          type: DEPENDENT
          key: meraki.login.num.different.passwords
          description: 'Number of recent passwords that new password must be distinct from.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.numDifferentPasswords
              error_handler: DISCARD_VALUE
            - type: NOT_MATCHES_REGEX
              parameters:
                - ^null$
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: 8e882c747c7047f99127346adc7e0a5a
          name: 'Password expiration days'
          type: DEPENDENT
          key: meraki.login.password.expiration.days
          description: 'Number of days after which users will be forced to change their password.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.loginSecurity.passwordExpirationDays
              error_handler: DISCARD_VALUE
            - type: NOT_MATCHES_REGEX
              parameters:
                - ^null$
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.data
          tags:
            - tag: component
              value: security
        - uuid: e18f69d27fcb4b949d5744aebef97ffb
          name: Policies
          type: DEPENDENT
          key: meraki.policies
          description: 'Meraki adaptive policies count.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.counts.policies
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: policy
        - uuid: 8a8369134eff4153aba32d9c435786f3
          name: 'Allow policies'
          type: DEPENDENT
          key: meraki.policies.allow
          description: 'Meraki adaptive allow policies count.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.counts.allowPolicies
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: policy
        - uuid: f85b33412a2a41b39c33d64f3c641232
          name: 'Custom ACLs'
          type: DEPENDENT
          key: meraki.policies.custom.acls
          description: 'Meraki adaptive policy custom ACLs count.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.counts.customAcls
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: policy
        - uuid: 8b9e13124628460584668dbe5cd1b92b
          name: 'Deny policies'
          type: DEPENDENT
          key: meraki.policies.deny
          description: 'Meraki adaptive deny policies count.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.counts.denyPolicies
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: policy
        - uuid: a4918ea4d6954b5f829e5533117c109a
          name: Groups
          type: DEPENDENT
          key: meraki.policies.groups
          description: 'Meraki adaptive policy groups count.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.data.counts.groups
              error_handler: DISCARD_VALUE
          master_item:
            key: meraki.get.adaptive.policy
          tags:
            - tag: component
              value: policy
      discovery_rules:
        - uuid: 596c6122c6244dee83e3b55e30e4fda0
          name: 'Administrators discovery'
          type: DEPENDENT
          key: meraki.admins.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ADMIN.NAME}'
                value: '{$MERAKI.ADMIN.NAME.MATCHES}'
              - macro: '{#ADMIN.NAME}'
                value: '{$MERAKI.ADMIN.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#ADMIN.ORG.ACCESS}'
                value: '{$MERAKI.ADMIN.ORG.ACCESS.MATCHES}'
              - macro: '{#ADMIN.ORG.ACCESS}'
                value: '{$MERAKI.ADMIN.ORG.ACCESS.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: d4d450d2788c4e83af247b647951314b
              name: 'Admin [{#ADMIN.NAME}]: authentication method'
              type: DEPENDENT
              key: 'meraki.admin.account.auth.method[{#ADMIN.ID}]'
              value_type: TEXT
              description: 'Admin''s authentication method.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.authenticationMethod
              master_item:
                key: 'meraki.admin.get[{#ADMIN.ID}]'
              tags:
                - tag: admin
                  value: '{#ADMIN.NAME}'
                - tag: component
                  value: security
            - uuid: 7efd859bb84e47bd84a099686f42ee8b
              name: 'Admin [{#ADMIN.NAME}]: organization access'
              type: DEPENDENT
              key: 'meraki.admin.account.org.access[{#ADMIN.ID}]'
              value_type: TEXT
              description: 'Admin''s level of access to the organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.orgAccess
              master_item:
                key: 'meraki.admin.get[{#ADMIN.ID}]'
              tags:
                - tag: admin
                  value: '{#ADMIN.NAME}'
                - tag: component
                  value: security
            - uuid: 58a07f56495943dc9cb58352d919de61
              name: 'Admin [{#ADMIN.NAME}]: account status'
              type: DEPENDENT
              key: 'meraki.admin.account.status[{#ADMIN.ID}]'
              value_type: TEXT
              description: 'Status of the admin''s account.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.accountStatus
              master_item:
                key: 'meraki.admin.get[{#ADMIN.ID}]'
              tags:
                - tag: admin
                  value: '{#ADMIN.NAME}'
                - tag: component
                  value: security
            - uuid: edfa03da4a694111920146d2744884bb
              name: 'Admin [{#ADMIN.NAME}]: 2FA enabled'
              type: DEPENDENT
              key: 'meraki.admin.account.two.factor.auth[{#ADMIN.ID}]'
              description: 'Indicates whether two-factor authentication is enabled.'
              valuemap:
                name: 'Boolean format'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.twoFactorAuthEnabled
                - type: BOOL_TO_DECIMAL
              master_item:
                key: 'meraki.admin.get[{#ADMIN.ID}]'
              tags:
                - tag: admin
                  value: '{#ADMIN.NAME}'
                - tag: component
                  value: security
            - uuid: 6d075eb822f94d8285e358fa330b67fc
              name: 'Admin [{#ADMIN.NAME}]: get data'
              type: DEPENDENT
              key: 'meraki.admin.get[{#ADMIN.ID}]'
              history: '0'
              value_type: TEXT
              description: 'Raw data for admin in this organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.adminAccount.[?(@.id == "{#ADMIN.ID}")].first()'
              master_item:
                key: meraki.get.data
              tags:
                - tag: admin
                  value: '{#ADMIN.NAME}'
                - tag: component
                  value: raw
                - tag: component
                  value: security
          master_item:
            key: meraki.get.data
          lld_macro_paths:
            - lld_macro: '{#ADMIN.ID}'
              path: $.id
            - lld_macro: '{#ADMIN.NAME}'
              path: $.name
            - lld_macro: '{#ADMIN.ORG.ACCESS}'
              path: $.orgAccess
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.adminAccount
        - uuid: 961ecce14f274858a6d632ec906c849f
          name: 'License discovery'
          type: DEPENDENT
          key: meraki.license.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#LICENSE.STATE}'
                value: '{$MERAKI.LICENSE.STATE.MATCHES}'
              - macro: '{#LICENSE.STATE}'
                value: '{$MERAKI.LICENSE.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#LICENSE.TYPE}'
                value: '{$MERAKI.LICENSE.TYPE.MATCHES}'
              - macro: '{#LICENSE.TYPE}'
                value: '{$MERAKI.LICENSE.TYPE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: 87672962b9e14e69ad63f4d790fd11ad
              name: 'License [{#LICENSE.ID}]: activation date'
              type: DEPENDENT
              key: 'meraki.license.activation.date[{#LICENSE.ID}]'
              value_type: FLOAT
              units: unixtime
              description: 'The date the license started burning.'
              valuemap:
                name: 'License statuses'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.activationDate
                - type: JAVASCRIPT
                  parameters:
                    - 'return truncatedTimestamp = Math.floor(Date.parse(value) / 1000) || -1;'
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: dd9c1d50a4cc448e82affb7de442af8e
              name: 'License [{#LICENSE.ID}]: device name'
              type: DEPENDENT
              key: 'meraki.license.device.name[{#LICENSE.ID}]'
              value_type: CHAR
              description: 'Name of the device the license is assigned to.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.deviceName
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: dc550872241f49ab930aa9bc34614308
              name: 'License [{#LICENSE.ID}]: device serial'
              type: DEPENDENT
              key: 'meraki.license.device.serial[{#LICENSE.ID}]'
              value_type: CHAR
              description: 'Serial number of the device the license is assigned to.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.deviceSerial
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: d8504a68e79344228c612b6afc362cde
              name: 'License [{#LICENSE.ID}]: expiration date'
              type: DEPENDENT
              key: 'meraki.license.expiration.date[{#LICENSE.ID}]'
              value_type: FLOAT
              units: unixtime
              description: 'The date the license will expire.'
              valuemap:
                name: 'License statuses'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.expirationDate
                - type: JAVASCRIPT
                  parameters:
                    - 'return truncatedTimestamp = Math.floor(Date.parse(value) / 1000) || -1;'
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: 544eb99d23134448afd1ea4ff267ef13
              name: 'License [{#LICENSE.ID}]: get data'
              type: DEPENDENT
              key: 'meraki.license.get[{#LICENSE.ID}]'
              history: '0'
              value_type: TEXT
              description: 'Raw data for a license.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.licenses.[?(@.id == "{#LICENSE.ID}")].first()'
              master_item:
                key: meraki.get.list.licenses
              tags:
                - tag: component
                  value: license
                - tag: component
                  value: raw
            - uuid: dde68e22656c4e9e88f89a97984704a8
              name: 'License [{#LICENSE.ID}]: key'
              type: DEPENDENT
              key: 'meraki.license.key[{#LICENSE.ID}]'
              value_type: CHAR
              description: 'License key.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.licenseKey
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: b616fcfc6cd740ec8ec52578d7bc2f8c
              name: 'License [{#LICENSE.ID}]: state'
              type: DEPENDENT
              key: 'meraki.license.state[{#LICENSE.ID}]'
              value_type: CHAR
              description: 'The state of the license. All queued licenses have a status of ''recently queued''.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.state
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
            - uuid: cb07d887e5dc407e91208323394e61a7
              name: 'License [{#LICENSE.ID}]: total duration in days'
              type: DEPENDENT
              key: 'meraki.license.total.duration[{#LICENSE.ID}]'
              value_type: FLOAT
              description: 'The duration of the license plus all permanently queued licenses associated with it.'
              valuemap:
                name: 'License statuses'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.totalDurationInDays
                - type: JAVASCRIPT
                  parameters:
                    - 'return days = Math.floor(value) || -1;'
              master_item:
                key: 'meraki.license.get[{#LICENSE.ID}]'
              tags:
                - tag: component
                  value: license
                - tag: license-type
                  value: '{#LICENSE.TYPE}'
          graph_prototypes:
            - uuid: 302613b208c24c8191d4fccb2d941cbb
              name: 'Meraki: license [{#LICENSE.ID}] date'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.license.activation.date[{#LICENSE.ID}]'
                - sortorder: '1'
                  color: F63100
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.license.expiration.date[{#LICENSE.ID}]'
          master_item:
            key: meraki.get.list.licenses
          lld_macro_paths:
            - lld_macro: '{#LICENSE.DEVICE.NAME}'
              path: $.deviceName
            - lld_macro: '{#LICENSE.ID}'
              path: $.id
            - lld_macro: '{#LICENSE.STATE}'
              path: $.state
            - lld_macro: '{#LICENSE.TYPE}'
              path: $.licenseType
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.licenses
        - uuid: c885b8978f284ab98007860de6cadb84
          name: 'Networks discovery'
          type: DEPENDENT
          key: meraki.networks.discovery
          item_prototypes:
            - uuid: fca3d0675bdb42158c20db24a8d2d4ee
              name: 'Network [{#NETWORK.NAME}]: Time zone'
              type: DEPENDENT
              key: 'meraki.network.timezone[{#NETWORK.ID}]'
              value_type: CHAR
              description: 'Timezone of the network.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.networks[?(@.name== ''{#NETWORK.NAME}'' && @.id== ''{#NETWORK.ID}'')].timeZone.first()'
              master_item:
                key: meraki.get.networks
              tags:
                - tag: component
                  value: network
                - tag: network
                  value: '{#NETWORK.NAME}'
          master_item:
            key: meraki.get.networks
          lld_macro_paths:
            - lld_macro: '{#NETWORK.ID}'
              path: $.id
            - lld_macro: '{#NETWORK.NAME}'
              path: $.name
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.networks
        - uuid: fa4eb762c1064723b5f708aff74ed12c
          name: 'SAML roles discovery'
          type: DEPENDENT
          key: meraki.saml.roles.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#SAML.ORG.ACCESS}'
                value: '{$MERAKI.SAML.ORG.ACCESS.MATCHES}'
              - macro: '{#SAML.ORG.ACCESS}'
                value: '{$MERAKI.SAML.ORG.ACCESS.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#SAML.ROLE}'
                value: '{$MERAKI.SAML.ROLE.MATCHES}'
              - macro: '{#SAML.ROLE}'
                value: '{$MERAKI.SAML.ROLE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: d0f48c88f8c64f8ab1fd1d77aed7f08e
              name: 'SAML role [{#SAML.ROLE}]: get data'
              type: DEPENDENT
              key: 'meraki.saml.get[{#SAML.ID}]'
              history: '0'
              value_type: TEXT
              description: 'Raw data for SAML roles.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.samlRoles.[?(@.id == "{#SAML.ID}")].first()'
              master_item:
                key: meraki.get.data
              tags:
                - tag: component
                  value: raw
            - uuid: f4bf93217d10424fb56d3ff8965d2495
              name: 'SAML role [{#SAML.ROLE}]: organization access'
              type: DEPENDENT
              key: 'meraki.saml.org.access[{#SAML.ID}]'
              value_type: TEXT
              description: 'The privilege of the SAML administrator in the organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.orgAccess
              master_item:
                key: 'meraki.saml.get[{#SAML.ID}]'
              tags:
                - tag: saml-role
                  value: '{#SAML.ROLE}'
          master_item:
            key: meraki.get.data
          lld_macro_paths:
            - lld_macro: '{#SAML.ID}'
              path: $.id
            - lld_macro: '{#SAML.ORG.ACCESS}'
              path: $.orgAccess
            - lld_macro: '{#SAML.ROLE}'
              path: $.role
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.samlRoles
        - uuid: 03d6aeb2bc3d473b9aab87acd0e08f8c
          name: 'Uplinks discovery'
          type: DEPENDENT
          key: meraki.uplinks.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NETWORK.NAME}'
                value: '{$MERAKI.LLD.UPLINK.NETWORK.NAME.MATCHES}'
              - macro: '{#NETWORK.NAME}'
                value: '{$MERAKI.LLD.UPLINK.NETWORK.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#UPLINK.ROLE}'
                value: '{$MERAKI.LLD.UPLINK.ROLE.MATCHES}'
              - macro: '{#UPLINK.ROLE}'
                value: '{$MERAKI.LLD.UPLINK.ROLE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: 783a083a49e64c2db1d37e44d28f263b
              name: 'Uplink [{#INTERFACE}]: [{#UPLINK.ROLE}]: [{#NETWORK.NAME}]: Interface'
              type: DEPENDENT
              key: 'meraki.uplink.interface[{#NETWORK.NAME}, {#INTERFACE}, {#UPLINK.ROLE}]'
              value_type: CHAR
              description: 'Network uplink interface.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.uplinks[?(@.networkName== ''{#NETWORK.NAME}'' && @.interface== ''{#INTERFACE}'' && @.role== ''{#UPLINK.ROLE}'' )].interface.first()'
              master_item:
                key: meraki.get.networks
              tags:
                - tag: component
                  value: network
                - tag: component
                  value: uplink
                - tag: interface
                  value: '{#INTERFACE}'
                - tag: network
                  value: '{#NETWORK.NAME}'
                - tag: serial-number
                  value: '{#UPLINK.DEVICE.SERIAL}'
            - uuid: a4026ab15ff34c43a23605b27146376d
              name: 'Uplink [{#INTERFACE}]: [{#UPLINK.ROLE}]: [{#NETWORK.NAME}]: Public IP'
              type: DEPENDENT
              key: 'meraki.uplink.public.ip[{#NETWORK.NAME}, {#INTERFACE}, {#UPLINK.ROLE}]'
              value_type: CHAR
              description: 'Network uplink public IP.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.uplinks[?(@.networkName== ''{#NETWORK.NAME}'' && @.interface== ''{#INTERFACE}'' && @.role== ''{#UPLINK.ROLE}'' )].publicIp.first()'
                - type: NOT_MATCHES_REGEX
                  parameters:
                    - ^null$
                  error_handler: DISCARD_VALUE
              master_item:
                key: meraki.get.networks
              tags:
                - tag: component
                  value: network
                - tag: component
                  value: uplink
                - tag: interface
                  value: '{#INTERFACE}'
                - tag: network
                  value: '{#NETWORK.NAME}'
                - tag: serial-number
                  value: '{#UPLINK.DEVICE.SERIAL}'
            - uuid: 7600f662dd044d1f857a6ffd9898277c
              name: 'Uplink [{#INTERFACE}]: [{#UPLINK.ROLE}]: [{#NETWORK.NAME}]: Status'
              type: DEPENDENT
              key: 'meraki.uplink.status[{#NETWORK.NAME}, {#INTERFACE}, {#UPLINK.ROLE}]'
              description: 'Network uplink status.'
              valuemap:
                name: 'Uplink status'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.uplinks[?(@.networkName== ''{#NETWORK.NAME}'' && @.interface== ''{#INTERFACE}'' && @.role== ''{#UPLINK.ROLE}'' )].status.first()'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      switch (value) {
                      	case 'failed':
                      		return 0
                      	case 'active':
                      		return 1
                      	case 'ready':
                      		return 2
                      	case 'not connected':
                      		return 3
                      	default:
                      		return 10
                      }
              master_item:
                key: meraki.get.networks
              tags:
                - tag: component
                  value: network
                - tag: component
                  value: uplink
                - tag: interface
                  value: '{#INTERFACE}'
                - tag: network
                  value: '{#NETWORK.NAME}'
                - tag: serial-number
                  value: '{#UPLINK.DEVICE.SERIAL}'
              trigger_prototypes:
                - uuid: b1f3cbb8f3024c3f8cd6a8eaf7a5df52
                  expression: 'last(/Cisco Meraki organization by HTTP/meraki.uplink.status[{#NETWORK.NAME}, {#INTERFACE}, {#UPLINK.ROLE}])=0'
                  name: 'Meraki: Uplink [{#INTERFACE}]: [{#UPLINK.ROLE}]: [{#NETWORK.NAME}]: Status is failed'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: meraki.get.networks
          lld_macro_paths:
            - lld_macro: '{#INTERFACE}'
              path: $.interface
            - lld_macro: '{#NETWORK.NAME}'
              path: $.networkName
            - lld_macro: '{#PRIVATE.IP}'
              path: $.ip
            - lld_macro: '{#PUBLIC.IP}'
              path: $.publicIp
            - lld_macro: '{#UPLINK.DEVICE.SERIAL}'
              path: $.serial
            - lld_macro: '{#UPLINK.ROLE}'
              path: $.role
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.uplinks
        - uuid: 34052749bd3c46fd9083d738ddeee216
          name: 'VPN stats discovery'
          type: DEPENDENT
          key: meraki.vpn.stats.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NETWORK.NAME}'
                value: '{$MERAKI.LLD.VPN.NETWORK.NAME.MATCHES}'
              - macro: '{#NETWORK.NAME}'
                value: '{$MERAKI.LLD.VPN.NETWORK.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#PEER.NETWORK.NAME}'
                value: '{$MERAKI.LLD.VPN.PEER.NETWORK.NAME.MATCHES}'
              - macro: '{#PEER.NETWORK.NAME}'
                value: '{$MERAKI.LLD.VPN.PEER.NETWORK.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#RECEIVER.UPLINK}'
                value: '{$MERAKI.LLD.VPN.RECEIVER.UPLINK.MATCHES}'
              - macro: '{#RECEIVER.UPLINK}'
                value: '{$MERAKI.LLD.VPN.RECEIVER.UPLINK.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#SENDER.UPLINK}'
                value: '{$MERAKI.LLD.VPN.SENDER.UPLINK.MATCHES}'
              - macro: '{#SENDER.UPLINK}'
                value: '{$MERAKI.LLD.VPN.SENDER.UPLINK.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: 6e38c9538ad4489ea08b6d21fc8a8bd3
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: jitter avg'
              type: DEPENDENT
              key: 'meraki.vpn.stat.jitter.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection jitter avg.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.avgJitter
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: c676fc71415d4e199f257f165fc56163
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: jitter max'
              type: DEPENDENT
              key: 'meraki.vpn.stat.jitter.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection jitter max.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.maxJitter
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: c0d392d7ca2b42df9a967ffb2dcfa80d
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: jitter min'
              type: DEPENDENT
              key: 'meraki.vpn.stat.jitter.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection jitter min.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.minJitter
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 6f56db10935641b0bf416ae3402ddb17
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: latency avg'
              type: DEPENDENT
              key: 'meraki.vpn.stat.latency.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: ms
              description: 'VPN connection avg latency.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.avgLatencyMs
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 626ca25322e9413ca0e5bee2c8760c73
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: latency max'
              type: DEPENDENT
              key: 'meraki.vpn.stat.latency.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: ms
              description: 'VPN connection max latency.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.maxLatencyMs
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 56a0ea96051a4b45af7db3da1af3e4a4
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: latency min'
              type: DEPENDENT
              key: 'meraki.vpn.stat.latency.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: ms
              description: 'VPN connection min latency.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.minLatencyMs
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: a56018615c9540b58b8b074ccc8a05bd
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: loss avg, %'
              type: DEPENDENT
              key: 'meraki.vpn.stat.loss.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: '%'
              description: 'VPN connection loss avg.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.avgLossPercentage
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
              trigger_prototypes:
                - uuid: 3e3b9cdada9d451ea4be287bafd03cf4
                  expression: 'count(/Cisco Meraki organization by HTTP/meraki.vpn.stat.loss.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}],#3,,"{$MERAKI.VPN.LOSS.PERCENTILE}")>=3'
                  name: 'Meraki: VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: High average VPN connection loss (over >= {$MERAKI.VPN.LOSS.PERCENTILE%)'
                  event_name: 'Meraki: VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: High average VPN connection loss (over >= {$MERAKI.VPN.LOSS.PERCENTILE%)'
                  opdata: '{ITEM.LASTVALUE1}'
                  priority: AVERAGE
                  tags:
                    - tag: scope
                      value: availability
            - uuid: 7dccf9e43d944c37934a1dded9999756
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: loss max, %'
              type: DEPENDENT
              key: 'meraki.vpn.stat.loss.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: '%'
              description: 'VPN connection loss max.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.maxLossPercentage
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: eb835ef592a24e43bc918c4299b9f6e7
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: loss min, %'
              type: DEPENDENT
              key: 'meraki.vpn.stat.loss.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              units: '%'
              description: 'VPN connection loss min.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.minLossPercentage
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 1f26cdd09e5f45da9e8b0e679faa3425
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: mos avg'
              type: DEPENDENT
              key: 'meraki.vpn.stat.mos.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection mos avg.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.avgMos
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: bf28a0ead40046c8b08399775836be4e
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: mos max'
              type: DEPENDENT
              key: 'meraki.vpn.stat.mos.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection mos max.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.maxMos
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 9fee72321a23448983bd6cac7803600c
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: mos min'
              type: DEPENDENT
              key: 'meraki.vpn.stat.mos.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              value_type: FLOAT
              description: 'VPN connection mos min.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.minMos
              master_item:
                key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 2c968e21c8a34c73a17ed0fc4e2756b5
              name: 'VPN [{#NETWORK.NAME}]=>[{#PEER.NETWORK.NAME}]: stats raw'
              type: DEPENDENT
              key: 'meraki.vpn.stat.raw[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
              history: '0'
              value_type: TEXT
              description: 'VPN connection stats raw.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.vpnStats[?(@.networkId==''{#NETWORK.ID}'' && @.senderUplink==''{#SENDER.UPLINK}'' && @.peerNetworkId==''{#PEER.NETWORK.ID}'' && @.receiverUplink==''{#RECEIVER.UPLINK}'')].first()'
              master_item:
                key: meraki.get.vpn.stats
              tags:
                - tag: component
                  value: raw
          graph_prototypes:
            - uuid: 0794dc9d06844ee89099322f60382fc7
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: jitter'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.jitter.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '1'
                  color: F63100
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.loss.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '2'
                  color: 00611C
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.jitter.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
            - uuid: dd05787b5e0e4b4b870258b25c1a0503
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: latency'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.latency.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '1'
                  color: F63100
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.latency.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '2'
                  color: 00611C
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.latency.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
            - uuid: c0ff7a5798cd4aa181223763d8962229
              name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: loss'
              ymin_type_1: FIXED
              graph_items:
                - color: 199C0D
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.loss.avg[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '1'
                  color: F63100
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.loss.max[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
                - sortorder: '2'
                  color: 00611C
                  item:
                    host: 'Cisco Meraki organization by HTTP'
                    key: 'meraki.vpn.stat.loss.min[{#NETWORK.ID}, {#SENDER.UPLINK}, {#PEER.NETWORK.ID}, {#RECEIVER.UPLINK}]'
          master_item:
            key: meraki.get.vpn.stats
          lld_macro_paths:
            - lld_macro: '{#NETWORK.ID}'
              path: $.networkId
            - lld_macro: '{#NETWORK.NAME}'
              path: $.networkName
            - lld_macro: '{#PEER.NETWORK.ID}'
              path: $.peerNetworkId
            - lld_macro: '{#PEER.NETWORK.NAME}'
              path: $.peerNetworkName
            - lld_macro: '{#RECEIVER.UPLINK}'
              path: $.receiverUplink
            - lld_macro: '{#SENDER.UPLINK}'
              path: $.senderUplink
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.vpnStats
        - uuid: 01fd5c5650524c46acb8950c5e934e68
          name: 'VPN statuses discovery'
          type: DEPENDENT
          key: meraki.vpn.statuses.discovery
          item_prototypes:
            - uuid: 33586435a87a4151b089cd3671e278ec
              name: 'VPN [{#NETWORK.NAME}]: device serial'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.device.serial[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network device serial.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.deviceSerial
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 795e7163e5ec498fbef00aa6f90b5d13
              name: 'VPN [{#NETWORK.NAME}]: device status'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.device.status[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network device status.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.deviceStatus
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 73e90efe0f0b427a909e0a8bef4d5d38
              name: 'VPN [{#NETWORK.NAME}]: mode'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.mode[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network mode.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.vpnMode
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: baf0b63913564499a81065ea62cc8d53
              name: 'VPN [{#NETWORK.NAME}]: peers network ID'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.peers.network.id[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network ID.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.merakiVpnPeers..networkId.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: e6c461828bbd4177a755adba16b2b53b
              name: 'VPN [{#NETWORK.NAME}]: peers network name'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.peers.network.name[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network name Meraki VPN peers.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.merakiVpnPeers..networkName.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 712082be91af4e84a7300bd680fc7d41
              name: 'VPN [{#NETWORK.NAME}]: peers network reachability'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.peers.reachability[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'VPN network Meraki VPN peers reachability.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.merakiVpnPeers..reachability.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 0858c3efa5ea404ca94e05ca43671f05
              name: 'VPN [{#NETWORK.NAME}]: statuses raw'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              history: '0'
              value_type: TEXT
              description: 'VPN statuses raw.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.vpnStatuses[?(@.networkId==''{#NETWORK.ID}'' && @.networkName==''{#NETWORK.NAME}'')].first()'
              master_item:
                key: meraki.get.vpn.stats
              tags:
                - tag: component
                  value: raw
            - uuid: 2efc18211e414114a0301c6e8b8beda9
              name: 'VPN [{#NETWORK.NAME}]: third-party peers network ID'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.third.party.peers.network.id[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'Return network ID of the third-party VPN peers for the organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.thirdPartyVpnPeers..networkId.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 0b5fd0a0419e4a38bb27a0b5b3b73301
              name: 'VPN [{#NETWORK.NAME}]: third-party peers network name'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.third.party.peers.network.name[{#NETWORK.ID},  {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'Return network name of the third-party VPN peers for the organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.thirdPartyVpnPeers..networkName.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
            - uuid: 45e79c2918094fa5860d425d99e82201
              name: 'VPN [{#NETWORK.NAME}]: third-party peers network reachability'
              type: DEPENDENT
              key: 'meraki.vpn.statuses.third.party.peers.reachability[{#NETWORK.ID}, {#NETWORK.NAME}]'
              value_type: CHAR
              description: 'Return network reachability of the third-party VPN peers for the organization.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.thirdPartyVpnPeers..reachability.first()
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'meraki.vpn.statuses.raw[{#NETWORK.ID}, {#NETWORK.NAME}]'
              tags:
                - tag: component
                  value: vpn
          master_item:
            key: meraki.get.vpn.stats
          lld_macro_paths:
            - lld_macro: '{#NETWORK.ID}'
              path: $.networkId
            - lld_macro: '{#NETWORK.NAME}'
              path: $.networkName
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.vpnStatuses
      tags:
        - tag: class
          value: cloud
        - tag: class
          value: network
        - tag: subclass
          value: camera
        - tag: subclass
          value: firewall
        - tag: subclass
          value: modem
        - tag: subclass
          value: security
        - tag: target
          value: cisco-meraki-dashboard
      macros:
        - macro: '{$MERAKI.ADMIN.NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable admins in organization.'
          config:
            type: TEXT
            priority: '16'
            section_name: Filters
            label: 'Admin name filter (include)'
            description: 'Filter of discoverable admins in organization.'
        - macro: '{$MERAKI.ADMIN.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered admins in organization.'
          config:
            type: TEXT
            priority: '17'
            section_name: Filters
            label: 'Admin name filter (exclude)'
            description: 'Filter to exclude discovered admins in organization.'
        - macro: '{$MERAKI.ADMIN.ORG.ACCESS.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable admins in organization.'
          config:
            type: TEXT
            priority: '18'
            section_name: Filters
            label: 'Admin organization access filter (include)'
            description: 'Filter of discoverable admins in organization.'
        - macro: '{$MERAKI.ADMIN.ORG.ACCESS.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered admins in organization.'
          config:
            type: TEXT
            priority: '19'
            section_name: Filters
            label: 'Admin organization access filter (exclude)'
            description: 'Filter to exclude discovered admins in organization.'
        - macro: '{$MERAKI.API.URL}'
          value: api.meraki.com/api/v1
          description: 'Cisco Meraki dashboard API URL, e.g., api.meraki.com/api/v1'
          config:
            type: TEXT
            priority: '2'
            label: 'Meraki API URL'
            description: 'Cisco Meraki dashboard API URL, e.g., api.meraki.com/api/v1'
            required: 'YES'
        - macro: '{$MERAKI.CONFIG.CHANGE.TIMESPAN}'
          value: '1200'
          description: 'Timespan in seconds for gathering configuration change log. Used in the metric configuration and in the URL query.'
          config:
            type: TEXT
            priority: '6'
            section_name: Other
            label: 'Timespan for config change log'
            description: 'Timespan in seconds for gathering configuration change log. Used in the metric configuration and in the URL query.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$MERAKI.DATA.TIMEOUT}'
          value: '60'
          description: 'Response timeout for an API.'
          config:
            type: TEXT
            priority: '3'
            section_name: Other
            label: 'API response timeout'
            description: 'Response timeout for an API.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$MERAKI.HTTP_PROXY}'
          description: 'HTTP proxy for API requests. You can specify it using the format [protocol://][username[:password]@]proxy.example.com[:port]. See documentation at https://www.zabbix.com/documentation/8.0/manual/config/items/itemtypes/http'
          config:
            type: TEXT
            priority: '20'
            section_name: Other
            label: 'HTTP proxy'
            description: 'HTTP proxy for API requests. You can specify it using the format [protocol://][username[:password]@]proxy.example.com[:port]. See documentation at https://www.zabbix.com/documentation/8.0/manual/config/items/itemtypes/http'
        - macro: '{$MERAKI.LICENSE.EXPIRE}'
          value: '86400'
          description: 'Time in seconds for license to expire.'
          config:
            type: TEXT
            priority: '4'
            section_name: Other
            label: 'License expiry time'
            description: 'Time in seconds for license to expire.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$MERAKI.LICENSE.STATE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable license.'
          config:
            type: TEXT
            priority: '10'
            section_name: Filters
            label: 'License state filter (include)'
            description: 'Filter of discoverable license.'
        - macro: '{$MERAKI.LICENSE.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered license.'
          config:
            type: TEXT
            priority: '11'
            section_name: Filters
            label: 'License state filter (exclude)'
            description: 'Filter to exclude discovered license.'
        - macro: '{$MERAKI.LICENSE.TYPE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable license.'
          config:
            type: TEXT
            priority: '8'
            section_name: Filters
            label: 'License type filter (include)'
            description: 'Filter of discoverable license.'
        - macro: '{$MERAKI.LICENSE.TYPE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered license.'
          config:
            type: TEXT
            priority: '9'
            section_name: Filters
            label: 'License type filter (exclude)'
            description: 'Filter to exclude discovered license.'
        - macro: '{$MERAKI.LLD.UPLINK.NETWORK.NAME.MATCHES}'
          value: '.*'
          description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '21'
            section_name: Filters
            label: 'Uplink network name filter (include)'
            description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.UPLINK.NETWORK.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '22'
            section_name: Filters
            label: 'Uplink network name filter (exclude)'
            description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.UPLINK.ROLE.MATCHES}'
          value: '.*'
          description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '23'
            section_name: Filters
            label: 'Uplink role filter (include)'
            description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.UPLINK.ROLE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '24'
            section_name: Filters
            label: 'Uplink role filter (exclude)'
            description: 'This macro is used in uplinks discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.NETWORK.NAME.MATCHES}'
          value: '.*'
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '25'
            section_name: Filters
            label: 'VPN network name filter (include)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.NETWORK.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '26'
            section_name: Filters
            label: 'VPN network name filter (exclude)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.PEER.NETWORK.NAME.MATCHES}'
          value: '.*'
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '27'
            section_name: Filters
            label: 'VPN peer network name filter (include)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.PEER.NETWORK.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '28'
            section_name: Filters
            label: 'VPN peer network name filter (exclude)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.RECEIVER.UPLINK.MATCHES}'
          value: '.*'
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '31'
            section_name: Filters
            label: 'VPN receiver uplink filter (include)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.RECEIVER.UPLINK.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '32'
            section_name: Filters
            label: 'VPN receiver uplink filter (exclude)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.SENDER.UPLINK.MATCHES}'
          value: '.*'
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '29'
            section_name: Filters
            label: 'VPN sender uplink filter (include)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.LLD.VPN.SENDER.UPLINK.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
          config:
            type: TEXT
            priority: '30'
            section_name: Filters
            label: 'VPN sender uplink filter (exclude)'
            description: 'This macro is used in VPN stats discovery. Can be overridden on the host or linked template level.'
        - macro: '{$MERAKI.SAML.ORG.ACCESS.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable SAML role.'
          config:
            type: TEXT
            priority: '12'
            section_name: Filters
            label: 'SAML organization access filter (include)'
            description: 'Filter of discoverable SAML role.'
        - macro: '{$MERAKI.SAML.ORG.ACCESS.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered SAML role.'
          config:
            type: TEXT
            priority: '13'
            section_name: Filters
            label: 'SAML organization access filter (exclude)'
            description: 'Filter to exclude discovered SAML role.'
        - macro: '{$MERAKI.SAML.ROLE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable SAML role.'
          config:
            type: TEXT
            priority: '14'
            section_name: Filters
            label: 'SAML role filter (include)'
            description: 'Filter of discoverable SAML role.'
        - macro: '{$MERAKI.SAML.ROLE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered SAML role.'
          config:
            type: TEXT
            priority: '15'
            section_name: Filters
            label: 'SAML role filter (exclude)'
            description: 'Filter to exclude discovered SAML role.'
        - macro: '{$MERAKI.TOKEN}'
          type: SECRET_TEXT
          description: 'Cisco Meraki dashboard API token.'
          config:
            type: TEXT
            priority: '1'
            label: 'Meraki API token'
            description: 'Cisco Meraki dashboard API token.'
            required: 'YES'
        - macro: '{$MERAKI.VPN.LOSS.PERCENTILE}'
          value: '90'
          description: 'Average VPN connection loss percentage. Used in the trigger expression'
          config:
            type: TEXT
            priority: '5'
            section_name: Thresholds
            label: 'Avg. VPN loss (%)'
            description: 'Average VPN connection loss percentage. Used in the trigger expression In the range from 0 to 100 inclusive.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$MERAKI.VPN.STATS.TIMESPAN}'
          value: '180'
          description: 'Timespan in seconds for getting organization appliance VPN stats. Used in the metric configuration and in the JavaScript API query. Must be between 1 and 86400 seconds.'
          config:
            type: TEXT
            priority: '7'
            section_name: Other
            label: 'Timespan for VPN stats'
            description: 'Timespan in seconds for getting organization appliance VPN stats. Used in the metric configuration and in the JavaScript API query. Must be between 1 and 86400 seconds.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
      dashboards:
        - uuid: 2d10effbfff447f6937877f25d12646a
          name: 'Meraki: General'
          pages:
            - name: 'Meraki: VPN stats'
              widgets:
                - type: graphprototype
                  name: latency
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki organization by HTTP'
                        name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: latency'
                    - type: STRING
                      name: reference
                      value: AAAAA
                - type: graphprototype
                  name: loss
                  'y': '5'
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki organization by HTTP'
                        name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: jitter'
                    - type: STRING
                      name: reference
                      value: AAAAC
                - type: graphprototype
                  name: loss
                  x: '36'
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki organization by HTTP'
                        name: 'VPN [{#NETWORK.NAME}][{#SENDER.UPLINK}]=>[{#PEER.NETWORK.NAME}][{#RECEIVER.UPLINK}]: loss'
                    - type: STRING
                      name: reference
                      value: AAAAB
            - name: 'Meraki: License'
              widgets:
                - type: graphprototype
                  name: latency
                  width: '36'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'Cisco Meraki organization by HTTP'
                        name: 'Meraki: license [{#LICENSE.ID}] date'
                    - type: STRING
                      name: reference
                      value: AAAAD
      valuemaps:
        - uuid: ec79f04ded684421b644b38500fe8b26
          name: 'Boolean format'
          mappings:
            - value: '0'
              newvalue: 'False'
            - value: '1'
              newvalue: 'True'
        - uuid: af92df09c58c4c9287fe294b7b90e193
          name: 'License status'
          mappings:
            - value: '0'
              newvalue: 'License required'
            - value: '1'
              newvalue: OK
            - value: '10'
              newvalue: unknown
        - uuid: ba834580763b481a8800a0323fa61327
          name: 'License statuses'
          mappings:
            - value: '-1'
              newvalue: 'null'
        - uuid: e16992443a614d81a7f4186622709971
          name: 'Uplink status'
          mappings:
            - value: '0'
              newvalue: failed
            - value: '1'
              newvalue: active
            - value: '2'
              newvalue: ready
            - value: '3'
              newvalue: 'not connected'
            - value: '10'
              newvalue: unknown
