zabbix_export:
  version: '7.0'
  template_groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: 5e225ad1c2cc4d0bbf75586e7bf8871b
      template: 'AWS ECS Serverless Cluster by HTTP'
      name: 'AWS ECS Serverless Cluster by HTTP'
      description: |
        The template gets AWS ECS Serverless Cluster metrics and uses the script item to make HTTP requests to the CloudWatch API.
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      vendor:
        name: Zabbix
        version: 7.0-0
      groups:
        - name: Templates/Cloud
      items:
        - uuid: eb064f2ac4f54a5baf05940fc58e651f
          name: 'AWS ECS Cluster: Get alarms check'
          type: DEPENDENT
          key: aws.ecs.alarms.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Data collection check.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.ecs.get_alarms
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 76b9777749a041049faaa469daf82c4e
              expression: 'length(last(/AWS ECS Serverless Cluster by HTTP/aws.ecs.alarms.check))>0'
              name: 'AWS ECS Cluster: Failed to get alarms data'
              opdata: '{ITEM.LASTVALUE1}'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: fe542fdbef9d4889a7443ee761a46119
          name: 'AWS ECS Cluster: Container Instance Count'
          type: DEPENDENT
          key: aws.ecs.container_instance_count
          delay: '0'
          history: 7d
          value_type: FLOAT
          description: '''The number of EC2 instances running the Amazon ECS agent that are registered with a cluster.'''
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "ContainerInstanceCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: system
        - uuid: bbfd5c05bd5f49ec984d849b6d45dfdd
          name: 'AWS ECS Cluster: CPU Utilization'
          type: DEPENDENT
          key: aws.ecs.cpu_utilization
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: '%'
          description: 'Cluster CPU utilization'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.CPUUtilization
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: cpu
          triggers:
            - uuid: d8b5d12b4c6b4b2386fe2540dc387fa7
              expression: 'min(/AWS ECS Serverless Cluster by HTTP/aws.ecs.cpu_utilization,15m)>{$AWS.ECS.CLUSTER.CPU.UTIL.WARN}'
              name: 'AWS ECS Cluster: High CPU utilization'
              event_name: 'AWS ECS Cluster: High CPU utilization (over {$AWS.ECS.CLUSTER.CPU.UTIL.WARN}% for 15m)'
              opdata: 'Current utilization: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'The CPU utilization is too high. The system might be slow to respond.'
              tags:
                - tag: scope
                  value: capacity
                - tag: scope
                  value: performance
        - uuid: 32f0b934b2d14b008780e73371328eac
          name: 'AWS ECS Cluster: Ephemeral Storage Utilization'
          type: DEPENDENT
          key: aws.ecs.disk.utilization
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: '%'
          description: '''The calculated Disk Utilization'''
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.DiskUtilization
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: storage
        - uuid: d3d2c2df9fd54d24b4598ec247152ca4
          name: 'AWS ECS Cluster: Ephemeral Storage Reserved'
          type: DEPENDENT
          key: aws.ecs.ephemeral.storage.reserved
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: B
          description: |
            'The number of bytes reserved from ephemeral storage in the resource that is specified by the dimensions that you're using. Ephemeral storage is used for the container root filesystem and any bind mount host volumes defined in the container image and task definition. The amount of ephemeral storage can’t be changed in a running task.
             This metric is only available for tasks that run on Fargate Linux platform version 1.4.0 or later.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "EphemeralStorageReserved")].Values.first().first()'
              error_handler: DISCARD_VALUE
            - type: MULTIPLIER
              parameters:
                - '1073741824'
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: storage
        - uuid: 36556a43a93d436db94685441a12273f
          name: 'AWS ECS Cluster: Ephemeral Storage Utilized'
          type: DEPENDENT
          key: aws.ecs.ephemeral.storage.utilized
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: B
          description: |
            'The number of bytes used from ephemeral storage in the resource that is specified by the dimensions that you're using. Ephemeral storage is used for the container root filesystem and any bind mount host volumes defined in the container image and task definition. The amount of ephemeral storage can’t be changed in a running task.
             This metric is only available for tasks that run on Fargate Linux platform version 1.4.0 or later.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "EphemeralStorageUtilized")].Values.first().first()'
              error_handler: DISCARD_VALUE
            - type: MULTIPLIER
              parameters:
                - '1073741824'
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: storage
        - uuid: ee28426c92874a99b998198a5539599d
          name: 'AWS ECS Cluster: Get alarms data'
          type: SCRIPT
          key: aws.ecs.get_alarms
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
                params: {},
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region', 'cluster_name'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, params, data) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
                        host = service + '.' + region + '.amazonaws.com',
                        canonical_uri = '/',
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/json');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
                    Zabbix.log(4, '[ AWS ECS ] Sending request: ' + url);
            
                    response = request.get(url);
            
                    Zabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
            
                    if (response[0] === '<') {
                        try {
                            response = XML.toJson(response);
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                        }
                    }
            
                    if (response !== null) {
                        try {
                            response = JSON.parse(response);
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                        }
                    }
            
                    return response;
                },
            
                getAlarms: function () {
                    var payload = {
                        'Action': 'DescribeAlarms',
                        'Version': '2010-08-01',
                        'MaxRecords': 100
                    },
                        result = [];
            
                    while (payload.nextToken !== '') {
                        var alarms = AWS.getField(AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload)), 'DescribeAlarmsResponse.DescribeAlarmsResult');
                        payload.nextToken = alarms.nextToken || '';
                        alarms_list = AWS.getField(alarms, 'MetricAlarms');
            
                        if (!Array.isArray(alarms_list))
                            alarms_list = [alarms_list]
                        alarms_list.forEach(function (alarm) {
                            var dimensions = alarm.Dimensions;
            
                            Zabbix.log(4, '[ AWS ECS ] dimensions: ' + JSON.stringify(dimensions));
                            if (Array.isArray(alarm.Metrics)) {
                                alarm.Metrics.forEach(function (metric) {
                                    if (typeof metric.MetricStat === 'object' && metric.MetricStat !== null
                                        && typeof metric.MetricStat.Metric === 'object' && metric.MetricStat.Metric !== null
                                        && Array.isArray(metric.MetricStat.Metric.Dimensions)) {
                                        dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
                                    }
                                });
                            }
                            for (var i in dimensions) {
                                if (dimensions[i].Name === 'ClusterName' && dimensions[i].Value === AWS.params.cluster_name) {
                                    result.push(alarm);
                                    break;
                                }
                            }
                        });
                    }
            
                    return result;
                }
            }
            
            try {
                AWS.setParams(JSON.parse(value));
            
                return JSON.stringify(AWS.getAlarms());
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS ECS ] ERROR: ' + error);
            
                return JSON.stringify({ 'error': error });
            }
          description: |
            Get alarms data.
            DescribeAlarms API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: cluster_name
              value: '{$AWS.ECS.CLUSTER.NAME}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 9818272bc51e4848bba7b2863dda9424
          name: 'AWS ECS Cluster: Get cluster services'
          type: SCRIPT
          key: aws.ecs.get_cluster_services
          delay: 5m
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
                params: {},
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region', 'cluster_name'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, host, params, data, uri) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
            
                        canonical_uri = '/' + uri,
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('x-amz-content-sha256:' + sha256(data));
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/x-www-form-urlencoded');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                    
                    Zabbix.log(4, '[ AWS ECS ] Sending request: ' + url);
            
                    response = request.post(url, data);
            
                    Zabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
            
                    try {
                        response = JSON.parse(response);
                    }
                    catch (error) {
                        throw 'Failed to parse response received from AWS API. Check debug log for more information.';
                    }
            
                    return response;
                },
            
                listServices: function () {
                    var payload = {},
                        result,
                        ECSClusters_Services,
                        services = [];
            
                    payload['Action'] = 'ListServices';
                    payload['Version'] = '2014-11-13';
                    payload['cluster'] = AWS.params.cluster_name;
            
                    result = AWS.request('POST', AWS.params.region, 'ecs', 'ecs.' + AWS.params.region + '.amazonaws.com', AWS.prepareParams(payload), '', '');
                    ECSClusters_Services = AWS.getField(result, 'ListServicesResponse.ListServicesResult.serviceArns')
            
                    for (k in ECSClusters_Services) {
                        id = ECSClusters_Services[k];
            
                        json = {};
                        input = id.split(AWS.params.cluster_name + '/');
                        for (var i = 1; i < input.length; i += 2) {
                            json[input[i]] = input[i + 1];
                        }
                        services.push({
                            'service_name': input[1],
                        });
                    }
            
                    if (Array.isArray(services))
                        return services;
                    else
                        return [services];
            
                },
            
            
                ListTasks: function () {
                    var payload = {},
                        result,
                        ECSClusters_Services_Tasks,
                        tasks = [];
            
                    payload['Action'] = 'ListTasks';
                    payload['Version'] = '2014-11-13';
                    payload['cluster'] = AWS.params.cluster_name;
                    payload['status'] = AWS.params.status;
            
                    result = AWS.request('POST', AWS.params.region, 'ecs', 'ecs.' + AWS.params.region + '.amazonaws.com', AWS.prepareParams(payload), '', '');
                    ECSClusters_Services_Tasks = AWS.getField(result, 'ListTasksResponse.ListTasksResult.taskArns')
                    for (k in ECSClusters_Services_Tasks) {
                        id = ECSClusters_Services_Tasks[k];
                        json = {};
                        input = id.split(AWS.params.cluster_name + '/');
                        for (var i = 1; i < input.length; i += 2) {
                            json[input[i]] = input[i + 1];
                        }
                        tasks.push({
                            'task_id': input[1],
                        });
                    }
            
                    if (Array.isArray(tasks))
                        return tasks;
                    else
                        return [tasks];
                }
            };
            
            try {
                AWS.setParams(JSON.parse(value));
                var 
                services = AWS.listServices(),
                    tasks = AWS.ListTasks();
                return JSON.stringify(({ services, tasks }));
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS ECS ] ERROR: ' + error);
                return JSON.stringify({ 'error': error });
            }
          description: |
            Get cluster services.
            Full metrics list related to ECS: https://docs.aws.amazon.com/AmazonECS/latest/userguide/metrics-dimensions.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: cluster_name
              value: '{$AWS.ECS.CLUSTER.NAME}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 01f1a371b56e4945b604cd8b396c85f5
          name: 'AWS ECS Cluster: Get cluster metrics'
          type: SCRIPT
          key: aws.ecs.get_metrics
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
                params: {},
                request_period: 600,
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region', 'cluster_name'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareRecursive: function (prefix, param) {
                    var result = {};
            
                    if (typeof param === 'object') {
                        if (Array.isArray(param)) {
                            param.forEach(function (value, index) {
                                var nested = AWS.prepareRecursive(prefix + '.member.' + (index + 1), value);
                                Object.keys(nested).forEach(function (key) {
                                    result[key] = nested[key];
                                });
                            });
                        }
                        else {
                            Object.keys(param).forEach(function (k) {
                                var nested = AWS.prepareRecursive(prefix + '.' + k, param[k]);
                                Object.keys(nested).forEach(function (key) {
                                    result[key] = nested[key];
                                });
                            });
                        }
                    }
                    else {
                        result[prefix] = param;
                    }
            
                    return result;
                },
            
                renderPayload: function (period, cluster_name) {
                    var metrics_list = [
                        'ContainerInstanceCount:Count',
                        'ServiceCount:Count',
                        'CpuReserved:None',
                        'CpuUtilized:None',
                        'MemoryReserved:Megabytes',
                        'MemoryUtilized:Megabytes',
                        'NetworkRxBytes:Bytes/Second',
                        'NetworkTxBytes:Bytes/Second',
                        'StorageReadBytes:Bytes',
                        'StorageWriteBytes:Bytes',
                        'TaskCount:Count',
                        'EphemeralStorageReserved:Gigabytes',
                        'EphemeralStorageUtilized:Gigabytes'
                    ];
            
                    var metric_payload = [];
                    metrics_list.forEach(function (metric) {
                        var parts = metric.split(':', 2);
                        var name = parts[0].replace(/[^a-zA-Z0-9]/g, '');
                        metric_payload.push({
                            'Id': name.charAt(0).toLowerCase() + name.slice(1),
                            'MetricStat': {
                                'Metric': {
                                    'MetricName': parts[0],
                                    'Namespace': 'ECS/ContainerInsights',
                                    'Dimensions': [
                                        {
                                            'Name': 'ClusterName',
                                            'Value': cluster_name
                                        }
                                    ]
                                },
                                'Period': period,
                                'Stat': 'Average',
                                'Unit': parts[1]
                            }
                        });
                    });
            
                    return metric_payload;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, params, data) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
                        host = service + '.' + region + '.amazonaws.com',
                        canonical_uri = '/',
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/json');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
                    Zabbix.log(4, '[ AWS ECS  ] Sending request: ' + url);
            
                    response = request.get(url);
            
                    Zabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
            
                    if (response !== null) {
                        try {
                            response = JSON.parse(response);
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                        }
                    }
            
                    return response;
                },
            
                getMetricsData: function () {
                    var timestamp = new Date().getTime(),
                        MetricData = [],
                        CPUUtilization,
                        MemoryUtilization,
                        DiskUtilization,
                        obj = {},
                        metrics = ['CpuReserved', 'CpuUtilized', 'MemoryReserved', 'MemoryUtilized', 'EphemeralStorageReserved', 'EphemeralStorageUtilized'],
                        end_time = new Date(timestamp).toISOString().replace(/\.\d+Z/, 'Z'),
                        start_time = new Date(timestamp - AWS.request_period * 1000).toISOString().replace(/\.\d+Z/, 'Z'),
                        payload = AWS.prepareRecursive('MetricDataQueries', AWS.renderPayload(AWS.request_period, AWS.params.cluster_name));
            
                    payload['Action'] = 'GetMetricData';
                    payload['Version'] = '2010-08-01';
                    payload['StartTime'] = start_time;
                    payload['EndTime'] = end_time;
                    payload['ScanBy'] = 'TimestampDescending';
            
                    result = AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload));
                    MetricData = AWS.getField(result, 'GetMetricDataResponse.GetMetricDataResult.MetricDataResults')
            
                    MetricData.forEach(function (id) {
                        for (i in metrics) {
                            if (AWS.getField(id, 'Label') === metrics[i]) {
                                obj[metrics[i]] = AWS.getField(id, 'Values');
                            }
                        }
                    });
                    CPUUtilization = Math.abs(obj.CpuUtilized * 100 / obj.CpuReserved);
                    MemoryUtilization = Math.abs(obj.MemoryUtilized * 100 / obj.MemoryReserved);
                    DiskUtilization = Math.abs(obj.EphemeralStorageUtilized * 100 / obj.EphemeralStorageReserved);
                    return ({ MetricData, MemoryUtilization, CPUUtilization, DiskUtilization });
                }
            };
            
            try {
                AWS.setParams(JSON.parse(value));
            
                return JSON.stringify(AWS.getMetricsData());
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS ECS ] ERROR: ' + error);
            
                return JSON.stringify({ 'error': error });
            }
          description: |
            Get cluster metrics.
            Full metrics list related to ECS: https://docs.aws.amazon.com/AmazonECS/latest/userguide/metrics-dimensions.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: cluster_name
              value: '{$AWS.ECS.CLUSTER.NAME}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 66b7893a750144fa9c02391bc6b4c79c
          name: 'AWS ECS Cluster: Memory Utilization'
          type: DEPENDENT
          key: aws.ecs.memory_utilization
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: '%'
          description: |
            'The memory being used by tasks in the resource that is specified by the dimension set that you're using.
             This metric is only collected for tasks that have a defined memory reservation in their task definition.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.MemoryUtilization
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: memory
          triggers:
            - uuid: 2f0d82467a754fada1ab4f38ce2c2c5b
              expression: 'min(/AWS ECS Serverless Cluster by HTTP/aws.ecs.memory_utilization,15m)>{$AWS.ECS.CLUSTER.MEMORY.UTIL.WARN}'
              name: 'AWS ECS Cluster: High memory utilization'
              event_name: 'AWS ECS Cluster: High memory utilization (over {$AWS.ECS.CLUSTER.MEMORY.UTIL.WARN}% for 15m)'
              opdata: 'Current utilization: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'The system is running out of free memory.'
              tags:
                - tag: scope
                  value: capacity
                - tag: scope
                  value: performance
        - uuid: 852512ccdd9e48f9849ac019d94cdf55
          name: 'AWS ECS Cluster: Get metrics check'
          type: DEPENDENT
          key: aws.ecs.metrics.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Data collection check.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 91ce423ddff44f0b8364e6d6470b15c5
              expression: 'length(last(/AWS ECS Serverless Cluster by HTTP/aws.ecs.metrics.check))>0'
              name: 'AWS ECS Cluster: Failed to get metrics data'
              opdata: '{ITEM.LASTVALUE1}'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 203c0c6607034e79ac9038d65cc4ee54
          name: 'AWS ECS Cluster: Network rx bytes'
          type: DEPENDENT
          key: aws.ecs.network.rx
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: Bps
          description: |
            'The number of bytes received by the resource that is specified by the dimensions that you're using.
             This metric is only available for containers in tasks using the awsvpc or bridge network modes.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "NetworkRxBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: network
        - uuid: ff917b212098496e814f259c6bf71146
          name: 'AWS ECS Cluster: Network tx bytes'
          type: DEPENDENT
          key: aws.ecs.network.tx
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: Bps
          description: |
            'The number of bytes transmitted by the resource that is specified by the dimensions that you're using.
             This metric is only available for containers in tasks using the awsvpc or bridge network modes.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "NetworkTxBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: network
        - uuid: b7aa2555bbc24d8587f89e39a4929e7e
          name: 'AWS ECS Cluster: Service Count'
          type: DEPENDENT
          key: aws.ecs.service_count
          delay: '0'
          history: 7d
          value_type: FLOAT
          description: '''The number of services in the cluster.'''
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "ServiceCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: system
        - uuid: 81d2ab08f2aa4608921269da28778e76
          name: 'AWS ECS Cluster: Task Count'
          type: DEPENDENT
          key: aws.ecs.task_count
          delay: '0'
          history: 7d
          value_type: FLOAT
          description: '''The number of tasks running in the cluster.'''
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.MetricData[?(@.Label == "TaskCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.ecs.get_metrics
          tags:
            - tag: component
              value: system
      discovery_rules:
        - uuid: 8cc32fccef92436eb0aabf7888e43735
          name: 'Cluster Alarms discovery'
          type: DEPENDENT
          key: aws.ecs.alarms.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ECS.LLD.FILTER.ALARM_NAME.MATCHES}'
                formulaid: A
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ECS.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ECS.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
                formulaid: C
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ECS.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discovery instance alarms.'
          item_prototypes:
            - uuid: a0cee89be68746ad8ad30de7ba1f444c
              name: 'AWS ECS Cluster Alarms: ["{#ALARM_NAME}"]: Get metrics'
              type: DEPENDENT
              key: 'aws.ecs.alarm.get_metrics["{#ALARM_NAME}"]'
              delay: '0'
              history: '0'
              trends: '0'
              value_type: TEXT
              description: 'Get alarm metrics about the state and its reason.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.AlarmName == "{#ALARM_NAME}")].first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: aws.ecs.get_alarms
              tags:
                - tag: component
                  value: raw
            - uuid: 7224b197422a4b8583a4a6ce43117153
              name: 'AWS ECS Cluster Alarms: ["{#ALARM_NAME}"]: State'
              type: DEPENDENT
              key: 'aws.ecs.alarm.state["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The state value for the alarm. Possible values: 0 (OK), 1 (INSUFFICIENT_DATA), 2 (ALARM).
                Alarm description:
                {#ALARM_DESCRIPTION}
              valuemap:
                name: 'Alarm state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateValue
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '3'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];
                      
                      return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());
              master_item:
                key: 'aws.ecs.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
              trigger_prototypes:
                - uuid: 78c58e8dddd34d7cbb5a9bdaada6db6d
                  expression: 'last(/AWS ECS Serverless Cluster by HTTP/aws.ecs.alarm.state["{#ALARM_NAME}"])=1'
                  name: 'AWS ECS Cluster Alarms: "{#ALARM_NAME}" has ''Insufficient data'' state'
                  priority: INFO
                  tags:
                    - tag: scope
                      value: notice
            - uuid: a45dcc184496489aa4564b290392a0b6
              name: 'AWS ECS Cluster Alarms: ["{#ALARM_NAME}"]: State reason'
              type: DEPENDENT
              key: 'aws.ecs.alarm.state_reason["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              trends: '0'
              value_type: TEXT
              description: |
                An explanation for the alarm state, in text format.
                Alarm description:
                {#ALARM_DESCRIPTION}
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateReason
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.ecs.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
          trigger_prototypes:
            - uuid: 64c6b0244f5a49f89465595d74b35880
              expression: 'last(/AWS ECS Serverless Cluster by HTTP/aws.ecs.alarm.state["{#ALARM_NAME}"])=2 and length(last(/AWS ECS Serverless Cluster by HTTP/aws.ecs.alarm.state_reason["{#ALARM_NAME}"]))>0'
              name: 'AWS ECS Cluster Alarms: "{#ALARM_NAME}" has ''Alarm'' state'
              priority: AVERAGE
              description: |
                Alarm "{#ALARM_NAME}" has 'Alarm' state. 
                Reason: {ITEM.LASTVALUE2}
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: aws.ecs.get_alarms
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var result = [];
                  var alarms = JSON.parse(value);
                  
                  alarms.forEach(function(alarm) {
                  
                   result.push({
                  '{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
                  '{#ALARM_NAME}': alarm.AlarmName,
                  '{#ALARM_PERIOD}': alarm.Period,
                  '{#METRIC_NAME}': alarm.MetricName,
                  '{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
                    });
                  });
                  
                  return JSON.stringify(result);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: adc6dcb0deef4aa79f8f39f4c8198871
          name: 'Cluster Services discovery'
          type: DEPENDENT
          key: aws.ecs.services.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ECS.SERVICE.NAME}'
                value: '{$AWS.ECS.LLD.FILTER.SERVICE.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ECS.SERVICE.NAME}'
                value: '{$AWS.ECS.LLD.FILTER.SERVICE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Discovery {$AWS.ECS.CLUSTER.NAME} services.'
          item_prototypes:
            - uuid: e098ff8ab20a468ba4a38ff621ff7aa6
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: CPU Utilization'
              type: DEPENDENT
              key: 'aws.ecs.services.cpu.utilization["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: '%'
              description: |
                "A number of CPU units used by tasks in the resource that is specified by the dimension set that you're using.
                 This metric is only collected for tasks that have a defined CPU reservation in their task definition."
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "AWS/ECS CPUUtilization")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: cpu
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
              trigger_prototypes:
                - uuid: 9c0d75d7b6ad40e18afa52cbcde3c2d9
                  expression: 'min(/AWS ECS Serverless Cluster by HTTP/aws.ecs.services.cpu.utilization["{#AWS.ECS.SERVICE.NAME}"],15m)>{$AWS.ECS.CLUSTER.SERVICE.CPU.UTIL.WARN}'
                  name: 'AWS ECS Cluster Service: High CPU utilization'
                  event_name: 'AWS ECS Cluster Service: High CPU utilization (over {$AWS.ECS.CLUSTER.SERVICE.CPU.UTIL.WARN}% for 15m)'
                  opdata: 'Current utilization: {ITEM.LASTVALUE1}'
                  priority: WARNING
                  description: 'The CPU utilization is too high. The system might be slow to respond.'
                  tags:
                    - tag: scope
                      value: capacity
                    - tag: scope
                      value: performance
                    - tag: service
                      value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: a1e8143735f246cb9daf660bde09e908
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: CPU Reserved'
              type: DEPENDENT
              key: 'aws.ecs.services.cpu_reserved["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              description: |
                "A number of CPU units reserved by tasks in the resource that is specified by the dimension set that you're using.
                 This metric is only collected for tasks that have a defined CPU reservation in their task definition."
              valuemap:
                name: 'CPU Reserved'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights CpuReserved")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: cpu
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 23f91e8623604201be2e8c194e5f0ba7
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Desired Task'
              type: DEPENDENT
              key: 'aws.ecs.services.desired.task["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              description: 'The desired number of tasks for an {#AWS.ECS.SERVICE.NAME} service.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights DesiredTaskCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 84b099e6e7b243f69a8b840d03b1035e
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Ephemeral storage reserved'
              type: DEPENDENT
              key: 'aws.ecs.services.ephemeral.storage.reserved["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: |
                'The number of bytes reserved from ephemeral storage in the resource that is specified by the dimensions that you're using. Ephemeral storage is used for the container root filesystem and any bind mount host volumes defined in the container image and task definition. The amount of ephemeral storage can’t be changed in a running task.
                This metric is only available for tasks that run on Fargate Linux platform version 1.4.0 or later.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights EphemeralStorageReserved")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1073741824'
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: component
                  value: storage
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: fa0a602c008346318dd2b747ecd3a6cf
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Ephemeral storage utilized'
              type: DEPENDENT
              key: 'aws.ecs.services.ephemeral.storage.utilized["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: |
                'The number of bytes used from ephemeral storage in the resource that is specified by the dimensions that you're using. Ephemeral storage is used for the container root filesystem and any bind mount host volumes defined in the container image and task definition. The amount of ephemeral storage can’t be changed in a running task.
                This metric is only available for tasks that run on Fargate Linux platform version 1.4.0 or later.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights EphemeralStorageUtilized")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1073741824'
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: component
                  value: storage
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 0f80f5477ed04dbfbcb241c06854a6ff
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Get metrics'
              type: SCRIPT
              key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              delay: 0s;m/5
              history: '0'
              trends: '0'
              value_type: TEXT
              params: |
                var AWS = {
                    params: {},
                    request_period: 600,
                
                    setParams: function (params) {
                        switch (AWS.getField(params, 'auth_type')) {
                            case 'role_base':
                                AWS.params['auth_type'] = 'role_base';
                                var request = new HttpRequest(),
                                    IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
                
                                if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                    throw 'Error getting security credentials from instance metadata. Role not found.';
                                }
                
                                credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
                
                                if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                    throw 'Error getting security credentials from instance metadata.';
                                }
                
                                try {
                                    credentials = JSON.parse(credentials);
                                }
                                catch (error) {
                                    throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                                }
                
                                ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                    if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                        throw 'Required credentials is not set: "' + field + '".';
                                    };
                                    AWS.params[field] = credentials[field];
                                });
                                break;
                            case 'access_key':
                            default:
                                AWS.params['auth_type'] = 'access_key';
                                ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                    if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                        throw 'Required param is not set: "' + field + '".';
                                    }
                                    AWS.params[field] = params[field];
                                });
                        }
                        ['region', 'cluster_name', 'service_name'].forEach(function (field) {
                            if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                throw 'Required param is not set: "' + field + '".';
                            }
                            AWS.params[field] = params[field];
                        });
                    },
                
                    getField: function (data, path) {
                        var steps = path.split('.');
                        for (var i = 0; i < steps.length; i++) {
                            var step = steps[i];
                            if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                                throw 'Required field was not found: ' + path;
                            }
                
                            data = data[step];
                        }
                
                        return data;
                    },
                    
                    sign: function (key, message) {
                        var hex = hmac('sha256', key, message);
                
                        if ((hex.length % 2) === 1) {
                            throw 'Invalid length of a hex string!';
                        }
                
                        var result = new Int8Array(hex.length / 2);
                        for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                            result[b] = parseInt(hex.substring(i, i + 2), 16);
                        }
                
                        return result;
                    },
                
                    prepareRecursive: function (prefix, param) {
                        var result = {};
                
                        if (typeof param === 'object') {
                            if (Array.isArray(param)) {
                                param.forEach(function (value, index) {
                                    var nested = AWS.prepareRecursive(prefix + '.member.' + (index + 1), value);
                                    Object.keys(nested).forEach(function (key) {
                                        result[key] = nested[key];
                                    });
                                });
                            }
                            else {
                                Object.keys(param).forEach(function (k) {
                                    var nested = AWS.prepareRecursive(prefix + '.' + k, param[k]);
                                    Object.keys(nested).forEach(function (key) {
                                        result[key] = nested[key];
                                    });
                                });
                            }
                        }
                        else {
                            result[prefix] = param;
                        }
                
                        return result;
                    },
                
                    renderPayload: function (period, cluster_name, service_name) {
                        var metrics_list = [
                            'CpuReserved:None:ECS/ContainerInsights',
                            'CpuUtilized:None:ECS/ContainerInsights',
                            'CPUUtilization:Percent:AWS/ECS',
                            'MemoryUtilization:Percent:AWS/ECS',
                            'MemoryReserved:Megabytes:ECS/ContainerInsights',
                            'MemoryUtilized:Megabytes:ECS/ContainerInsights',
                            'NetworkRxBytes:Bytes/Second:ECS/ContainerInsights',
                            'NetworkTxBytes:Bytes/Second:ECS/ContainerInsights',
                            'StorageReadBytes:Bytes:ECS/ContainerInsights',
                            'StorageWriteBytes:Bytes:ECS/ContainerInsights',
                            'DeploymentCount:Count:ECS/ContainerInsights',
                            'TaskSetCount:Count:ECS/ContainerInsights',
                            'DesiredTaskCount:Count:ECS/ContainerInsights',
                            'PendingTaskCount:Count:ECS/ContainerInsights',
                            'RunningTaskCount:Count:ECS/ContainerInsights',
                            'EphemeralStorageReserved:Gigabytes:ECS/ContainerInsights',
                            'EphemeralStorageUtilized:Gigabytes:ECS/ContainerInsights'
                        ];
                
                        var metric_payload = [];
                        metrics_list.forEach(function (metric) {
                            var parts = metric.split(':', 3);
                            var name = parts[0].replace(/[^a-zA-Z0-9]/g, '');
                            metric_payload.push({
                                'Id': name.charAt(0).toLowerCase() + name.slice(1),
                                'MetricStat': {
                                    'Metric': {
                                        'MetricName': parts[0],
                                        'Namespace': parts[2],
                                        'Dimensions': [
                                            {
                                                'Name': 'ClusterName',
                                                'Value': cluster_name
                                            }
                                            ,
                                            {
                                                'Name': 'ServiceName',
                                                'Value': service_name
                                            }
                                        ]
                                    },
                                    'Period': period,
                                    'Stat': 'Average',
                                    'Unit': parts[1]
                                }
                            });
                        });
                
                        return metric_payload;
                    },
                
                    prepareParams: function (params) {
                        var result = [];
                
                        Object.keys(params).sort().forEach(function (key) {
                            if (typeof params[key] !== 'object') {
                                result.push(key + '=' + encodeURIComponent(params[key]));
                            }
                            else {
                                result.push(prepareObject(key, params[key]));
                            }
                        });
                
                        return result.join('&');
                    },
                
                    request: function (method, region, service, params, data) {
                        if (typeof data === 'undefined' || data === null) {
                            data = '';
                        }
                
                        var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                            date = amzdate.replace(/T\d+Z/, ''),
                            host = service + '.' + region + '.amazonaws.com',
                            canonical_uri = '/',
                            canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                            signed_headers = 'content-encoding;host;x-amz-date',
                            canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                            credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                            request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                            key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                
                        key = AWS.sign(key, region);
                        key = AWS.sign(key, service);
                        key = AWS.sign(key, 'aws4_request');
                
                        var request = new HttpRequest(),
                            url = 'https://' + host + canonical_uri + '?' + params;
                
                        if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                            request.setProxy(AWS.params.proxy);
                        }
                        request.addHeader('x-amz-date: ' + amzdate);
                        request.addHeader('Accept: application/json');
                        request.addHeader('Content-Type: application/json');
                        request.addHeader('Content-Encoding: amz-1.0');
                        request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                        if (AWS.params.auth_type === 'role_base')
                            request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                        
                        Zabbix.log(4, '[ AWS ECS  ] Sending request: ' + url);
                
                        response = request.get(url);
                
                        Zabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);
                
                        if (request.getStatus() !== 200) {
                            throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                        }
                
                        if (response !== null) {
                            try {
                                response = JSON.parse(response);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                            }
                        }
                
                        return response;
                    },
                
                    getMetricsData: function () {
                        var timestamp = new Date().getTime(),
                            end_time = new Date(timestamp).toISOString().replace(/\.\d+Z/, 'Z'),
                            start_time = new Date(timestamp - AWS.request_period * 1000).toISOString().replace(/\.\d+Z/, 'Z'),
                            payload = AWS.prepareRecursive('MetricDataQueries', AWS.renderPayload(AWS.request_period, AWS.params.cluster_name, AWS.params.service_name));
                
                        payload['Action'] = 'GetMetricData';
                        payload['Version'] = '2010-08-01';
                        payload['StartTime'] = start_time;
                        payload['EndTime'] = end_time;
                        payload['ScanBy'] = 'TimestampDescending';
                
                        result = AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload));
                        MetricData = AWS.getField(result, 'GetMetricDataResponse.GetMetricDataResult.MetricDataResults')
                
                        return MetricData;
                    }
                };
                
                try {
                    AWS.setParams(JSON.parse(value));
                
                    return JSON.stringify(AWS.getMetricsData());
                }
                catch (error) {
                    error += (String(error).endsWith('.')) ? '' : '.';
                    Zabbix.log(3, '[ AWS ECS ] ERROR: ' + error);
                
                    return JSON.stringify({ 'error': error });
                }
              description: |
                Get metrics of ESC services.
                Full metrics list related to ECS : https://docs.aws.amazon.com/ecs/index.html
              preprocessing:
                - type: CHECK_NOT_SUPPORTED
                  parameters:
                    - '-1'
              timeout: 15s
              parameters:
                - name: AccessKeyId
                  value: '{$AWS.ACCESS.KEY.ID}'
                - name: auth_type
                  value: '{$AWS.AUTH_TYPE}'
                - name: cluster_name
                  value: '{$AWS.ECS.CLUSTER.NAME}'
                - name: proxy
                  value: '{$AWS.PROXY}'
                - name: region
                  value: '{$AWS.REGION}'
                - name: SecretAccessKey
                  value: '{$AWS.SECRET.ACCESS.KEY}'
                - name: service_name
                  value: '{#AWS.ECS.SERVICE.NAME}'
              tags:
                - tag: component
                  value: raw
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 869a2921e0e44163b45c18786ea92471
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Memory utilization'
              type: DEPENDENT
              key: 'aws.ecs.services.memory.utilization["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: '%'
              description: |
                'The memory being used by tasks in the resource that is specified by the dimension set that you're using.
                This metric is only collected for tasks that have a defined memory reservation in their task definition.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "AWS/ECS MemoryUtilization")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: memory
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
              trigger_prototypes:
                - uuid: 7146da954a6d40d4ad8aa83ee3bdb1eb
                  expression: 'min(/AWS ECS Serverless Cluster by HTTP/aws.ecs.services.memory.utilization["{#AWS.ECS.SERVICE.NAME}"],15m)>{$AWS.ECS.CLUSTER.SERVICE.MEMORY.UTIL.WARN}'
                  name: 'AWS ECS Cluster Service: High memory utilization'
                  event_name: 'AWS ECS Cluster Service: High memory utilization (over {$AWS.ECS.CLUSTER.SERVICE.MEMORY.UTIL.WARN}% for 15m)'
                  opdata: 'Current utilization: {ITEM.LASTVALUE1}'
                  priority: WARNING
                  description: 'The system is running out of free memory.'
                  tags:
                    - tag: scope
                      value: capacity
                    - tag: scope
                      value: performance
                    - tag: service
                      value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: bd7bbc9699b8404592a8d67b437f1315
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Memory reserved'
              type: DEPENDENT
              key: 'aws.ecs.services.memory_reserved["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: |
                'The memory that is reserved by tasks in the resource that is specified by the dimension set that you're using. 
                This metric is only collected for tasks that have a defined memory reservation in their task definition.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights MemoryReserved")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1048576'
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: memory
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: a00e917d61a24df4b4f0234643667ad9
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Memory utilized'
              type: DEPENDENT
              key: 'aws.ecs.services.memory_utilized["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: |
                'The memory being used by tasks in the resource that is specified by the dimension set that you're using.
                This metric is only collected for tasks that have a defined memory reservation in their task definition.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights MemoryUtilized")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1048576'
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: memory
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 517dd17172554f3bae93ccb030c75c3a
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Network rx bytes'
              type: DEPENDENT
              key: 'aws.ecs.services.network.rx["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: Bps
              description: |
                'The number of bytes received by the resource that is specified by the dimensions that you're using.
                This metric is only available for containers in tasks using the awsvpc or bridge network modes.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights NetworkRxBytes")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: network
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: bd99f218853b4f6bac3020d9a7f8a544
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Network tx bytes'
              type: DEPENDENT
              key: 'aws.ecs.services.network.tx["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: Bps
              description: |
                'The number of bytes transmitted by the resource that is specified by the dimensions that you're using.
                This metric is only available for containers in tasks using the awsvpc or bridge network modes.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights NetworkTxBytes")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: network
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: e9e3c9ed4ac44d8e8c0f1e3ad55cc114
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Pending Task'
              type: DEPENDENT
              key: 'aws.ecs.services.pending.task["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              description: 'The number of tasks currently in the `pending` state.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights PendingTaskCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: f2f7feb7a3194221aae8ed71b12e49eb
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Running Task'
              type: DEPENDENT
              key: 'aws.ecs.services.running.task["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              description: 'The number of tasks currently in the `running` state.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights RunningTaskCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 4c9ea34655f44192be806b3225a38233
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Storage read bytes'
              type: DEPENDENT
              key: 'aws.ecs.services.storage.read.bytes["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: '''The number of bytes read from storage in the resource that is specified by the dimensions that you''re using.'''
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights StorageReadBytes")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: component
                  value: storage
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: a240f6821aab42a8aa97a2263f126356
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Storage write bytes'
              type: DEPENDENT
              key: 'aws.ecs.services.storage.write.bytes["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              units: B
              description: '''The number of bytes written to storage in the resource that is specified by the dimensions that you''re using.'''
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights StorageWriteBytes")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: component
                  value: storage
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
            - uuid: 6e80c7b477b648329480ad2dfb19f282
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Task Set'
              type: DEPENDENT
              key: 'aws.ecs.services.task.set["{#AWS.ECS.SERVICE.NAME}"]'
              delay: '0'
              history: 7d
              value_type: FLOAT
              description: 'The number of task sets in the {#AWS.ECS.SERVICE.NAME} service.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "ECS/ContainerInsights TaskSetCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.ecs.services.get_metrics["{#AWS.ECS.SERVICE.NAME}"]'
              tags:
                - tag: component
                  value: services
                - tag: service
                  value: '{#AWS.ECS.SERVICE.NAME}'
          graph_prototypes:
            - uuid: 2c511d8c02bb47e6954bce0e8d35d713
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: CPU Utilization'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 2196F3
                  item:
                    host: 'AWS ECS Serverless Cluster by HTTP'
                    key: 'aws.ecs.services.cpu.utilization["{#AWS.ECS.SERVICE.NAME}"]'
            - uuid: 962375e2a79a4b26b8c1f42f008158ae
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Memory Utilization'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 2196F3
                  item:
                    host: 'AWS ECS Serverless Cluster by HTTP'
                    key: 'aws.ecs.services.memory.utilization["{#AWS.ECS.SERVICE.NAME}"]'
            - uuid: 0823c8464d1d4f0ba4aef10f02c24cb3
              name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Network'
              graph_items:
                - color: 199C0D
                  item:
                    host: 'AWS ECS Serverless Cluster by HTTP'
                    key: 'aws.ecs.services.network.rx["{#AWS.ECS.SERVICE.NAME}"]'
                - sortorder: '1'
                  color: F63100
                  item:
                    host: 'AWS ECS Serverless Cluster by HTTP'
                    key: 'aws.ecs.services.network.tx["{#AWS.ECS.SERVICE.NAME}"]'
          master_item:
            key: aws.ecs.get_cluster_services
          lld_macro_paths:
            - lld_macro: '{#AWS.ECS.SERVICE.NAME}'
              path: $.service_name
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.services
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: target
          value: aws
        - tag: target
          value: ecs
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: role_base
          description: 'Authorization method. Possible values: role_base, access_key.'
        - macro: '{$AWS.ECS.CLUSTER.CPU.UTIL.WARN}'
          value: '70'
          description: 'The warning threshold of the cluster CPU utilization expressed in %.'
        - macro: '{$AWS.ECS.CLUSTER.MEMORY.UTIL.WARN}'
          value: '70'
          description: 'The warning threshold of the cluster memory utilization expressed in %.'
        - macro: '{$AWS.ECS.CLUSTER.NAME}'
          description: 'ECS cluster name.'
        - macro: '{$AWS.ECS.CLUSTER.SERVICE.CPU.UTIL.WARN}'
          value: '80'
          description: 'The warning threshold of the cluster service CPU utilization expressed in %.'
        - macro: '{$AWS.ECS.CLUSTER.SERVICE.MEMORY.UTIL.WARN}'
          value: '80'
          description: 'The warning threshold of the cluster service memory utilization expressed in %.'
        - macro: '{$AWS.ECS.LLD.FILTER.ALARM_NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by name.'
        - macro: '{$AWS.ECS.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by name.'
        - macro: '{$AWS.ECS.LLD.FILTER.SERVICE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable services by name.'
        - macro: '{$AWS.ECS.LLD.FILTER.SERVICE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered services by name.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets HTTP proxy value. If this macro is empty then no proxy is used.'
        - macro: '{$AWS.REGION}'
          value: us-west-1
          description: 'Amazon ECS Region code.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          type: SECRET_TEXT
          description: 'Secret access key.'
      dashboards:
        - uuid: 21cc12db2b0f4289b0660fcf5538b65d
          name: 'Overview AWS ECS Serverless Cluster'
          pages:
            - name: Cluster
              widgets:
                - type: item
                  name: 'Service count'
                  width: '8'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        key: aws.ecs.service_count
                    - type: INTEGER
                      name: show.0
                      value: '2'
                - type: graph
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster: CPU Utilization'
                    - type: STRING
                      name: reference
                      value: AAAAD
                - type: graph
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster: Memory Utilization'
                    - type: STRING
                      name: reference
                      value: AAAAC
                - type: graph
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster: Disk Utilization'
                    - type: STRING
                      name: reference
                      value: AAAAB
                - type: graph
                  'y': '20'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster: Network'
                    - type: STRING
                      name: reference
                      value: AAAAA
                - type: item
                  name: 'Task count'
                  x: '8'
                  width: '8'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        key: aws.ecs.task_count
                    - type: INTEGER
                      name: show.0
                      value: '2'
                - type: item
                  name: 'Container instance count'
                  x: '16'
                  width: '8'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        key: aws.ecs.container_instance_count
                    - type: INTEGER
                      name: show.0
                      value: '2'
            - name: Services
              widgets:
                - type: graphprototype
                  width: '24'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: CPU Utilization'
                    - type: STRING
                      name: reference
                      value: AAAAE
                - type: graphprototype
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Memory Utilization'
                    - type: STRING
                      name: reference
                      value: AAAAF
                - type: graphprototype
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid.0
                      value:
                        host: 'AWS ECS Serverless Cluster by HTTP'
                        name: 'AWS ECS Cluster Service: ["{#AWS.ECS.SERVICE.NAME}"]: Network'
                    - type: STRING
                      name: reference
                      value: AAAAG
      valuemaps:
        - uuid: 2de56a6f2b004624976a39e7b58ea193
          name: 'Alarm state'
          mappings:
            - value: '0'
              newvalue: OK
            - value: '1'
              newvalue: 'Insufficient data'
            - value: '2'
              newvalue: Alarm
            - value: '255'
              newvalue: Unknown
        - uuid: e49859d7e9b1494181dec88a386b4bb2
          name: 'CPU Reserved'
          mappings:
            - value: '256'
              newvalue: '.25 vCPU'
            - value: '512'
              newvalue: '.5 vCPU'
            - value: '1024'
              newvalue: '1 vCPU'
            - value: '2048'
              newvalue: '2 vCPU'
            - value: '4096'
              newvalue: '4 vCPU'
            - value: '8192'
              newvalue: '8 vCPU'
            - value: '16384'
              newvalue: '16 vCPU'
            - value: '32768'
              newvalue: '32 vCPU'
  graphs:
    - uuid: 22143acf16da404cbb4a770d47a16e64
      name: 'AWS ECS Cluster: CPU Utilization'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 2196F3
          item:
            host: 'AWS ECS Serverless Cluster by HTTP'
            key: aws.ecs.cpu_utilization
    - uuid: e9bb6696b7f34beb9ba207821cb9c4e1
      name: 'AWS ECS Cluster: Disk Utilization'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 2196F3
          item:
            host: 'AWS ECS Serverless Cluster by HTTP'
            key: aws.ecs.disk.utilization
    - uuid: fefa5004db6f44c4a10cbebd00a82280
      name: 'AWS ECS Cluster: Memory Utilization'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 2196F3
          item:
            host: 'AWS ECS Serverless Cluster by HTTP'
            key: aws.ecs.memory_utilization
    - uuid: b2e46c9ceafd495998fd98957e3f7414
      name: 'AWS ECS Cluster: Network'
      graph_items:
        - color: 199C0D
          item:
            host: 'AWS ECS Serverless Cluster by HTTP'
            key: aws.ecs.network.rx
        - sortorder: '1'
          color: F63100
          item:
            host: 'AWS ECS Serverless Cluster by HTTP'
            key: aws.ecs.network.tx
