zabbix_export:
  version: '7.0'
  template_groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  host_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Applications
    - uuid: 748ad4d098d447d492bb935c907f652f
      name: Databases
    - uuid: 137f19e6e2dc4219b33553b812627bc2
      name: 'Virtual machines'
  templates:
    - uuid: c60e5929ab474f67bbe67dc6b04e709d
      template: 'AWS by HTTP'
      name: 'AWS by HTTP'
      description: |
        Get AWS EC2, RDS and S3 instances, AWS ECS clusters. Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      vendor:
        name: Zabbix
        version: 7.0-0
      groups:
        - name: Templates/Cloud
      discovery_rules:
        - uuid: c651911bad9244ad9c8d2dad5b0d70e4
          name: 'EC2 instances discovery'
          type: SCRIPT
          key: aws.ec2.discovery
          delay: 12h
          params: |
            var AWS = {
                params: {},
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region_match', 'region_not_match'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, host, params, data, uri) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
            
                        canonical_uri = '/' + uri,
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('x-amz-content-sha256:' + sha256(data));
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/json');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                    
                        Zabbix.log(4, '[ AWS EC2 ] Sending request: ' + url);
            
                    response = request.post(url, data);
            
                    Zabbix.log(4, '[ AWS EC2 ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
                    if (response !== null) {
                        try {
                            response = XML.toJson(response);
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                        }
                    }
            
                    return JSON.parse(response);
                },
            
                tagToNameInstances: function (instance) {
                    var tags = AWS.getField(instance, 'tagSet.item'),
                        instanceName = AWS.getField(instance, 'instanceId');
                    if (!Array.isArray(tags))
                        tags = [tags]
                    tags.forEach(
                        function (tag) {
                            if (String(AWS.getField(tag, 'key')) === 'Name') {
                                instanceName = AWS.getField(tag, 'value');
                            }
                        }
                    );
                    return instanceName;
                },
            
                listRegions: function () {
                    var payload = {
                        'Action': 'DescribeRegions',
                        'Version': '2016-11-15'
                    };
            
                    result = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');
            
                    regions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')
                    if (!Array.isArray(regions))
                        regions = [regions]
                    return regions
                },
            
                listInstances: function () {
                    var lld_array = [],
                        regions = AWS.listRegions(),
                        payload = {
                            'Action': 'DescribeInstances',
                            'Version': '2016-11-15'
                        };
            
                    regions.forEach(function (region) {
                        var region_name = AWS.getField(region, 'regionName');
                        if (region_name.match(AWS.params.region_match) === null ||
                            region_name.match(AWS.params.region_not_match) !== null)
                            return;
            
                        result = AWS.request('POST', region_name, 'ec2', AWS.getField(region, 'regionEndpoint'), AWS.prepareParams(payload), '', '');
            
                        if (typeof result !== 'object'
                            || typeof result.DescribeInstancesResponse !== 'object'
                            || typeof result.DescribeInstancesResponse.reservationSet !== 'object') {
                            throw 'Cannot get EC2 instance list from AWS API. Check debug log for more information.';
                        }
            
                        if (result.DescribeInstancesResponse.reservationSet === null)
                            return [];
            
                        if (typeof result.DescribeInstancesResponse.reservationSet.item !== 'object')
                            throw 'Cannot get EC2 instance list from AWS API. Check debug log for more information.';
            
                        var reservation = result.DescribeInstancesResponse.reservationSet.item
                        if (!Array.isArray(reservation))
                            reservation = [reservation]
            
                        reservation.forEach(function (res_item) {
                            var instances = AWS.getField(res_item, 'instancesSet.item')
                            if (!Array.isArray(instances))
                                instances = [instances]
                            instances.forEach(function (instance) {
                                if (AWS.getField(instance, 'instanceState.name') === 'terminated') return;
                                lld_array.push(
                                    {
                                        instanceId: AWS.getField(instance, 'instanceId'),
                                        instanceName: AWS.tagToNameInstances(instance),
                                        instanceRegion: region_name
                                    }
                                )
                            });
                        });
                    });
            
                    return lld_array;
                }
            };
            
            try {
                AWS.setParams(JSON.parse(value));
            
                return JSON.stringify(AWS.listInstances());
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS EC2 ] ERROR: ' + error);
                return JSON.stringify({ 'error': error });
            }
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.EC2.INSTANCE.NAME}'
                value: '{$AWS.EC2.LLD.FILTER.NAME.MATCHES}'
                formulaid: A
              - macro: '{#AWS.EC2.INSTANCE.NAME}'
                value: '{$AWS.EC2.LLD.FILTER.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#AWS.EC2.INSTANCE.REGION}'
                value: '{$AWS.EC2.LLD.FILTER.REGION.MATCHES}'
                formulaid: C
              - macro: '{#AWS.EC2.INSTANCE.REGION}'
                value: '{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Get EC2 instances.'
          host_prototypes:
            - uuid: c4c830c727294b07926c39b00cf19046
              host: '{#AWS.EC2.INSTANCE.ID}'
              name: '{#AWS.EC2.INSTANCE.NAME}'
              group_links:
                - group:
                    name: 'Virtual machines'
              templates:
                - name: 'AWS EC2 by HTTP'
              macros:
                - macro: '{$AWS.EC2.INSTANCE.ID}'
                  value: '{#AWS.EC2.INSTANCE.ID}'
                  description: 'EC2 instance ID.'
                - macro: '{$AWS.REGION}'
                  value: '{#AWS.EC2.INSTANCE.REGION}'
                  description: 'Amazon EC2 Region code.'
              tags:
                - tag: name
                  value: '{#AWS.EC2.INSTANCE.NAME}'
                - tag: region
                  value: '{#AWS.EC2.INSTANCE.REGION}'
                - tag: service
                  value: ec2
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#AWS.EC2.INSTANCE.ID}'
          timeout: 60s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region_match
              value: '{$AWS.EC2.LLD.FILTER.REGION.MATCHES}'
            - name: region_not_match
              value: '{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          lld_macro_paths:
            - lld_macro: '{#AWS.EC2.INSTANCE.ID}'
              path: $.instanceId
            - lld_macro: '{#AWS.EC2.INSTANCE.NAME}'
              path: $.instanceName
            - lld_macro: '{#AWS.EC2.INSTANCE.REGION}'
              path: $.instanceRegion
        - uuid: 44b68894d68c45ec9a5ea787c975ae16
          name: 'ECS clusters discovery'
          type: SCRIPT
          key: aws.ecs.discovery
          delay: 12h
          params: |
            var AWS = {
                params: {},
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region_match', 'region_not_match'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
                        data = data[step];
                    }
            
                    return data;
            
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
            
                },
            
                prepareParams: function (params) {
                    var result = [];
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
            
                },
            
                request: function (method, region, service, host, params, data, uri) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
                        canonical_uri = '/' + uri,
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('x-amz-content-sha256:' + sha256(data));
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/x-www-form-urlencoded');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                    
                    Zabbix.log(4, '[ AWS ECS ] Sending request: ' + url);
            
                    response = request.post(url, data);
            
                    Zabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
                    try {
                        response = JSON.parse(response);
                    }
                    catch (error) {
                        try {
                            response = JSON.parse(XML.toJson(response));
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS API. Check debug log for more information.';
                        }
                    }
            
                    return response;
            
                },
            
                listRegions: function () {
                    var payload = {
                        'Action': 'DescribeRegions',
                        'Version': '2016-11-15'
                    };
            
                    result = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');
            
                    regions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')
                    if (!Array.isArray(regions))
                        regions = [regions]
                    return regions
                },
            
                listClusters: function () {
                    var data = [],
                        regions = AWS.listRegions(),
                        result,
                        ECSClusters,
                        payload = {
                            'Action': 'ListClusters',
                            'Version': '2014-11-13'
                        };
            
                    regions.forEach(function (region) {
                        var region_name = AWS.getField(region, 'regionName');
                        if (region_name.match(AWS.params.region_match) === null ||
                            region_name.match(AWS.params.region_not_match) !== null)
                            return;
            
                        result = AWS.request('POST', region_name, 'ecs', 'ecs.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');
                        ECSClusters = AWS.getField(result, 'ListClustersResponse.ListClustersResult.clusterArns')
                        for (k in ECSClusters) {
                            clusters = ECSClusters[k];
                            json = {};
                            input = clusters.split('/');
                            for (var i = 1; i < input.length; i += 2) {
                                json[input[i]] = input[i + 1];
                            }
                            data.push({
                                'clusters_name': input[1],
                                'region': region_name
                            });
                        }
                    });
                    return data;
                },
            
                decribeClusters: function (cluster_name, region_name) {
                    var payload = {},
                        result;
                    payload['Action'] = 'DescribeClusters';
                    payload['Version'] = '2014-11-13';
                    payload['clusters.clusterName'] = cluster_name;
                    payload['include.statistics'] = 'STATISTICS';
                    result = AWS.request('POST', region_name, 'ecs', 'ecs.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');
            
                    return result;
            
                }
            
            };
            
            try {
                AWS.setParams(JSON.parse(value));
                var clusters = AWS.listClusters(),
                    infrastructure = [],
                    metrics = ['runningEC2TasksCount', 'pendingEC2TasksCount', 'activeEC2ServiceCount', 'drainingEC2ServiceCount'],
                    ECSClusters = [],
                    DescribeClusters = [];
                DescribeClusters = clusters.map(function (cluster) {
                    ECSClusters = AWS.getField(AWS.decribeClusters(cluster.clusters_name, cluster.region), 'DescribeClustersResponse.DescribeClustersResult.clusters')
                    for (k in ECSClusters) {
                        var ECS2 = 0;
                        statistic = AWS.getField(ECSClusters[k], 'statistics');
                        statistic.forEach(function (id) {
                            for (i in metrics) {
                                if (AWS.getField(id, 'name') === metrics[i]) {
                                    ECS2 += Number(AWS.getField(id, 'value'));
                                }
                            }
                        })
                        infrastructure = (ECS2 > 0) ? 'use_ecs2' : 'serverless';
            
                        return {
                            'clusterName': ECSClusters[k].clusterName,
                            'status': ECSClusters[k].status,
                            'infrastructure': infrastructure,
                            'region': cluster.region
                        }
            
                    }
                })
                return JSON.stringify(DescribeClusters);
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS ECS ] ERROR: ' + error);
                return JSON.stringify({ 'error': error });
            }
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ECS.CLUSTER.NAME}'
                value: '{$AWS.ECS.LLD.FILTER.NAME.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ECS.CLUSTER.NAME}'
                value: '{$AWS.ECS.LLD.FILTER.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#AWS.ECS.CLUSTER.REGION}'
                value: '{$AWS.ECS.LLD.FILTER.REGION.MATCHES}'
                formulaid: C
              - macro: '{#AWS.ECS.CLUSTER.REGION}'
                value: '{$AWS.ECS.LLD.FILTER.REGION.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
              - macro: '{#AWS.ECS.CLUSTER.STATUS}'
                value: '{$AWS.ECS.LLD.FILTER.STATUS.MATCHES}'
                formulaid: E
              - macro: '{#AWS.ECS.CLUSTER.STATUS}'
                value: '{$AWS.ECS.LLD.FILTER.STATUS.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: F
          description: 'Get ECS clusters.'
          host_prototypes:
            - uuid: 71072e5a149e45b293946866f8220c07
              host: '{#AWS.ECS.CLUSTER.NAME}'
              name: '{#AWS.ECS.CLUSTER.NAME}'
              group_links:
                - group:
                    name: Applications
              macros:
                - macro: '{$AWS.ECS.CLUSTER.NAME}'
                  value: '{#AWS.ECS.CLUSTER.NAME}'
                  description: 'ECS cluster name.'
                - macro: '{$AWS.REGION}'
                  value: '{#AWS.ECS.CLUSTER.REGION}'
                  description: 'ECS cluster name.'
              tags:
                - tag: name
                  value: '{#AWS.ECS.CLUSTER.NAME}'
                - tag: region
                  value: '{#AWS.ECS.CLUSTER.REGION}'
                - tag: service
                  value: ecs
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region_match
              value: '{$AWS.EC2.LLD.FILTER.REGION.MATCHES}'
            - name: region_not_match
              value: '{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          lld_macro_paths:
            - lld_macro: '{#AWS.ECS.CLUSTER.INFRASTRUCTURE}'
              path: $.infrastructure
            - lld_macro: '{#AWS.ECS.CLUSTER.NAME}'
              path: $.clusterName
            - lld_macro: '{#AWS.ECS.CLUSTER.REGION}'
              path: $.region
            - lld_macro: '{#AWS.ECS.CLUSTER.STATUS}'
              path: $.status
          overrides:
            - name: Serverless
              step: '1'
              filter:
                conditions:
                  - macro: '{#AWS.ECS.CLUSTER.INFRASTRUCTURE}'
                    value: ^serverless$
                    formulaid: A
              operations:
                - operationobject: HOST_PROTOTYPE
                  operator: REGEXP
                  templates:
                    - name: 'AWS ECS Serverless Cluster by HTTP'
            - name: 'Use EC2 Infrastructure'
              step: '2'
              filter:
                conditions:
                  - macro: '{#AWS.ECS.CLUSTER.INFRASTRUCTURE}'
                    value: ^use_ecs2$
                    formulaid: A
              operations:
                - operationobject: HOST_PROTOTYPE
                  operator: REGEXP
                  templates:
                    - name: 'AWS ECS Cluster by HTTP'
        - uuid: c1127e674b7548b2802cd8771f3a4768
          name: 'RDS instances discovery'
          type: SCRIPT
          key: aws.rds.discovery
          delay: 12h
          params: |
            var AWS = {
                params: {},
            
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region_match', 'region_not_match'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, host, params, data, uri) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
            
                        canonical_uri = '/' + uri,
                        canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                        signed_headers = 'content-encoding;host;x-amz-date',
                        canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('x-amz-content-sha256:' + sha256(data));
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/json');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
                    Zabbix.log(4, '[ AWS RDS ] Sending request: ' + url);
            
                    response = request.post(url, data);
            
                    Zabbix.log(4, '[ AWS RDS ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
            
                    try {
                        response = JSON.parse(response);
                    }
                    catch (error) {
                        try {
                            response = JSON.parse(XML.toJson(response));
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS API. Check debug log for more information.';
                        }
                    }
            
                    return response;
                },
            
                listRegions: function () {
                    var payload = {
                        'Action': 'DescribeRegions',
                        'Version': '2016-11-15'
                    };
            
                    result = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');
            
                    regions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')
                    if (!Array.isArray(regions))
                        regions = [regions]
                    return regions
                },
            
                listInstances: function () {
                    var lld_array = [],
                        regions = AWS.listRegions(),
                        payload = {
                            'Action': 'DescribeDBInstances',
                            'Version': '2014-10-31'
                        };
            
                    regions.forEach(function (region) {
                        var region_name = AWS.getField(region, 'regionName');
                        if (region_name.match(AWS.params.region_match) === null ||
                            region_name.match(AWS.params.region_not_match) !== null)
                            return;
            
                        result = AWS.request('POST', region_name, 'rds', 'rds.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');
            
                        databases = AWS.getField(result, 'DescribeDBInstancesResponse.DescribeDBInstancesResult.DBInstances')
                        if (!Array.isArray(databases))
                            databases = [databases]
            
                        databases.forEach(function (db) {
                            lld_array.push(
                                {
                                    DBInstanceIdentifier: AWS.getField(db, 'DBInstanceIdentifier'),
                                    instanceRegion: region_name
                                }
                            )
                        });
                    });
            
                    return lld_array;
                }
            };
            
            try {
                AWS.setParams(JSON.parse(value));
            
                return JSON.stringify(AWS.listInstances());
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS RDS ] ERROR: ' + error);
                return JSON.stringify({ 'error': error });
            }
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.RDS.INSTANCE.ID}'
                value: '{$AWS.RDS.LLD.FILTER.NAME.MATCHES}'
                formulaid: A
              - macro: '{#AWS.RDS.INSTANCE.ID}'
                value: '{$AWS.RDS.LLD.FILTER.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#AWS.RDS.REGION}'
                value: '{$AWS.RDS.LLD.FILTER.REGION.MATCHES}'
                formulaid: C
              - macro: '{#AWS.RDS.REGION}'
                value: '{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Get RDS instances.'
          host_prototypes:
            - uuid: 799663c52a644f78aa3b3c14d4cc7235
              host: '{#AWS.RDS.INSTANCE.ID}'
              name: '{#AWS.RDS.INSTANCE.ID}'
              group_links:
                - group:
                    name: Databases
              templates:
                - name: 'AWS RDS instance by HTTP'
              macros:
                - macro: '{$AWS.RDS.INSTANCE.ID}'
                  value: '{#AWS.RDS.INSTANCE.ID}'
                  description: 'RDS instance ID.'
                - macro: '{$AWS.REGION}'
                  value: '{#AWS.RDS.REGION}'
                  description: 'RDS instance region.'
              tags:
                - tag: name
                  value: '{#AWS.RDS.INSTANCE.ID}'
                - tag: region
                  value: '{#AWS.RDS.REGION}'
                - tag: service
                  value: rds
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#AWS.RDS.INSTANCE.ID}'
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region_match
              value: '{$AWS.RDS.LLD.FILTER.REGION.MATCHES}'
            - name: region_not_match
              value: '{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          lld_macro_paths:
            - lld_macro: '{#AWS.RDS.INSTANCE.ID}'
              path: $.DBInstanceIdentifier
            - lld_macro: '{#AWS.RDS.REGION}'
              path: $.instanceRegion
        - uuid: ab6a97a108fb4dbc9fd1e07378721ffe
          name: 'S3 buckets discovery'
          type: SCRIPT
          key: aws.s3.discovery
          delay: 12h
          params: |
            var AWS = {
                params: {},
                
                getField: function (data, path) {
                    var steps = path.split('.');
                    for (var i = 0; i < steps.length; i++) {
                        var step = steps[i];
                        if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                            throw 'Required field was not found: ' + path;
                        }
            
                        data = data[step];
                    }
            
                    return data;
                },
            
                setParams: function (params) {
                    switch (AWS.getField(params, 'auth_type')) {
                        case 'role_base':
                            AWS.params['auth_type'] = 'role_base';
                            var request = new HttpRequest(),
                                IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
                            if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                                throw 'Error getting security credentials from instance metadata. Role not found.';
                            }
            
                            credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
                            if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                                throw 'Error getting security credentials from instance metadata.';
                            }
            
                            try {
                                credentials = JSON.parse(credentials);
                            }
                            catch (error) {
                                throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                            }
            
                            ['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                                if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                                    throw 'Required credentials is not set: "' + field + '".';
                                };
                                AWS.params[field] = credentials[field];
                            });
                            break;
                        case 'access_key':
                        default:
                            AWS.params['auth_type'] = 'access_key';
                            ['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                                if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                                    throw 'Required param is not set: "' + field + '".';
                                }
                                AWS.params[field] = params[field];
                            });
                    }
                    ['region_match', 'region_not_match'].forEach(function (field) {
                        if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                            throw 'Required param is not set: "' + field + '".';
                        }
                        AWS.params[field] = params[field];
                    });
                },
            
                sign: function (key, message) {
                    var hex = hmac('sha256', key, message);
            
                    if ((hex.length % 2) === 1) {
                        throw 'Invalid length of a hex string!';
                    }
            
                    var result = new Int8Array(hex.length / 2);
                    for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                        result[b] = parseInt(hex.substring(i, i + 2), 16);
                    }
            
                    return result;
                },
            
                prepareParams: function (params) {
                    var result = [];
            
                    Object.keys(params).sort().forEach(function (key) {
                        if (typeof params[key] !== 'object') {
                            result.push(key + '=' + encodeURIComponent(params[key]));
                        }
                        else {
                            result.push(prepareObject(key, params[key]));
                        }
                    });
            
                    return result.join('&');
                },
            
                request: function (method, region, service, host, params, data, uri) {
                    if (typeof data === 'undefined' || data === null) {
                        data = '';
                    }
            
                    var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                        date = amzdate.replace(/T\d+Z/, ''),
            
                        canonical_uri = '/' + uri;
            
                    if (AWS.params.auth_type === 'role_base'){
                        var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
                            signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
                    } else {
                        var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                            signed_headers = 'content-encoding;host;x-amz-date';
                    }
            
                    var canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                        credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                        request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                        key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
                    key = AWS.sign(key, region);
                    key = AWS.sign(key, service);
                    key = AWS.sign(key, 'aws4_request');
            
                    var request = new HttpRequest(),
                        url = 'https://' + host + canonical_uri + '?' + params;
            
                    if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                        request.setProxy(AWS.params.proxy);
                    }
                    request.addHeader('x-amz-date: ' + amzdate);
                    request.addHeader('x-amz-content-sha256:' + sha256(data));
                    request.addHeader('Accept: application/json');
                    request.addHeader('Content-Type: application/json');
                    request.addHeader('Content-Encoding: amz-1.0');
                    request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                    if (AWS.params.auth_type === 'role_base')
                        request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
                    Zabbix.log(4, '[ AWS S3 ] Sending request: ' + url);
            
                    response = request.get(url);
            
                    Zabbix.log(4, '[ AWS S3 ] Received response with status code ' + request.getStatus() + ': ' + response);
            
                    if (request.getStatus() !== 200) {
                        throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                    }
                    if (response !== null) {
                        try {
                            response = XML.toJson(response);
                        }
                        catch (error) {
                            throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
                        }
                    }
            
                    return JSON.parse(response);
                },
            
                getBucketLocation: function (bucket_name) {
                    var payload = {};
            
                    payload['location'] = '',
            
                        result = AWS.request('GET', 'us-east-1', 's3', 's3.amazonaws.com', AWS.prepareParams(payload), '', bucket_name);
            
                    if (typeof result !== 'object'
                        || result.hasOwnProperty('LocationConstraint') === false
                    ) {
                        throw 'Cannot get buckets region location data from AWS S3 API. Check debug log for more information.';
                    }
            
                    return result.LocationConstraint !== null ? result.LocationConstraint : 'us-east-1';
                },
            
                listBuckets: function () {
                    var lld_array = [],
                        payload = {
                        'Action': 'ListBuckets',
                        'Version': '2006-03-01'
                    };
                    
                    result = AWS.request('GET', 'us-east-1', 's3', 's3.us-east-1.amazonaws.com', AWS.prepareParams(payload), '', '');
                    
                    if (typeof result !== 'object'
                        || typeof result.ListAllMyBucketsResult !== 'object'
                        || typeof result.ListAllMyBucketsResult.Buckets !== 'object') {
                        throw 'Cannot get buckets list from AWS S3 API. Check debug log for more information.';
                    }
                    if (result.ListAllMyBucketsResult.Buckets === null)
                        return []
                    if (typeof result.ListAllMyBucketsResult.Buckets.Bucket !== 'object') {
                        throw 'Cannot get buckets list from AWS S3 API. Check debug log for more information.';
                    }
            
                    var buckets = [];
                    if (!Array.isArray(result.ListAllMyBucketsResult.Buckets.Bucket))
                        buckets = [result.ListAllMyBucketsResult.Buckets.Bucket]
                    else
                        buckets = result.ListAllMyBucketsResult.Buckets.Bucket
                    buckets.forEach(
                        function (bucket, index, buckets_array) {
                            if (!bucket.hasOwnProperty('Name'))
                                throw 'Cannot get location for bucket. Check debug log for more information.';
                            var region_name = AWS.getBucketLocation(bucket['Name']);
                            buckets_array[index]['location'] = region_name;
                            if (region_name.match(AWS.params.region_match) !== null &&
                                region_name.match(AWS.params.region_not_match) === null)
                                lld_array.push(buckets_array[index]);
                        });
            
                    return lld_array;
                }
            };
            
            try {
                AWS.setParams(JSON.parse(value));
            
                return JSON.stringify(AWS.listBuckets());
            }
            catch (error) {
                error += (String(error).endsWith('.')) ? '' : '.';
                Zabbix.log(3, '[ AWS S3 ] ERROR: ' + error);
                return JSON.stringify({ 'error': error });
            }
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.S3.NAME}'
                value: '{$AWS.S3.LLD.FILTER.NAME.MATCHES}'
                formulaid: A
              - macro: '{#AWS.S3.NAME}'
                value: '{$AWS.S3.LLD.FILTER.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#AWS.S3.REGION}'
                value: '{$AWS.S3.LLD.FILTER.REGION.MATCHES}'
                formulaid: C
              - macro: '{#AWS.S3.REGION}'
                value: '{$AWS.S3.LLD.FILTER.REGION.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Get S3 bucket instances.'
          host_prototypes:
            - uuid: e45bd9810ea14718b17b875aad3fc544
              host: '{#AWS.S3.NAME}'
              name: '{#AWS.S3.NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#AWS.S3.REGION}'
              templates:
                - name: 'AWS S3 bucket by HTTP'
              macros:
                - macro: '{$AWS.REGION}'
                  value: '{#AWS.S3.REGION}'
                  description: 'Amazon S3 region code.'
                - macro: '{$AWS.S3.BUCKET.NAME}'
                  value: '{#AWS.S3.NAME}'
                  description: 'S3 bucket name.'
                - macro: '{$AWS.S3.FILTER.ID}'
                  value: '1'
                  description: 'S3 bucket requests filter identifier.'
              tags:
                - tag: name
                  value: '{#AWS.S3.NAME}'
                - tag: region
                  value: '{#AWS.S3.REGION}'
                - tag: service
                  value: s3
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#AWS.S3.NAME}'
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region_match
              value: '{$AWS.S3.LLD.FILTER.REGION.MATCHES}'
            - name: region_not_match
              value: '{$AWS.S3.LLD.FILTER.REGION.NOT_MATCHES}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          lld_macro_paths:
            - lld_macro: '{#AWS.S3.NAME}'
              path: $.Name
            - lld_macro: '{#AWS.S3.REGION}'
              path: $.location
      tags:
        - tag: class
          value: software
        - tag: target
          value: aws
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: role_base
          description: 'Authorization method. Possible values: role_base, access_key.'
        - macro: '{$AWS.EC2.LLD.FILTER.NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable EC2 instances by namespace.'
        - macro: '{$AWS.EC2.LLD.FILTER.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered EC2 instances by namespace.'
        - macro: '{$AWS.EC2.LLD.FILTER.REGION.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable EC2 instances by region.'
        - macro: '{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered EC2 instances by region.'
        - macro: '{$AWS.ECS.LLD.FILTER.NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable ECS clusters by name.'
        - macro: '{$AWS.ECS.LLD.FILTER.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered ECS clusters by name.'
        - macro: '{$AWS.ECS.LLD.FILTER.REGION.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable ECS clusters by region.'
        - macro: '{$AWS.ECS.LLD.FILTER.REGION.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered ECS clusters by region.'
        - macro: '{$AWS.ECS.LLD.FILTER.STATUS.MATCHES}'
          value: ACTIVE
          description: 'Filter of discoverable ECS clusters by status.'
        - macro: '{$AWS.ECS.LLD.FILTER.STATUS.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered ECS clusters by status.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets HTTP proxy value. If this macro is empty then no proxy is used.'
        - macro: '{$AWS.RDS.LLD.FILTER.NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable RDS instances by namespace.'
        - macro: '{$AWS.RDS.LLD.FILTER.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered RDS instances by namespace.'
        - macro: '{$AWS.RDS.LLD.FILTER.REGION.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable RDS instances by region.'
        - macro: '{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered RDS instances by region.'
        - macro: '{$AWS.S3.LLD.FILTER.NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable S3 buckets by namespace.'
        - macro: '{$AWS.S3.LLD.FILTER.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered S3 buckets by namespace.'
        - macro: '{$AWS.S3.LLD.FILTER.REGION.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable S3 buckets by region.'
        - macro: '{$AWS.S3.LLD.FILTER.REGION.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered S3 buckets by region.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          type: SECRET_TEXT
          description: 'Secret access key.'
