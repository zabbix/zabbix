zabbix_export:
  version: '8.0'
  template_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Templates/Applications
  host_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Applications
  templates:
    - uuid: 07695028a2ba4b66a5414797bec791df
      template: 'Kubernetes cluster state by HTTP'
      name: 'Kubernetes cluster state by HTTP'
      description: |
        Get Kubernetes state metrics by HTTP.
        Metrics are collected by requests to Kubernetes API.
        
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      wizard_ready: 'YES'
      readme: |
        ## Overview
        
        The template to monitor Kubernetes state.
        It works without external scripts and uses the script item to make HTTP requests to the Kubernetes API.
        
        Template `Kubernetes cluster state by HTTP` - collects metrics by HTTP agent from kube-state-metrics endpoint and Kubernetes API.
        
        **Note:** Some metrics may not be collected depending on your Kubernetes version and configuration.
        
        ## Setup
        
        Install the [Zabbix Helm Chart](https://git.zabbix.com/projects/ZT/repos/kubernetes-helm/browse?at=refs%2Fheads%2Fmaster) in your Kubernetes cluster.
        Internal service metrics are collected from kube-state-metrics endpoint.
        
        Template needs to use authorization via API token.
        
        Set the `Kubernetes API URL` such as `<scheme>://<host>:<port>`.
        
        Get the generated service account token using the command:
        
        `kubectl get secret zabbix-zabbix-helm-chart -n monitoring -o jsonpath={.data.token} | base64 -d`
        
        Then set it to the field: `API Authorization Token`.
        Set `State Endpoint Name` with Kube state metrics endpoint name. See `kubectl -n monitoring get ep`. Default: `zabbix-kube-state-metrics`.
        
        **Note:** If you wish to monitor Controller Manager and Scheduler components, you might need to set the `--binding-address` option for them to the address where Zabbix proxy can reach them.
        For example, for clusters created with `kubeadm` it can be set in the following manifest files (changes will be applied immediately):
        
        - /etc/kubernetes/manifests/kube-controller-manager.yaml
        - /etc/kubernetes/manifests/kube-scheduler.yaml
        
        Depending on your Kubernetes distribution, you might need to adjust `Control Plane Taint` field (for example, set it to `node-role.kubernetes.io/master` for OpenShift).
        
        **Note:** Some metrics may not be collected depending on your Kubernetes version and configuration.
        
        Set up the fields to filter the metrics of discovered Kubelets by node names:
        
        - `Kubelet Node Matches Filter`
        - `Kubelet Node Exclude Filter`
        
        Set up fields to filter metrics by namespace:
        
        - `Namespace Matches Filter`
        - `Namespace Exclude Filter`
        
        Set up fields to filter node metrics by nodename:
        
        - `Node Matches Filter`
        - `Node Exclude Filter`
        
        **Note:** If you have a large cluster, it is highly recommended to set a filter for discoverable namespaces.
        
        You can use the `Kubelet Labels Filter` and `Kubelet Annotations Filter` fields for advanced filtering of kubelets by node labels and annotations.
        
        Notes about labels and annotations filters:
        
        - Values should be specified separated by commas and must have the key/value form with support for regular expressions in the value (`key1: value, key2: regexp`).
        - ECMAScript syntax is used for regular expressions.
        - Filters are applied if such label key exists for the entity that is being filtered (it means that if you specify a key in the filter, entities that do not have this key will not be affected by the filter and will still be discovered, and only entities containing that key will be filtered by the value).
        - You can also use the exclamation point symbol (`!`) to invert the filter (`!key: value`).
        
        For example: `kubernetes.io/hostname: kubernetes-node[5-25], !node-role.kubernetes.io/ingress: .*`. As a result, the kubelets on nodes 5-25 without the "ingress" role will be discovered.
        
        
        See the Kubernetes documentation for details about labels and annotations:
        
        - <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
        - <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/>
        
        You can also set up evaluation periods for replica mismatch triggers (Deployments, ReplicaSets, StatefulSets) with the field `Replica Mismatch Evaluation Period`, which supports context and regular expressions.
      vendor:
        name: Zabbix
        version: 8.0-3
      groups:
        - name: Templates/Applications
      items:
        - uuid: 41c79d9286734cc3b0e3aa5ef729e5fe
          name: 'Get component statuses'
          type: HTTP_AGENT
          key: kube.componentstatuses
          history: '0'
          value_type: TEXT
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - '-1'
          timeout: 10s
          url: '{$KUBE.API.URL}{$KUBE.API.COMPONENTSTATUSES.ENDPOINT}'
          status_codes: '200, 403'
          headers:
            - name: Authorization
              value: 'Bearer {$KUBE.API.TOKEN}'
          tags:
            - tag: component
              value: raw
        - uuid: e40b126a0cf64ce6bfed3b3de1d4dfa8
          name: 'Control plane LLD'
          type: SCRIPT
          key: kube.control_plane.lld
          history: '0'
          value_type: TEXT
          params: |
            var Kube = {
            	params: {},
            
            	setParams: function (params) {
            		['api_token', 'api_url', 'api_server_scheme', 'api_server_port', 'controller_scheme', 'controller_port',
            			'scheduler_scheme', 'scheduler_port', 'control_plane_taint'].forEach(function (field) {
            				if (typeof params !== 'object' || typeof params[field] === 'undefined'
            					|| params[field] === '') {
            					throw 'Required param is not set: "' + field + '".';
            				}
            			});
            
            		Kube.params = params;
            		if (typeof Kube.params.api_url === 'string' && !Kube.params.api_url.endsWith('/')) {
            			Kube.params.api_url += '/';
            		}
            	},
            
            	apiRequest: function (query) {
            		var request = new HttpRequest(),
            			response,
            			url = encodeURI(Kube.params.api_url + query);
            		if (typeof Kube.params.http_proxy !== 'undefined' && Kube.params.http_proxy !== '') {
            			request.setProxy(Kube.params.http_proxy);
            		}
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Authorization: Bearer ' + Kube.params.api_token);
            
            		Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);
            
            		if (Kube.params.http_proxy) {
            			Zabbix.log(4, '[ Kubernetes ] Using http proxy: ' + Kube.params.http_proxy);
            		}
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() < 200 || request.getStatus() >= 300) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		try {
            			response = JSON.parse(response);
            		}
            		catch (error) {
            			throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            		}
            		return response;
            	},
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	getNodes: function () {
            		var result = Kube.apiRequest('api/v1/nodes?labelSelector=' + Kube.params.control_plane_taint);
            
            		if (typeof result !== 'object'
            			|| typeof result.items === 'undefined') {
            			throw 'Cannot get control plane nodes from Kubernetes API. Check debug log for more information.';
            		};
            
            		var nodes = result.items,
            			IPv4 = /(?:\d{1,3}\.){3}\d{1,3}/,
            			controlPlaneNodes = [],
            			hostname = Kube.params.api_url.match(/https?:\/\/([\w.-]+|\[[a-f0-9:]+\]|[^a-zA-Z:]+)(?::\d+)?/);
            
            		if (typeof hostname[1] === 'undefined') {
            			Zabbix.log(4, '[ Kubernetes ] Received incorrect Kubernetes API url: ' + api_url + '. Expected format: <scheme>://<host>:<port>');
            			throw 'Cannot get hostname from Kubernetes API url. Check debug log for more information.';
            		};
            
            		controlPlaneNodes = nodes.map(function (node) {
            			var internalIPs = Kube.getField(node, 'status.addresses').filter(function (addr) {
            				return addr.type === 'InternalIP';
            			});
            			var internalIP = internalIPs.length && internalIPs[0].address;
            
            			return {
            				'{#NAME}': Kube.getField(node, 'metadata.name'),
            				'{#IP}': internalIP,
            				'{#KUBE.API.SERVER.URL}': Kube.params.api_server_scheme + '://' + (IPv4.test(internalIP) ? internalIP : '[' + internalIP + ']') + ':' + Kube.params.api_server_port + '/metrics',
            				'{#KUBE.CONTROLLER.SERVER.URL}': Kube.params.controller_scheme + '://' + (IPv4.test(internalIP) ? internalIP : '[' + internalIP + ']') + ':' + Kube.params.controller_port + '/metrics',
            				'{#KUBE.SCHEDULER.SERVER.URL}': Kube.params.scheduler_scheme + '://' + (IPv4.test(internalIP) ? internalIP : '[' + internalIP + ']') + ':' + Kube.params.scheduler_port + '/metrics',
            				'{#COMPONENT.API}': 'API',
            				'{#COMPONENT.CONTROLLER}': 'Controller manager',
            				'{#COMPONENT.SCHEDULER}': 'Scheduler',
            				'{#CLUSTER_HOSTNAME}': hostname[1]
            			};
            		});
            
            		return JSON.stringify(controlPlaneNodes);
            	}
            };
            
            try {
            	Kube.setParams(JSON.parse(value));
            	return Kube.getNodes();
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
            	return JSON.stringify({ error: error });
            }
          description: 'Generation of data for Control plane discovery rules.'
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          timeout: 10s
          parameters:
            - name: api_server_port
              value: '{$KUBE.API_SERVER.PORT}'
            - name: api_server_scheme
              value: '{$KUBE.API_SERVER.SCHEME}'
            - name: api_token
              value: '{$KUBE.API.TOKEN}'
            - name: api_url
              value: '{$KUBE.API.URL}'
            - name: controller_port
              value: '{$KUBE.CONTROLLER_MANAGER.PORT}'
            - name: controller_scheme
              value: '{$KUBE.CONTROLLER_MANAGER.SCHEME}'
            - name: control_plane_taint
              value: '{$KUBE.CONTROL_PLANE.TAINT}'
            - name: http_proxy
              value: '{$KUBE.HTTP.PROXY}'
            - name: scheduler_port
              value: '{$KUBE.SCHEDULER.PORT}'
            - name: scheduler_scheme
              value: '{$KUBE.SCHEDULER.SCHEME}'
          tags:
            - tag: component
              value: raw
        - uuid: 6f22e81d69d04eeca88a7992463556a7
          name: 'CronJob count'
          type: DEPENDENT
          key: kube.cronjob.count
          description: 'Number of cronjobs.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_cronjob_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: cronjob
        - uuid: 483fc2c315264ae5963d34a45f80156e
          name: 'Deployment count'
          type: DEPENDENT
          key: kube.deployment.count
          description: 'The number of deployments.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_deployment_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: deployment
        - uuid: 93126582e30e45b8a70f6e45402e2f54
          name: 'Endpoint count'
          type: DEPENDENT
          key: kube.endpoint.count
          description: 'Number of endpoints.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_endpoint_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: endpoint
        - uuid: c08df3a8ae044ae9a331db33bcca7db3
          name: 'Job count'
          type: DEPENDENT
          key: kube.job.count
          description: 'Number of jobs (generated by cronjob + job).'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_job_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: job
        - uuid: d731fb05f0284921ab3548ba631f019c
          name: 'Get livez'
          type: HTTP_AGENT
          key: kube.livez
          history: '0'
          value_type: TEXT
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var output = [],
                  	component;
                  
                  value.split(/\n/).forEach(function (entry) {
                  	if (component = entry.match(/^\[.+\](.+)\s(\w+)$/)) {
                  		output.push({
                  			name: component[1],
                  			value: component[2]
                  		});
                  	}
                  });
                  
                  return JSON.stringify(output);
          timeout: 10s
          url: '{$KUBE.API.URL}{$KUBE.API.LIVEZ.ENDPOINT}?verbose'
          status_codes: '200, 403'
          headers:
            - name: Authorization
              value: 'Bearer {$KUBE.API.TOKEN}'
          tags:
            - tag: component
              value: raw
        - uuid: d266edd6dda34e15888b572569a1f301
          name: 'Namespace count'
          type: DEPENDENT
          key: kube.namespace.count
          description: 'The number of namespaces.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_namespace_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: namespace
        - uuid: 968e1dcaf76645aebd4979b9ad4eca9e
          name: 'Node count'
          type: DEPENDENT
          key: kube.node.count
          description: 'The number of nodes.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_node_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: node
        - uuid: aae78585c668466da5d0ab8d8b899828
          name: 'Node LLD'
          type: SCRIPT
          key: kube.node.lld
          history: '0'
          value_type: TEXT
          params: |
            var Kube = {
            	params: {},
            
            	setParams: function (params) {
            		['api_url', 'api_token', 'kubelet_scheme', 'kubelet_port'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined'
            				|| params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            		});
            		['node_filter_labels', 'node_filter_annotations'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined') {
            				throw 'Parameter can be empty but not removed: "' + field + '".';
            			}
            		});
            
            		Kube.params = params;
            		if (typeof Kube.params.api_url === 'string' && !Kube.params.api_url.endsWith('/')) {
            			Kube.params.api_url += '/';
            		}
            
            	},
            
            	apiRequest: function (query) {
            		var request = new HttpRequest(),
            			response,
            			url = encodeURI(Kube.params.api_url + query);
            
            		if (typeof Kube.params.http_proxy !== 'undefined' && Kube.params.http_proxy !== '') {
            			request.setProxy(Kube.params.http_proxy);
            		}
            
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Authorization: Bearer ' + Kube.params.api_token);
            
            		Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);
            
            		if (Kube.params.http_proxy) {
            			Zabbix.log(4, '[ Kubernetes ] Using http proxy: ' + Kube.params.http_proxy);
            		}
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() < 200 || request.getStatus() >= 300) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            
            		}
            		try {
            			response = JSON.parse(response);
            		}
            		catch (error) {
            			throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            		}
            		return response;
            
            	},
            
            	parseFilters: function (csv) {
            		if (!csv)
            			return [];
            
            		var filters = [];
            		const filterCapture = /([!\w\-\.\/]+)\s*:\s*(.*)/;
            		const onComma = /\s*,\s*/;
            
            		csv.split(onComma).forEach(function (kv) {
            			var match = kv.match(filterCapture);
            			if (!match) {
            				Zabbix.log(3, 'Cannot parse filter from: "' + kv + '"');
            				return;
            			}
            
            			filters.push({ key: match[1], expression: match[2] });
            		});
            
            		return filters;
            	},
            
            	filter: function (name, data, filters) {
            		if (typeof data !== 'object') {
            			return true;
            		}
            
            		return filters.every(function (filter) {
            			const filter_key = filter.key.startsWith('!') ? filter.key.substring(1) : filter.key;
            
            			if (!(filter_key in data)) {
            				return true;
            			}
            
            			const isExcludingFilter = filter.key.startsWith('!');
            			const isMatchForFilter = new RegExp(filter.expression).test(data[filter_key]);
            
            			if ((isExcludingFilter && isMatchForFilter) ||
            				(!isExcludingFilter && !isMatchForFilter)) {
            				Zabbix.log(4, '[ Kubernetes ] Discarded "' + name + '" by filter "' + filter.key + ': ' + filter.expression + '"');
            				return false;
            			}
            
            			return true;
            		});
            	},
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	getNodes: function () {
            		var result = Kube.apiRequest('api/v1/nodes');
            		if (typeof result !== 'object'
            			|| typeof result.items === 'undefined') {
            			throw 'Cannot get nodes from Kubernetes API. Check debug log for more information.';
            		};
            		var nodes = result.items,
            			IPv4 = /(?:\d{1,3}\.){3}\d{1,3}/,
            			kubeNodes = [],
            			hostname = Kube.params.api_url.match(/https?:\/\/([\w.-]+|\[[a-f0-9:]+\]|[^a-zA-Z:]+)(?::\d+)?/),
            			filterNodeLabels = Kube.parseFilters(Kube.params.node_filter_labels),
            			filterNodeAnnotations = Kube.parseFilters(Kube.params.node_filter_annotations);
            
            		if (typeof hostname[1] === 'undefined') {
            			Zabbix.log(4, '[ Kubernetes ] Received incorrect Kubernetes API url: ' + api_url + '. Expected format: <scheme>://<host>:<port>');
            			throw 'Cannot get hostname from Kubernetes API url. Check debug log for more information.';
            		};
            
            		kubeNodes = nodes.map(function (node) {
            			if (Kube.filter(Kube.getField(node, 'metadata.name'), Kube.getField(node, 'metadata.labels'), filterNodeLabels)
            				&& Kube.filter(Kube.getField(node, 'metadata.name'), Kube.getField(node, 'metadata.annotations'), filterNodeAnnotations)) {
            				Zabbix.log(4, '[ Kubernetes ] Filtered node "' + node.metadata.name + '"');
            
            				var internalIPs = Kube.getField(node, 'status.addresses').filter(function (addr) {
            					return addr.type === 'InternalIP';
            				});
            
            				var internalIP = internalIPs.length && internalIPs[0].address;
            
            				return {
            					'{#NAME}': node.metadata.name,
            					'{#IP}': internalIP,
            					'{#KUBE.KUBELET.URL}': Kube.params.kubelet_scheme + '://' + (IPv4.test(internalIP) ? internalIP : '[' + internalIP + ']') + ':' + Kube.params.kubelet_port,
            					'{#COMPONENT}': 'Kubelet',
            					'{#CLUSTER_HOSTNAME}': hostname[1]
            				};
            			}
            		});
            
            		return JSON.stringify(kubeNodes);
            
            	},
            };
            
            try {
            	Kube.setParams(JSON.parse(value));
            	return Kube.getNodes();
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
            	return JSON.stringify({ error: error });
            }
          description: 'Generation of data for Kubelet discovery rules.'
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          timeout: 10s
          parameters:
            - name: api_token
              value: '{$KUBE.API.TOKEN}'
            - name: api_url
              value: '{$KUBE.API.URL}'
            - name: http_proxy
              value: '{$KUBE.HTTP.PROXY}'
            - name: kubelet_port
              value: '{$KUBE.KUBELET.PORT}'
            - name: kubelet_scheme
              value: '{$KUBE.KUBELET.SCHEME}'
            - name: node_filter_annotations
              value: '{$KUBE.KUBELET.FILTER.ANNOTATIONS}'
            - name: node_filter_labels
              value: '{$KUBE.KUBELET.FILTER.LABELS}'
          tags:
            - tag: component
              value: raw
        - uuid: 3a5eaef4e8134dfb9f2935f98a8b88f7
          name: 'Get readyz'
          type: HTTP_AGENT
          key: kube.readyz
          history: '0'
          value_type: TEXT
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var output = [],
                  	component;
                  
                  value.split(/\n/).forEach(function (entry) {
                  	if (component = entry.match(/^\[.+\](.+)\s(\w+)$/)) {
                  		output.push({
                  			name: component[1],
                  			value: component[2]
                  		});
                  	}
                  });
                  
                  return JSON.stringify(output);
          timeout: 10s
          url: '{$KUBE.API.URL}{$KUBE.API.READYZ.ENDPOINT}?verbose'
          status_codes: '200, 403'
          headers:
            - name: Authorization
              value: 'Bearer {$KUBE.API.TOKEN}'
          tags:
            - tag: component
              value: raw
        - uuid: 262b0114fed14fec91d50589e97307a7
          name: 'Service count'
          type: DEPENDENT
          key: kube.service.count
          description: 'The number of services.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_service_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: service
        - uuid: 66e69f9970ce478f8f0ff13f26b248e3
          name: 'Get state metrics'
          type: SCRIPT
          key: kube.state.metrics
          history: '0'
          value_type: TEXT
          params: |
            var Kube = {
            	params: {},
            
            	setParams: function (params) {
            		['api_url', 'api_token', 'state_endpoint_name'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined'
            				|| params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            		});
            
            		Kube.params = params;
            		if (typeof Kube.params.api_url === 'string' && !Kube.params.api_url.endsWith('/')) {
            			Kube.params.api_url += '/';
            		}
            	},
            
            	apiRequest: function (query) {
            		var request = new HttpRequest(),
            			response,
            			url = encodeURI(Kube.params.api_url + query);
            
            		if (typeof Kube.params.http_proxy !== 'undefined' && Kube.params.http_proxy !== '') {
            			request.setProxy(Kube.params.http_proxy);
            		}
            
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Authorization: Bearer ' + Kube.params.api_token);
            
            		Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);
            
            		if (Kube.params.http_proxy) {
            			Zabbix.log(4, '[ Kubernetes ] Using http proxy: ' + Kube.params.http_proxy);
            		}
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() < 200 || request.getStatus() >= 300) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            		try {
            			response = JSON.parse(response);
            		}
            		catch (error) {
            			throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            		}
            		return response;
            	},
            
            	getEndpoint: function (ep) {
            		if (typeof ep.subsets[0].addresses !== 'undefined') {
            			var scheme,
            				addr,
            				port;
            			ep.subsets.forEach(function (subset) {
            				var lp = subset.ports.filter(function (port) {
            					if (port.name !== 'http' &&
            						port.name !== 'https' &&
            						port.name !== 'https-main') {
            						return false;
            					}
            					scheme = port.name.match(/https?/);
            					return true;
            				})
            				if (lp.length) {
            					port = lp[0].port
            					addr = subset.addresses[0].ip
            				}
            			})
            			return {
            				scheme: scheme || 'http',
            				address: addr || ep.subsets[0].addresses[0].ip,
            				port: port || 8080
            			}
            		}
            	},
            
            	getMetricsEndpoint: function () {
            		var result = Kube.apiRequest('api/v1/endpoints'),
            			endpoint = [];
            
            		if (typeof result !== 'object'
            			|| typeof result.items === 'undefined') {
            			throw 'Cannot get endpoints from Kubernetes API. Check debug log for more information.';
            		};
            
            		result.items.forEach(function (ep) {
            			if (ep.metadata.name === Kube.params.state_endpoint_name && Array.isArray(ep.subsets)) {
            				endpoint.push(Kube.getEndpoint(ep));
            			}
            			if (typeof Kube.params.openshift_endpoint_name !== 'undefined' && Kube.params.openshift_endpoint_name !== ''
            				&& ep.metadata.name === Kube.params.openshift_endpoint_name && Array.isArray(ep.subsets)) {
            				endpoint.push(Kube.getEndpoint(ep));
            			}
            		});
            		if (endpoint.length === 0) {
            			throw 'Cannot get state metrics endpoints from Kubernetes API. Check debug log for more information.';
            		}
            		return endpoint;
            	},
            
            	getStateMetrics: function () {
            		var metrics_endpoint = Kube.getMetricsEndpoint(),
            			IPv4 = /(?:\d{1,3}\.){3}\d{1,3}/,
            			result = '',
            			request = new HttpRequest();
            
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Authorization: Bearer ' + Kube.params.api_token);
            
            		if (typeof Kube.params.http_proxy !== 'undefined' && Kube.params.http_proxy !== '') {
            			request.setProxy(Kube.params.http_proxy);
            			Zabbix.log(4, '[ Kubernetes ] Using http proxy: ' + Kube.params.http_proxy);
            		}
            
            		metrics_endpoint.forEach(function (endpoint) {
            			var url = endpoint.scheme + '://' + (IPv4.test(endpoint.address) ? endpoint.address : '[' + endpoint.address + ']') + ':' + endpoint.port + '/metrics';
            
            			Zabbix.log(4, '[ Kubernetes ] Sending request: ' + url);
            			response = request.get(url);
            			Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            			if (request.getStatus() < 200 || request.getStatus() >= 300) {
            				throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            			}
            			if (response === null) {
            				throw 'Failed to get state metrics. Check debug log for more information.';
            			}
            			result += response + '\n';
            		}
            		);
            
            		return result;
            
            	}
            };
            
            try {
            	Kube.setParams(JSON.parse(value));
            
            	var stateMetrics = Kube.getStateMetrics();
            
            	return stateMetrics;
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
            	return JSON.stringify({ error: error });
            }
          description: 'Collecting Kubernetes metrics from kube-state-metrics.'
          timeout: 10s
          parameters:
            - name: api_token
              value: '{$KUBE.API.TOKEN}'
            - name: api_url
              value: '{$KUBE.API.URL}'
            - name: http_proxy
              value: '{$KUBE.HTTP.PROXY}'
            - name: openshift_endpoint_name
              value: '{$OPENSHIFT.STATE.ENDPOINT.NAME}'
            - name: state_endpoint_name
              value: '{$KUBE.STATE.ENDPOINT.NAME}'
          tags:
            - tag: component
              value: raw
        - uuid: 3940412bea334e139a72b223197582eb
          name: 'StatefulSet count'
          type: DEPENDENT
          key: kube.statefulset.count
          description: 'The number of statefulsets.'
          preprocessing:
            - type: PROMETHEUS_PATTERN
              parameters:
                - kube_statefulset_created
                - function
                - count
              error_handler: DISCARD_VALUE
          master_item:
            key: kube.state.metrics
          tags:
            - tag: component
              value: statefulset
      discovery_rules:
        - uuid: dbfd8959361f4cdd973ed552eb18eb86
          name: 'API servers discovery'
          type: DEPENDENT
          key: kube.api_servers.discovery
          host_prototypes:
            - uuid: a67ac5100e6d499088e4c81856f947fc
              host: 'API {#NAME}'
              name: 'API {#NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.API}'
              templates:
                - name: 'Kubernetes API server by HTTP'
              macros:
                - macro: '{$KUBE.API.SERVER.URL}'
                  value: '{#KUBE.API.SERVER.URL}'
              tags:
                - tag: addr
                  value: '{#IP}'
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#IP}'
          master_item:
            key: kube.control_plane.lld
        - uuid: 920b56d5e9234da6b60717763e206736
          name: 'Component statuses discovery'
          type: DEPENDENT
          key: kube.componentstatuses.discovery
          item_prototypes:
            - uuid: 766e311f05f646d18eaaaa9ea9afa691
              name: 'Component [{#NAME}]: Healthy'
              type: DEPENDENT
              key: 'kube.componentstatuses.healthy[{#NAME}]'
              value_type: CHAR
              description: 'Cluster component healthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.items.[?(@.metadata.name == "{#NAME}")].conditions[?(@.type == "Healthy")].status.first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.componentstatuses
              tags:
                - tag: component
                  value: component
                - tag: component
                  value: '{#NAME}'
                - tag: status
                  value: healthy
              trigger_prototypes:
                - uuid: 58828a692aa2418ba98c6d66a23f1506
                  expression: 'count(/Kubernetes cluster state by HTTP/kube.componentstatuses.healthy[{#NAME}],#2,"ne","True")=2 and length(last(/Kubernetes cluster state by HTTP/kube.componentstatuses.healthy[{#NAME}]))>0'
                  recovery_mode: RECOVERY_EXPRESSION
                  recovery_expression: 'count(/Kubernetes cluster state by HTTP/kube.componentstatuses.healthy[{#NAME}],#3,"eq","True")=3'
                  name: 'Kubernetes cluster state: Component [{#NAME}] is unhealthy'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.componentstatuses
          lld_macro_paths:
            - lld_macro: '{#NAME}'
              path: $.metadata.name
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.items
              error_handler: DISCARD_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 08463c66bce845e7acff0d91785e0982
          name: 'Controller manager nodes discovery'
          type: DEPENDENT
          key: kube.controller_manager.discovery
          host_prototypes:
            - uuid: 9d529f3924fc4831a62fb1eec79b64d7
              host: 'Controller manager {#NAME}'
              name: 'Controller manager {#NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.CONTROLLER}'
              templates:
                - name: 'Kubernetes Controller manager by HTTP'
              macros:
                - macro: '{$KUBE.CONTROLLER.SERVER.URL}'
                  value: '{#KUBE.CONTROLLER.SERVER.URL}'
              tags:
                - tag: addr
                  value: '{#IP}'
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#IP}'
          master_item:
            key: kube.control_plane.lld
        - uuid: 9bb7532f14dd42c6a532636126e507f9
          name: 'CronJob discovery'
          type: DEPENDENT
          key: kube.cronjob.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: fd1afcc4646146588fd3c22cf2f7e040
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Completion failed'
              type: DEPENDENT
              key: 'kube.cronjob.completion.failed[{#NAMESPACE}/{#NAME}]'
              description: 'Number of jobs the execution of which has failed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_failed{namespace="{#NAMESPACE}", job_name=~"{#NAME}-*", condition="true"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 5ba1dfd55c784f8597575b38399d5e36
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Completion succeeded'
              type: DEPENDENT
              key: 'kube.cronjob.completion.succeeded[{#NAMESPACE}/{#NAME}]'
              description: 'Number of jobs the execution of which has been completed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_complete{namespace="{#NAMESPACE}", job_name=~"{#NAME}-*", condition="true"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 7ae683d5a1ed4f84a09b38863bd263a7
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Last schedule'
              type: DEPENDENT
              key: 'kube.cronjob.last_schedule_time[{#NAMESPACE}/{#NAME}]'
              units: unixtime
              description: 'LastScheduleTime keeps information of when was the last time the job was successfully scheduled.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_cronjob_status_last_schedule_time{namespace="{#NAMESPACE}", cronjob="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 8ad7e96b34604a4991698288a7af8027
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Next schedule'
              type: DEPENDENT
              key: 'kube.cronjob.next_schedule_time[{#NAMESPACE}/{#NAME}]'
              units: unixtime
              description: 'Next time the cronjob should be scheduled. The time after lastScheduleTime or after the cron job''s creation time if it''s never been scheduled. Use this to determine if the job is delayed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_cronjob_next_schedule_time{namespace="{#NAMESPACE}", cronjob="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 329e8166d1ec42cca7508580efaad366
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Suspend'
              type: DEPENDENT
              key: 'kube.cronjob.spec_suspend[{#NAMESPACE}/{#NAME}]'
              description: 'Suspend flag tells the controller to suspend subsequent executions.'
              valuemap:
                name: 'Boolean format'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_cronjob_spec_suspend{namespace="{#NAMESPACE}", cronjob="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 1h
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: ce13a921915a4232971f2e29102cac64
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Active'
              type: DEPENDENT
              key: 'kube.cronjob.status_active[{#NAMESPACE}/{#NAME}]'
              description: 'Active holds pointers to currently running jobs.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_cronjob_status_active{namespace="{#NAMESPACE}", cronjob="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 26993138717242079583b1c17d0e8dc8
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Failed'
              type: DEPENDENT
              key: 'kube.cronjob.status_failed[{#NAMESPACE}/{#NAME}]'
              description: 'The number of pods which reached the Failed phase and the reason for failure.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_status_failed{namespace="{#NAMESPACE}", job_name=~"{#NAME}-*"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 9e5adc642c3a40ab80654542903cd314
              name: 'Namespace [{#NAMESPACE}] CronJob [{#NAME}]: Succeeded'
              type: DEPENDENT
              key: 'kube.cronjob.status_succeeded[{#NAMESPACE}/{#NAME}]'
              description: 'The number of pods which reached the Succeeded phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_status_succeeded{namespace="{#NAMESPACE}", job_name=~"{#NAME}-*"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cronjob
                - tag: cronjob
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.cronjob
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_cronjob_created
        - uuid: 907dd8e2792e4e1591a99e4cdf65b0f0
          name: 'Daemonset discovery'
          type: DEPENDENT
          key: kube.daemonset.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 61a295b5e2ec4e1f91984a74d0695c1b
              name: 'Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Desired'
              type: DEPENDENT
              key: 'kube.daemonset.desired[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of nodes that should be running the daemon pod.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_daemonset_status_desired_number_scheduled{namespace="{#NAMESPACE}", daemonset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: daemonset
                - tag: daemonset
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 5393cb9b29e442198967cdd2a040d673
              name: 'Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Misscheduled'
              type: DEPENDENT
              key: 'kube.daemonset.misscheduled[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of nodes that run a daemon pod but are not supposed to.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_daemonset_status_number_misscheduled{namespace="{#NAMESPACE}", daemonset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: daemonset
                - tag: daemonset
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 193ccc0290514c4594193a8bcfd60312
              name: 'Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Ready'
              type: DEPENDENT
              key: 'kube.daemonset.ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of nodes that should be running the daemon pod and have one or more running and ready.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_daemonset_status_number_ready{namespace="{#NAMESPACE}", daemonset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: daemonset
                - tag: daemonset
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 5727ade78d394d8da1ae46b5d35b5f54
              name: 'Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Scheduled'
              type: DEPENDENT
              key: 'kube.daemonset.scheduled[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of nodes that run at least one daemon pod and are supposed to.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_daemonset_status_current_number_scheduled{namespace="{#NAMESPACE}", daemonset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: daemonset
                - tag: daemonset
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: d7c1ebe9e42942719dae731a2c440208
              name: 'Namespace [{#NAMESPACE}] Daemonset [{#NAME}]: Updated number scheduled'
              type: DEPENDENT
              key: 'kube.daemonset.updated[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The total number of nodes that are running updated daemon pod.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_daemonset_status_updated_number_scheduled{namespace="{#NAMESPACE}", daemonset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: daemonset
                - tag: daemonset
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.daemonset
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_daemonset_status_number_ready
        - uuid: 461770e4762f498e86f3f1c931fe27a9
          name: 'Deployment discovery'
          type: DEPENDENT
          key: kube.deployment.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 943c67dc814e4b06a57fbc4ef609686a
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas'
              type: DEPENDENT
              key: 'kube.deployment.replicas[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of replicas per deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_status_replicas{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 23d730bdea7f444eb5f2ee8bf5987379
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas available'
              type: DEPENDENT
              key: 'kube.deployment.replicas_available[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of available replicas per deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_status_replicas_available{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: status
                  value: available
            - uuid: b79fe110f4d64a94bb78d7f1e9b175e7
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas desired'
              type: DEPENDENT
              key: 'kube.deployment.replicas_desired[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of desired pods for a deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_spec_replicas{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: b6d4d557e6104f6b9e1084863cf4024d
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas mismatched'
              type: DEPENDENT
              key: 'kube.deployment.replicas_mismatched[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of available replicas not matching the desired number of replicas.'
              preprocessing:
                - type: PROMETHEUS_TO_JSON
                  parameters:
                    - '{__name__=~"^kube_deployment_(spec_replicas|status_replicas_available)$", namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var data = JSON.parse(value),
                      	replicas_desired,
                      	replicas_available;
                      
                      if (data.length !== 2) {
                      	throw 'Incorrect length of JSON (must be 2). Actual length: ' + data.length;
                      }
                      
                      JSON.parse(value).forEach(function (item) {
                      	if (item.name === 'kube_deployment_spec_replicas') {
                      		replicas_desired = item.value;
                      	}
                      	if (item.name === 'kube_deployment_status_replicas_available') {
                      		replicas_available = item.value;
                      	}
                      });
                      
                      return Math.abs(replicas_desired - replicas_available);
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 891537523f98425c8bb1566f984b535a
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas unavailable'
              type: DEPENDENT
              key: 'kube.deployment.replicas_unavailable[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of unavailable replicas per deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_status_replicas_unavailable{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: status
                  value: unavailable
            - uuid: 241480bc5e90426abbf5d2792cd846cd
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Replicas updated'
              type: DEPENDENT
              key: 'kube.deployment.replicas_updated[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of updated replicas per deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_status_replicas_updated{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: status
                  value: updated
            - uuid: 2651b21facca4bd88929079f4372da37
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Rollingupdate max unavailable'
              type: DEPENDENT
              key: 'kube.deployment.rollingupdate.max_unavailable[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Maximum number of unavailable replicas during a rolling update of a deployment.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_spec_strategy_rollingupdate_max_unavailable{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: edc5635267b146d2b0a986e5820227ac
              name: 'Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Paused'
              type: DEPENDENT
              key: 'kube.deployment.spec_paused[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Whether the deployment is paused and will not be processed by the deployment controller.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_deployment_spec_paused{namespace="{#NAMESPACE}", deployment="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: deployment
                - tag: deployment
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
          trigger_prototypes:
            - uuid: aa9f828467d84252aecc00dd342b5661
              expression: |
                min(/Kubernetes cluster state by HTTP/kube.deployment.replicas_mismatched[{#NAMESPACE}/{#NAME}],{$KUBE.REPLICA.MISMATCH.EVAL_PERIOD:"deployment:{#NAMESPACE}:{#NAME}"})>0
                and last(/Kubernetes cluster state by HTTP/kube.deployment.replicas_desired[{#NAMESPACE}/{#NAME}])>=0
                and last(/Kubernetes cluster state by HTTP/kube.deployment.replicas_available[{#NAMESPACE}/{#NAME}])>=0
              name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] Deployment [{#NAME}]: Deployment replicas mismatch'
              opdata: 'Desired: {ITEM.LASTVALUE2}, available: {ITEM.LASTVALUE3}'
              priority: WARNING
              description: 'Deployment has not matched the expected number of replicas during the specified trigger evaluation period.'
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.deployment
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_deployment_spec_paused
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 671a0dd7f6e54c6893094fa4360d3dd4
          name: 'Endpoint discovery'
          type: DEPENDENT
          key: kube.endpoint.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: d587eb7186dd425ead2c9554825ba20a
              name: 'Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Address available'
              type: DEPENDENT
              key: 'kube.endpoint.address_available[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of addresses available in endpoint.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_endpoint_address_available{namespace="{#NAMESPACE}", endpoint="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: endpoint
                - tag: endpoint
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: status
                  value: available
            - uuid: 91fc21c37e144890858137f7f5c38135
              name: 'Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Address not ready'
              type: DEPENDENT
              key: 'kube.endpoint.address_not_ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of addresses not ready in endpoint.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_endpoint_address_not_ready{namespace="{#NAMESPACE}", endpoint="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: endpoint
                - tag: endpoint
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: status
                  value: not-ready
            - uuid: f6c2a426e0154c34b2bcb98eeeb88a0d
              name: 'Namespace [{#NAMESPACE}] Endpoint [{#NAME}]: Age'
              type: DEPENDENT
              key: 'kube.endpoint.age[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              units: s
              description: 'Endpoint age (number of seconds since creation).'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_endpoint_created{namespace="{#NAMESPACE}", endpoint="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return (Math.floor(Date.now()/1000)-Number(value));'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: endpoint
                - tag: endpoint
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.endpoint
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_endpoint_created
        - uuid: bc6897c5abe246fdb1ba72c1e71cdb81
          name: 'Job discovery'
          type: DEPENDENT
          key: kube.job.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: b1fad48e204e4bf9a03c79baa0f58963
              name: 'Namespace [{#NAMESPACE}] Job [{#NAME}]: Completion failed'
              type: DEPENDENT
              key: 'kube.job.completion.failed[{#NAMESPACE}/{#NAME}]'
              description: 'Number of jobs the execution of which has failed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_failed{namespace="{#NAMESPACE}", job_name="{#NAME}", condition="true"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: job
                - tag: job
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 51d3653b2c7543dba04339ded6ff65dd
              name: 'Namespace [{#NAMESPACE}] Job [{#NAME}]: Completion succeeded'
              type: DEPENDENT
              key: 'kube.job.completion.succeeded[{#NAMESPACE}/{#NAME}]'
              description: 'Number of jobs the execution of which has been completed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_complete{namespace="{#NAMESPACE}", job_name="{#NAME}", condition="true"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: job
                - tag: job
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: f175e0bd1f6b41a2b62e69df40b3fc07
              name: 'Namespace [{#NAMESPACE}] Job [{#NAME}]: Failed'
              type: DEPENDENT
              key: 'kube.job.status_failed[{#NAMESPACE}/{#NAME}]'
              description: 'The number of pods which reached the Failed phase and the reason for failure.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_status_failed{namespace="{#NAMESPACE}", job_name="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: job
                - tag: job
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: b909868367d5481d982d33d5248167ab
              name: 'Namespace [{#NAMESPACE}] Job [{#NAME}]: Succeeded'
              type: DEPENDENT
              key: 'kube.job.status_succeeded[{#NAMESPACE}/{#NAME}]'
              description: 'The number of pods which reached the Succeeded phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_job_status_succeeded{namespace="{#NAMESPACE}", job_name="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: job
                - tag: job
                  value: '{#NAME}'
                - tag: namespace
                  value: '{#NAMESPACE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.job_name
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - 'kube_job_owner{owner_is_controller!="true"}'
        - uuid: 11ca82627209443a96693e443d6391c1
          name: 'Kubelet discovery'
          type: DEPENDENT
          key: kube.kubelet.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.KUBELET_NODE.MATCHES}'
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.KUBELET_NODE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          host_prototypes:
            - uuid: c1c4807f378a47dfa59e9bbc8e43f5e2
              host: 'Kubelet {#NAME}'
              name: 'Kubelet {#NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT}'
              templates:
                - name: 'Kubernetes Kubelet by HTTP'
              macros:
                - macro: '{$KUBE.KUBELET.URL}'
                  value: '{#KUBE.KUBELET.URL}'
              tags:
                - tag: addr
                  value: '{#IP}'
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#IP}'
          master_item:
            key: kube.node.lld
        - uuid: 438e963e02a749b5a2cc487b9fd5db05
          name: 'Livez discovery'
          type: DEPENDENT
          key: kube.livez.discovery
          item_prototypes:
            - uuid: 93548d985c1542a891bfc74f2d42d59a
              name: 'Livez [{#NAME}]: Healthcheck'
              type: DEPENDENT
              key: 'kube.livez.healthcheck[{#NAME}]'
              value_type: CHAR
              description: 'Result of livez healthcheck for component.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.name == "{#NAME}")].value.first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.livez
              tags:
                - tag: component
                  value: livez
                - tag: component
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 9fcb23d29ac3481a8613515cc2cccfcf
                  expression: 'count(/Kubernetes cluster state by HTTP/kube.livez.healthcheck[{#NAME}],#2,"ne","ok")=2 and length(last(/Kubernetes cluster state by HTTP/kube.livez.healthcheck[{#NAME}]))>0'
                  recovery_mode: RECOVERY_EXPRESSION
                  recovery_expression: 'count(/Kubernetes cluster state by HTTP/kube.livez.healthcheck[{#NAME}],#3,"eq","ok")=3'
                  name: 'Kubernetes cluster state: Livez [{#NAME}] is unhealthy'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.livez
          lld_macro_paths:
            - lld_macro: '{#NAME}'
              path: $.name
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 9d161120d2be48d1abb6e56107057874
          name: 'Node discovery'
          type: DEPENDENT
          key: kube.node.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.NODE.MATCHES}'
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: 4f994219cbe94dfe8d96af1ad5018212
              name: 'Node [{#NAME}]: CPU allocatable'
              type: DEPENDENT
              key: 'kube.node.cpu_allocatable[{#NAME}]'
              value_type: FLOAT
              units: cpu
              description: 'The CPU resources of a node that are available for scheduling.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_allocatable{node="{#NAME}", resource="cpu"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cpu
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: allocatable
            - uuid: 5d3ad3e1b2a547aea65b557ff2765ef7
              name: 'Node [{#NAME}]: CPU capacity'
              type: DEPENDENT
              key: 'kube.node.cpu_capacity[{#NAME}]'
              value_type: FLOAT
              units: cpu
              description: 'The capacity for CPU resources of a node.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_capacity{node="{#NAME}", resource="cpu"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: cpu
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: capacity
            - uuid: 49440553854441f39ecbcf7052d83e51
              name: 'Node [{#NAME}]: Ephemeral storage allocatable'
              type: DEPENDENT
              key: 'kube.node.ephemeral_storage_allocatable[{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The allocatable ephemeral storage of a node that is available for scheduling.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_allocatable{node="{#NAME}", resource="ephemeral_storage"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: ephemeral-storage
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: capacity
            - uuid: 2831a4b1bc1549198203f3e894f07a1f
              name: 'Node [{#NAME}]: Ephemeral storage capacity'
              type: DEPENDENT
              key: 'kube.node.ephemeral_storage_capacity[{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The ephemeral storage capacity of a node.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_capacity{node="{#NAME}", resource="ephemeral_storage"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: ephemeral-storage
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: capacity
            - uuid: 0247f7ba014443a0b13a4fdd3e191062
              name: 'Node [{#NAME}]: Memory allocatable'
              type: DEPENDENT
              key: 'kube.node.memory_allocatable[{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The memory resources of a node that are available for scheduling.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_allocatable{node="{#NAME}", resource="memory"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: memory
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: allocatable
            - uuid: 3336028952b14e2ab3dae55659156ea3
              name: 'Node [{#NAME}]: Memory capacity'
              type: DEPENDENT
              key: 'kube.node.memory_capacity[{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The capacity for memory resources of a node.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_capacity{node="{#NAME}", resource="memory"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: memory
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: capacity
            - uuid: 049eb92c52a24c9887d7120f2a7e106c
              name: 'Node [{#NAME}]: Pods allocatable'
              type: DEPENDENT
              key: 'kube.node.pods_allocatable[{#NAME}]'
              value_type: FLOAT
              description: 'The pods resources of a node that are available for scheduling.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_allocatable{node="{#NAME}", resource="pods"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pods
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: allocatable
            - uuid: 163edc95ec7d41f29099b94409916d82
              name: 'Node [{#NAME}]: Pods capacity'
              type: DEPENDENT
              key: 'kube.node.pods_capacity[{#NAME}]'
              value_type: FLOAT
              description: 'The capacity for pods resources of a node.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_node_status_capacity{node="{#NAME}", resource="pods"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pods
                - tag: node
                  value: '{#NAME}'
                - tag: status
                  value: capacity
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAME}'
              path: $.labels.node
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_node_info
        - uuid: a7bf79185bab4eb8891e5a154424a96d
          name: 'PodDisruptionBudget discovery'
          type: DEPENDENT
          key: kube.pdb.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 3eef1fb3311e429fa3043c9e4d88335f
              name: 'Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Disruptions allowed'
              type: DEPENDENT
              key: 'kube.pdb.disruptions_allowed[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of pod disruptions that are allowed.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_poddisruptionbudget_status_pod_disruptions_allowed{namespace="{#NAMESPACE}", poddisruptionbudget="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pdb
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pdb
                  value: '{#NAME}'
            - uuid: a303e07be68c40bdb7d996696af53c98
              name: 'Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods desired'
              type: DEPENDENT
              key: 'kube.pdb.pods_desired[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Minimum desired number of healthy pods.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_poddisruptionbudget_status_desired_healthy{namespace="{#NAMESPACE}", poddisruptionbudget="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pdb
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pdb
                  value: '{#NAME}'
            - uuid: f2a82d6de52446f594a6554137508604
              name: 'Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods healthy'
              type: DEPENDENT
              key: 'kube.pdb.pods_healthy[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Current number of healthy pods.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_poddisruptionbudget_status_current_healthy{namespace="{#NAMESPACE}", poddisruptionbudget="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pdb
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pdb
                  value: '{#NAME}'
            - uuid: 2c15033188ab4062a432f30c3320677f
              name: 'Namespace [{#NAMESPACE}] PodDisruptionBudget [{#NAME}]: Pods total'
              type: DEPENDENT
              key: 'kube.pdb.pods_total[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Total number of pods counted by this disruption budget.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_poddisruptionbudget_status_expected_pods{namespace="{#NAMESPACE}", poddisruptionbudget="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pdb
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pdb
                  value: '{#NAME}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.poddisruptionbudget
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_poddisruptionbudget_created
        - uuid: d88889ab64804c4389d3755ea49b80d6
          name: 'Pod discovery'
          type: DEPENDENT
          key: kube.pod.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 3a145b38d57f4164a7a9ef0dd15c530a
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers CPU limits'
              type: DEPENDENT
              key: 'kube.pod.containers.limits.cpu[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The limit on CPU cores to be used by a container.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_resource_limits{namespace="{#NAMESPACE}", pod="{#NAME}", resource="cpu"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: resource
                  value: cpu
            - uuid: e1dd38e6fb484610891aef057a58daf0
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers memory limits'
              type: DEPENDENT
              key: 'kube.pod.containers.limits.memory[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The limit on memory to be used by a container.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_resource_limits{namespace="{#NAMESPACE}", pod="{#NAME}", resource="memory"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: resource
                  value: memory
            - uuid: 8465ea15f3974476924cb66df5a63e0c
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers CPU requests'
              type: DEPENDENT
              key: 'kube.pod.containers.requests.cpu[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of requested CPU cores by a container.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_resource_requests{namespace="{#NAMESPACE}", pod="{#NAME}", resource="cpu"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: resource
                  value: cpu
            - uuid: 27379c192d0841a5adb2c2e4ae937263
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers memory requests'
              type: DEPENDENT
              key: 'kube.pod.containers.requests.memory[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The number of requested memory bytes by a container.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_resource_requests{namespace="{#NAMESPACE}", pod="{#NAME}", resource="memory"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: resource
                  value: memory
            - uuid: 1719bf9d1a1c443dbddcefb91483a77c
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers ready'
              type: DEPENDENT
              key: 'kube.pod.containers_ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes whether the containers readiness check succeeded.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_status_ready{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: ready
            - uuid: fbc8f3a91ec9429ca4c6d70c07480dcc
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers restarts'
              type: DEPENDENT
              key: 'kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of container restarts.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_status_restarts_total{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: restarts
              trigger_prototypes:
                - uuid: 4656457043d04f4a9b829222ad071d22
                  expression: '(last(/Kubernetes cluster state by HTTP/kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}])-min(/Kubernetes cluster state by HTTP/kube.pod.containers_restarts[{#NAMESPACE}/{#NAME}],15m))>1'
                  name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Pod is crash looping'
                  priority: WARNING
                  description: 'Containers of the pod keep restarting. This most likely indicates that the pod is in the CrashLoopBackOff state.'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: b96149f7a44d4a49903421fbc38c0101
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers running'
              type: DEPENDENT
              key: 'kube.pod.containers_running[{#NAMESPACE}/{#NAME}]'
              description: 'Describes whether the container is currently in running state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_status_running{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: running
            - uuid: 50785c1c96894866973ebf8491e3c320
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers terminated'
              type: DEPENDENT
              key: 'kube.pod.containers_terminated[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes whether the container is currently in terminated state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_status_terminated{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: terminated
            - uuid: 01d80d5f171f4af2b3b1da70679e87ba
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Containers waiting'
              type: DEPENDENT
              key: 'kube.pod.containers_waiting[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes whether the container is currently in waiting state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_container_status_waiting{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: waiting
            - uuid: dedbaa4308624b6b982a7e6b62f92d3f
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Failed'
              type: DEPENDENT
              key: 'kube.pod.phase.failed[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Pod is in failed state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_phase{namespace="{#NAMESPACE}", pod="{#NAME}", phase="Failed"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: failed
                - tag: pod
                  value: '{#NAME}'
            - uuid: fa3759bb7873453b9842f3e459403163
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Pending'
              type: DEPENDENT
              key: 'kube.pod.phase.pending[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Pod is in pending state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_phase{namespace="{#NAMESPACE}", pod="{#NAME}", phase="Pending"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: pending
                - tag: pod
                  value: '{#NAME}'
            - uuid: 59168479f1e246bf8da46606f3ce2a5e
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Running'
              type: DEPENDENT
              key: 'kube.pod.phase.running[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Pod is in unknown state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_phase{namespace="{#NAMESPACE}", pod="{#NAME}", phase="Running"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: running
                - tag: pod
                  value: '{#NAME}'
            - uuid: 8a9451a6466f4c64b31377d850841578
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Succeeded'
              type: DEPENDENT
              key: 'kube.pod.phase.succeeded[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Pod is in succeeded state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_phase{namespace="{#NAMESPACE}", pod="{#NAME}", phase="Succeeded"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: succeeded
                - tag: pod
                  value: '{#NAME}'
            - uuid: 9303dab482754a7b991b3ba4afef96e7
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}] Phase: Unknown'
              type: DEPENDENT
              key: 'kube.pod.phase.unknown[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Pod is in unknown state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_phase{namespace="{#NAMESPACE}", pod="{#NAME}", phase="Unknown"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: unknown
                - tag: pod
                  value: '{#NAME}'
            - uuid: d946bc58d5a44aa9936b09c825a51f59
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Ready'
              type: DEPENDENT
              key: 'kube.pod.ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes whether the pod is ready to serve requests.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_ready{namespace="{#NAMESPACE}", pod="{#NAME}", condition="true"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: ready
            - uuid: 0f858209a4b344de80b1382710c6f153
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Scheduled'
              type: DEPENDENT
              key: 'kube.pod.scheduled[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes the status of the scheduling process for the pod.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_scheduled{namespace="{#NAMESPACE}", pod="{#NAME}", condition="true"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: scheduled
            - uuid: 93ba93d04ec34b5193252f19a33f5d59
              name: 'Namespace [{#NAMESPACE}] Pod [{#NAME}]: Unschedulable'
              type: DEPENDENT
              key: 'kube.pod.unschedulable[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Describes the unschedulable status for the pod.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_pod_status_unschedulable{namespace="{#NAMESPACE}", pod="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pod
                  value: '{#NAME}'
                - tag: status
                  value: unschedulable
          trigger_prototypes:
            - uuid: 5bf79dee7b974064b5848a7dcf6428c2
              expression: 'min(/Kubernetes cluster state by HTTP/kube.pod.phase.failed[{#NAMESPACE}/{#NAME}],10m)>0 or min(/Kubernetes cluster state by HTTP/kube.pod.phase.pending[{#NAMESPACE}/{#NAME}],10m)>0 or min(/Kubernetes cluster state by HTTP/kube.pod.phase.unknown[{#NAMESPACE}/{#NAME}],10m)>0'
              name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] Pod [{#NAME}]: Pod is not healthy'
              priority: HIGH
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.pod
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_pod_start_time
        - uuid: 657edb22832e43f5a084cf872c6bc6e4
          name: 'PV discovery'
          type: DEPENDENT
          key: kube.pv.discovery
          lifetime: '0'
          item_prototypes:
            - uuid: f93e620a32114a239bc622246ff57eb0
              name: 'PV [{#NAME}] Capacity bytes'
              type: DEPENDENT
              key: 'kube.pv.capacity.bytes[{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'A capacity of the persistent volume in bytes.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_capacity_bytes{persistentvolume="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pv
                - tag: pv
                  value: '{#NAME}'
            - uuid: f1f7c15a30e04203b63b3f828f1e49c6
              name: 'PV status phase: Available, sum'
              type: DEPENDENT
              key: 'kube.pv.status_phase.available.sum[{#SINGLETON}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volumes in the Available phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}", phase="Available"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: phase
                  value: available
            - uuid: 236db4d5cb4149f691003c0b50bf2b55
              name: 'PV status phase: Bound, sum'
              type: DEPENDENT
              key: 'kube.pv.status_phase.bound.sum[{#SINGLETON}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volumes in the Bound phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}", phase="Bound"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: phase
                  value: bound
            - uuid: bc5e42637e454baeb38eef946093f38a
              name: 'PV status phase: Failed, sum'
              type: DEPENDENT
              key: 'kube.pv.status_phase.failed.sum[{#SINGLETON}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volumes in the Failed phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}", phase="Failed"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: phase
                  value: failed
            - uuid: e69e327a90094195997a28e36fe47441
              name: 'PV status phase: Pending, sum'
              type: DEPENDENT
              key: 'kube.pv.status_phase.pending.sum[{#SINGLETON}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volumes in the Pending phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}", phase="Pending"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: phase
                  value: pending
            - uuid: 121d33d774534d38809b014f0af20d72
              name: 'PV status phase: Released, sum'
              type: DEPENDENT
              key: 'kube.pv.status_phase.released.sum[{#SINGLETON}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volumes in the Released phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}", phase="Released"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: phase
                  value: released
            - uuid: f2982e1a1c4a46f08b855d6f35e60c85
              name: 'PV [{#NAME}] Status phase'
              type: DEPENDENT
              key: 'kube.pv.status_phase[{#NAME}]'
              description: 'The current status phase of the persistent volume.'
              valuemap:
                name: 'PV and PVC status phases'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolume_status_phase{persistentvolume="{#NAME}"} == 1'
                    - label
                    - phase
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''Available'', ''Bound'', ''Failed'', ''Lost'', ''Pending'', ''Released''].indexOf(value) + 1 || ''Problem with status processing in JS, no such PV status: '' + value;'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pv
                - tag: pv
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: ccc486f937bd454e9e7193181a998bdb
                  expression: 'count(/Kubernetes cluster state by HTTP/kube.pv.status_phase[{#NAME}],2m,,3)>=2'
                  name: 'Kubernetes cluster state: PV [{#NAME}]: PV has failed'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.state.metrics
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - 'kube_persistentvolume_info{persistentvolume=~"{$KUBE.LLD.FILTER.PV.MATCHES}", persistentvolume!~"{$KUBE.LLD.FILTER.PV.NOT_MATCHES}"}'
            - type: JAVASCRIPT
              parameters:
                - |
                  var input = JSON.parse(value),
                  	output = [];
                  
                  input.forEach(function (metric) {
                  	output.push({ '{#NAME}': metric.labels.persistentvolume });
                  });
                  
                  if (output.length > 0) {
                  	output.push({ '{#SINGLETON}': '' });
                  }
                  
                  return JSON.stringify(output);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          overrides:
            - name: 'sum items'
              step: '1'
              filter:
                conditions:
                  - macro: '{#SINGLETON}'
                    operator: EXISTS
              operations:
                - operator: REGEXP
                  value: 'status phase.*sum'
                  discover: DISCOVER
                - operator: NOT_REGEXP
                  value: 'status phase.*sum'
                  discover: NO_DISCOVER
                - operationobject: TRIGGER_PROTOTYPE
                  operator: REGEXP
                  value: '.*'
                  discover: NO_DISCOVER
        - uuid: 4143b2f294ac45a5ab570a94a626fca6
          name: 'PVC discovery'
          type: DEPENDENT
          key: kube.pvc.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 9187144531f145398bfbe7281290533d
              name: 'Namespace [{#NAMESPACE}] PVC [{#NAME}] Requested storage'
              type: DEPENDENT
              key: 'kube.pvc.requested.storage[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              units: B
              description: 'The capacity of storage requested by the persistent volume claim.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolumeclaim_resource_requests_storage_bytes{namespace="{#NAMESPACE}", persistentvolumeclaim="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: pvc
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pvc
                  value: '{#NAME}'
            - uuid: 41bc1f54992a492da414846b91d48b0e
              name: 'Namespace [{#NAMESPACE}] PVC status phase: Bound, sum'
              type: DEPENDENT
              key: 'kube.pvc.status_phase.bound.sum[{#NAMESPACE}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volume claims in the Bound phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolumeclaim_status_phase{namespace="{#NAMESPACE}", phase="Bound"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pvc
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: bound
            - uuid: f3b3979c04424b908b514589c2995ff8
              name: 'Namespace [{#NAMESPACE}] PVC status phase: Lost, sum'
              type: DEPENDENT
              key: 'kube.pvc.status_phase.lost.sum[{#NAMESPACE}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volume claims in the Lost phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolumeclaim_status_phase{namespace="{#NAMESPACE}", phase="Lost"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pvc
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: lost
            - uuid: 237d8ee073c04c21a14269f15ab679fd
              name: 'Namespace [{#NAMESPACE}] PVC status phase: Pending, sum'
              type: DEPENDENT
              key: 'kube.pvc.status_phase.pending.sum[{#NAMESPACE}]'
              discover: NO_DISCOVER
              description: 'The total amount of persistent volume claims in the Pending phase.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolumeclaim_status_phase{namespace="{#NAMESPACE}", phase="Pending"}'
                    - function
                    - sum
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pvc
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: phase
                  value: pending
            - uuid: f036e514626b4610b531f9be09289daa
              name: 'Namespace [{#NAMESPACE}] PVC [{#NAME}] Status phase'
              type: DEPENDENT
              key: 'kube.pvc.status_phase[{#NAMESPACE}/{#NAME}]'
              description: 'The current status phase of the persistent volume claim.'
              valuemap:
                name: 'PV and PVC status phases'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_persistentvolumeclaim_status_phase{namespace="{#NAMESPACE}", persistentvolumeclaim="{#NAME}"} == 1'
                    - label
                    - phase
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''Available'', ''Bound'', ''Failed'', ''Lost'', ''Pending'', ''Released''].indexOf(value) + 1 || ''Problem with status processing in JS, no such PVC status: '' + value;'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: phase
                - tag: component
                  value: pvc
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: pvc
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 6cdf93dad1c647239570cbb3789f1a2c
                  expression: 'count(/Kubernetes cluster state by HTTP/kube.pvc.status_phase[{#NAMESPACE}/{#NAME}],2m,,5)>=2'
                  name: 'Kubernetes cluster state: NS [{#NAMESPACE}] PVC [{#NAME}]: PVC is pending'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.state.metrics
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_persistentvolumeclaim_info
            - type: JAVASCRIPT
              parameters:
                - |
                  var input = JSON.parse(value),
                  	lookup = {},
                  	output = [];
                  
                  input.forEach(function (metric) {
                  	var namespace = metric.labels.namespace;
                  	if (!(lookup[namespace])) {
                  		lookup[namespace] = 1;
                  		output.push({
                  			'{#IS_SUM}': '',
                  			'{#NAMESPACE}': metric.labels.namespace
                  		});
                  	}
                  	output.push({
                  		'{#NAME}': metric.labels.persistentvolumeclaim,
                  		'{#NAMESPACE}': metric.labels.namespace
                  	});
                  });
                  
                  return JSON.stringify(output);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          overrides:
            - name: 'sum items'
              step: '1'
              filter:
                conditions:
                  - macro: '{#IS_SUM}'
                    operator: EXISTS
              operations:
                - operator: REGEXP
                  value: 'status phase.*sum'
                  discover: DISCOVER
                - operator: NOT_REGEXP
                  value: 'status phase.*sum'
                  discover: NO_DISCOVER
                - operationobject: TRIGGER_PROTOTYPE
                  operator: REGEXP
                  value: '.*'
                  discover: NO_DISCOVER
        - uuid: ee274767c42345e3a501f43e81a3364a
          name: 'Readyz discovery'
          type: DEPENDENT
          key: kube.readyz.discovery
          item_prototypes:
            - uuid: c0693fb2709e4b01a35ca433edb84db7
              name: 'Readyz [{#NAME}]: Healthcheck'
              type: DEPENDENT
              key: 'kube.readyz.healthcheck[{#NAME}]'
              value_type: CHAR
              description: 'Result of readyz healthcheck for component.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.name == "{#NAME}")].value.first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.readyz
              tags:
                - tag: component
                  value: readyz
                - tag: component
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 1a88c2cf94d3444c9e5320776b323ce6
                  expression: 'count(/Kubernetes cluster state by HTTP/kube.readyz.healthcheck[{#NAME}],#2,"ne","ok")=2 and length(last(/Kubernetes cluster state by HTTP/kube.readyz.healthcheck[{#NAME}]))>0'
                  recovery_mode: RECOVERY_EXPRESSION
                  recovery_expression: 'count(/Kubernetes cluster state by HTTP/kube.readyz.healthcheck[{#NAME}],#3,"eq","ok")=3'
                  name: 'Kubernetes cluster state: Readyz [{#NAME}] is unhealthy'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.readyz
          lld_macro_paths:
            - lld_macro: '{#NAME}'
              path: $.name
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 6244f250f6cd411080221843ad1c59f2
          name: 'ReplicaSet discovery'
          type: DEPENDENT
          key: kube.replicaset.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 928536dae27c4e3497627b9f5642a7a8
              name: 'Namespace [{#NAMESPACE}] ReplicaSet [{#NAME}]: Fully labeled replicas'
              type: DEPENDENT
              key: 'kube.replicaset.fully_labeled_replicas[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of fully labeled replicas per ReplicaSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_replicaset_status_fully_labeled_replicas{namespace="{#NAMESPACE}", replicaset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: replicaset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: replicaset
                  value: '{#NAME}'
                - tag: status
                  value: fully-labeled
            - uuid: 4e911e4b71c342dba2227ed7ef360190
              name: 'Namespace [{#NAMESPACE}] ReplicaSet [{#NAME}]: Ready'
              type: DEPENDENT
              key: 'kube.replicaset.ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of ready replicas per ReplicaSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_replicaset_status_ready_replicas{namespace="{#NAMESPACE}", replicaset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: replicaset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: replicaset
                  value: '{#NAME}'
                - tag: status
                  value: ready
            - uuid: 545c8486dcc9409c93c6efee0f4b2ad6
              name: 'Namespace [{#NAMESPACE}] ReplicaSet [{#NAME}]: Replicas'
              type: DEPENDENT
              key: 'kube.replicaset.replicas[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of replicas per ReplicaSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_replicaset_status_replicas{namespace="{#NAMESPACE}", replicaset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: replicaset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: replicaset
                  value: '{#NAME}'
            - uuid: 30aea656c8a5470ea4566333077628b3
              name: 'Namespace [{#NAMESPACE}] ReplicaSet [{#NAME}]: Desired replicas'
              type: DEPENDENT
              key: 'kube.replicaset.replicas_desired[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of desired pods for a ReplicaSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_replicaset_spec_replicas{namespace="{#NAMESPACE}", replicaset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: replicaset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: replicaset
                  value: '{#NAME}'
                - tag: status
                  value: desired
            - uuid: a249a4762874499eb83eb8864df5c357
              name: 'Namespace [{#NAMESPACE}] ReplicaSet [{#NAME}]: Replicas mismatched'
              type: DEPENDENT
              key: 'kube.replicaset.replicas_mismatched[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of ready replicas not matching the desired number of replicas.'
              preprocessing:
                - type: PROMETHEUS_TO_JSON
                  parameters:
                    - '{__name__=~"^kube_replicaset_(spec_replicas|status_ready_replicas)$", namespace="{#NAMESPACE}", replicaset="{#NAME}"}'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var data = JSON.parse(value),
                      	replicas_desired,
                      	replicas_ready;
                      
                      if (data.length !== 2) {
                      	throw 'Incorrect length of JSON (must be 2). Actual length: ' + data.length;
                      }
                      
                      JSON.parse(value).forEach(function (item) {
                      	if (item.name === 'kube_replicaset_spec_replicas') {
                      		replicas_desired = item.value;
                      	}
                      	if (item.name === 'kube_replicaset_status_ready_replicas') {
                      		replicas_ready = item.value;
                      	}
                      });
                      
                      return Math.abs(replicas_desired - replicas_ready);
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: replicaset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: replicaset
                  value: '{#NAME}'
          trigger_prototypes:
            - uuid: 8046757dbd3b459c9cd9f7bd369dd416
              expression: |
                min(/Kubernetes cluster state by HTTP/kube.replicaset.replicas_mismatched[{#NAMESPACE}/{#NAME}],{$KUBE.REPLICA.MISMATCH.EVAL_PERIOD:"replicaset:{#NAMESPACE}:{#NAME}"})>0
                and last(/Kubernetes cluster state by HTTP/kube.replicaset.replicas_desired[{#NAMESPACE}/{#NAME}])>=0
                and last(/Kubernetes cluster state by HTTP/kube.replicaset.ready[{#NAMESPACE}/{#NAME}])>=0
              name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] RS [{#NAME}]: ReplicaSet mismatch'
              opdata: 'Desired: {ITEM.LASTVALUE2}, ready: {ITEM.LASTVALUE3}'
              priority: WARNING
              description: 'ReplicaSet has not matched the expected number of replicas during the specified trigger evaluation period.'
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.replicaset
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_replicaset_status_replicas
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: f732cbb0e71e4ab896c973e355d7a6a4
          name: 'Scheduler servers nodes discovery'
          type: DEPENDENT
          key: kube.scheduler.discovery
          host_prototypes:
            - uuid: 46da4b85c58f4c59825e61778a64a58e
              host: 'Scheduler {#NAME}'
              name: 'Scheduler {#NAME}'
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#CLUSTER_HOSTNAME}: Kubernetes/Components: {#COMPONENT.SCHEDULER}'
              templates:
                - name: 'Kubernetes Scheduler by HTTP'
              macros:
                - macro: '{$KUBE.SCHEDULER.SERVER.URL}'
                  value: '{#KUBE.SCHEDULER.SERVER.URL}'
              tags:
                - tag: addr
                  value: '{#IP}'
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#IP}'
          master_item:
            key: kube.control_plane.lld
        - uuid: 37812660877243e9bdbc0ffc7815578c
          name: 'StatefulSet discovery'
          type: DEPENDENT
          key: kube.statefulset.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 9cc34425228f44868f3cd46450d557ca
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Replicas'
              type: DEPENDENT
              key: 'kube.statefulset.replicas[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of replicas per StatefulSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_statefulset_status_replicas{namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
            - uuid: 33e5a534b35f40c6ad7fef53212ef970
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Current replicas'
              type: DEPENDENT
              key: 'kube.statefulset.replicas_current[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of current replicas per StatefulSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_statefulset_status_replicas_current{namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
            - uuid: 3fee3afc8b924b13ae24ab4b5e793acf
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Desired replicas'
              type: DEPENDENT
              key: 'kube.statefulset.replicas_desired[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'Number of desired pods for a StatefulSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_statefulset_replicas{namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
                - tag: status
                  value: ready
            - uuid: e2c3e03fe9bd42beab8a5d09c0a766bd
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Replicas mismatched'
              type: DEPENDENT
              key: 'kube.statefulset.replicas_mismatched[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of ready replicas not matching the number of replicas.'
              preprocessing:
                - type: PROMETHEUS_TO_JSON
                  parameters:
                    - '{__name__=~"^kube_statefulset_(status_replicas|status_replicas_ready)$", namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var data = JSON.parse(value),
                      	replicas,
                      	replicas_ready;
                      
                      if (data.length !== 2) {
                      	throw 'Incorrect length of JSON (must be 2). Actual length: ' + data.length;
                      }
                      
                      JSON.parse(value).forEach(function (item) {
                      	if (item.name === 'kube_statefulset_status_replicas') {
                      		replicas = item.value;
                      	}
                      	if (item.name === 'kube_statefulset_status_replicas_ready') {
                      		replicas_ready = item.value;
                      	}
                      });
                      
                      return Math.abs(replicas - replicas_ready);
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
            - uuid: b35c1cebd902484998f383585ce29b76
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Ready replicas'
              type: DEPENDENT
              key: 'kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of ready replicas per StatefulSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_statefulset_status_replicas_ready{namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
                - tag: status
                  value: ready
            - uuid: b00b1cfed30e4b90b9754d543e72d7aa
              name: 'Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: Updated replicas'
              type: DEPENDENT
              key: 'kube.statefulset.replicas_updated[{#NAMESPACE}/{#NAME}]'
              value_type: FLOAT
              description: 'The number of updated replicas per StatefulSet.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'kube_statefulset_status_replicas_updated{namespace="{#NAMESPACE}", statefulset="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: statefulset
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: statefulset
                  value: '{#NAME}'
                - tag: status
                  value: updated
          trigger_prototypes:
            - uuid: c29a27fe5a0345c8af9e0d4e99b22dcb
              expression: '(last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}]) / last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_current[{#NAMESPACE}/{#NAME}]))<>1'
              name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: StatefulSet is down'
              priority: HIGH
              tags:
                - tag: scope
                  value: availability
            - uuid: 469d6933f5494ca48a212cdc364058e0
              expression: |
                min(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_mismatched[{#NAMESPACE}/{#NAME}],{$KUBE.REPLICA.MISMATCH.EVAL_PERIOD:"statefulset:{#NAMESPACE}:{#NAME}"})>0
                and last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas[{#NAMESPACE}/{#NAME}])>=0
                and last(/Kubernetes cluster state by HTTP/kube.statefulset.replicas_ready[{#NAMESPACE}/{#NAME}])>=0
              name: 'Kubernetes cluster state: Namespace [{#NAMESPACE}] StatefulSet [{#NAME}]: StatefulSet replicas mismatch'
              opdata: 'Replicas: {ITEM.LASTVALUE2}, ready: {ITEM.LASTVALUE3}'
              priority: WARNING
              description: 'StatefulSet has not matched the number of replicas during the specified trigger evaluation period.'
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.statefulset
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - kube_statefulset_status_replicas
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 428c4419ac8b4c91995a2aa7332b1943
          name: 'OpenShift Build discovery'
          type: DEPENDENT
          key: openshift.build.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 4d1013542dcb45b3ae59fd276b0df3e0
              name: 'Namespace [{#NAMESPACE}] Build [{#NAME}]: Created'
              type: DEPENDENT
              key: 'openshift.build.created.time[{#NAMESPACE}/{#NAME}]'
              units: unixtime
              description: 'OpenShift Build Unix creation timestamp.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_build_created{namespace="{#NAMESPACE}", build="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1'
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: kube.state.metrics
              tags:
                - tag: build
                  value: '{#NAME}'
                - tag: component
                  value: build
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 97ebce9edb774e25943ed22416caaa0b
              name: 'Namespace [{#NAMESPACE}] Build [{#NAME}]: Generation'
              type: DEPENDENT
              key: 'openshift.build.sequence.number[{#NAMESPACE}/{#NAME}]'
              description: 'Sequence number representing a specific generation of the desired state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_build_metadata_generation{namespace="{#NAMESPACE}", build="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: build
                  value: '{#NAME}'
                - tag: component
                  value: build
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 9a8bdd353a5a499c8c66468c1325ae16
              name: 'Namespace [{#NAMESPACE}] Build [{#NAME}]: Status phase'
              type: DEPENDENT
              key: 'openshift.build.status_phase[{#NAMESPACE}/{#NAME}]'
              description: 'The Build phase.'
              valuemap:
                name: 'Build status phases'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_build_status_phase{build="{#NAME}"} == 1'
                    - label
                    - build_phase
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''complete'', ''cancelled'', ''new'', ''pending'', ''running'', ''failed'', ''error''].indexOf(value) + 1 || ''Problem with status processing in JS, no such build status: '' + value;'
              master_item:
                key: kube.state.metrics
              tags:
                - tag: build
                  value: '{#NAME}'
                - tag: component
                  value: build
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
              trigger_prototypes:
                - uuid: b3364370ae954d69b7fad1ac3afd238b
                  expression: 'count(/Kubernetes cluster state by HTTP/openshift.build.status_phase[{#NAMESPACE}/{#NAME}],2m,"ge",6)>=2'
                  name: 'Kubernetes cluster state: Build [{#NAME}]: Build has failed'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.build
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - openshift_build_created
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 974679d1b2bc4d7294baeca07bd19e07
          name: 'OpenShift BuildConfig discovery'
          type: DEPENDENT
          key: openshift.buildconfig.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: 09d0c8ed4d604d898f212419ccdf8324
              name: 'Namespace [{#NAMESPACE}] BuildConfig [{#NAME}]: Created'
              type: DEPENDENT
              key: 'openshift.buildconfig.created.time[{#NAMESPACE}/{#NAME}]'
              units: unixtime
              description: 'OpenShift BuildConfig Unix creation timestamp.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_buildconfig_created{namespace="{#NAMESPACE}", buildconfig="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1'
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: kube.state.metrics
              tags:
                - tag: buildconfig
                  value: '{#NAME}'
                - tag: component
                  value: buildconfig
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: 2e90ec2497eb4eb3bf41b68282f07e6d
              name: 'Namespace [{#NAMESPACE}] BuildConfig [{#NAME}]: Generation'
              type: DEPENDENT
              key: 'openshift.buildconfig.generation[{#NAMESPACE}/{#NAME}]'
              description: 'Sequence number representing a specific generation of the desired state.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_buildconfig_metadata_generation{namespace="{#NAMESPACE}", buildconfig="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: buildconfig
                  value: '{#NAME}'
                - tag: component
                  value: buildconfig
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
            - uuid: e97bf96c39d1407cbc42013bcd3a5095
              name: 'Namespace [{#NAMESPACE}] BuildConfig [{#NAME}]: Latest version'
              type: DEPENDENT
              key: 'openshift.buildconfig.status[{#NAMESPACE}/{#NAME}]'
              description: 'The latest version of BuildConfig.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_buildconfig_status_latest_version{namespace="{#NAMESPACE}", buildconfig="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: kube.state.metrics
              tags:
                - tag: buildconfig
                  value: '{#NAME}'
                - tag: component
                  value: buildconfig
                - tag: component
                  value: openshift
                - tag: namespace
                  value: '{#NAMESPACE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.buildconfig
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - openshift_buildconfig_created
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: d7e21c75073548078e06159ff94680c9
          name: 'OpenShift ClusterResourceQuota discovery'
          type: DEPENDENT
          key: openshift.cluster.resource.quota.discovery
          lifetime: '0'
          item_prototypes:
            - uuid: 0b3826bad61c407ab4b9e103f0a3ae18
              name: 'Quota [{#NAME}] Resource [{#RESOURCE}]: Type [{#TYPE}]]'
              type: DEPENDENT
              key: 'openshift.cluster.resource.quota[{#RESOURCE}/{#NAME}/{#TYPE}]'
              description: 'Usage about resource quota.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_clusterresourcequota_usage{name="{#NAME}", resource="{#RESOURCE}", type="{#TYPE}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: openshift
                - tag: quota
                  value: '{#NAME}'
                - tag: resource
                  value: '{#RESOURCE}'
                - tag: type
                  value: '{#TYPE}'
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#NAME}'
              path: $.labels.name
            - lld_macro: '{#RESOURCE}'
              path: $.labels.resource
            - lld_macro: '{#TYPE}'
              path: $.labels.type
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - openshift_clusterresourcequota_usage
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 140a80726c60443ca5bb87b758924f7f
          name: 'OpenShift Route discovery'
          type: DEPENDENT
          key: openshift.route.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: a59550207a484b918193d4a57b08d97e
              name: 'Namespace [{#NAMESPACE}] Route [{#NAME}]: Created'
              type: DEPENDENT
              key: 'openshift.route.created.time[{#NAMESPACE}/{#NAME}]'
              units: unixtime
              description: 'OpenShift Route Unix creation timestamp.'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_route_created{namespace="{#NAMESPACE}", route="{#NAME}"}'
                    - value
                    - ''
                  error_handler: DISCARD_VALUE
                - type: MULTIPLIER
                  parameters:
                    - '1'
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: openshift
                - tag: component
                  value: route
                - tag: host
                  value: '{#HOST}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: route
                  value: '{#NAME}'
            - uuid: d55f9134b0fa4f3ea0eea93a682ab4f9
              name: 'Namespace [{#NAMESPACE}] Route [{#NAME}]: Status'
              type: DEPENDENT
              key: 'openshift.route.status[{#NAMESPACE}/{#NAME}]'
              description: 'Information about route status.'
              valuemap:
                name: 'Boolean format'
              preprocessing:
                - type: PROMETHEUS_PATTERN
                  parameters:
                    - 'openshift_route_status{route="{#NAME}"} == 1'
                    - label
                    - status
                  error_handler: DISCARD_VALUE
                - type: BOOL_TO_DECIMAL
              master_item:
                key: kube.state.metrics
              tags:
                - tag: component
                  value: openshift
                - tag: component
                  value: route
                - tag: host
                  value: '{#HOST}'
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: route
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 98a6d7ba3a4049d693f5471819ee4b2e
                  expression: 'count(/Kubernetes cluster state by HTTP/openshift.route.status[{#NAMESPACE}/{#NAME}],2m,,0)>=2'
                  name: 'Kubernetes cluster state: Route [{#NAME}] with issue: Status is false'
                  priority: WARNING
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: kube.state.metrics
          lld_macro_paths:
            - lld_macro: '{#HOST}'
              path: $.labels.host
            - lld_macro: '{#NAMESPACE}'
              path: $.labels.namespace
            - lld_macro: '{#NAME}'
              path: $.labels.route
          preprocessing:
            - type: PROMETHEUS_TO_JSON
              parameters:
                - openshift_route_info
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: subclass
          value: automation
        - tag: subclass
          value: containers
        - tag: subclass
          value: deploy
        - tag: subclass
          value: development
        - tag: subclass
          value: virtualization
        - tag: target
          value: cluster-state
        - tag: target
          value: kubernetes
      macros:
        - macro: '{$KUBE.API.COMPONENTSTATUSES.ENDPOINT}'
          value: /api/v1/componentstatuses
          description: 'Kubernetes API componentstatuses endpoint /api/v1/componentstatuses'
          config:
            type: TEXT
            priority: '4'
            label: 'Componentstatuses Endpoint'
            description: 'The Kubernetes API componentstatuses endpoint.'
        - macro: '{$KUBE.API.LIVEZ.ENDPOINT}'
          value: /livez
          description: 'Kubernetes API livez endpoint /livez'
          config:
            type: TEXT
            priority: '3'
            label: 'Livez Endpoint'
            description: 'The Kubernetes API livez endpoint.'
        - macro: '{$KUBE.API.READYZ.ENDPOINT}'
          value: /readyz
          description: 'Kubernetes API readyz endpoint /readyz'
          config:
            type: TEXT
            priority: '5'
            label: 'Readyz Endpoint'
            description: 'The Kubernetes API readyz endpoint.'
        - macro: '{$KUBE.API.TOKEN}'
          type: SECRET_TEXT
          description: 'Service account bearer token.'
          config:
            type: TEXT
            priority: '1'
            label: 'API Token'
            description: 'Service account bearer token for authentication.'
            required: 'YES'
        - macro: '{$KUBE.API.URL}'
          value: 'https://kubernetes.default.svc.cluster.local:443'
          description: 'Kubernetes API endpoint URL in the format <scheme>://<host>:<port>'
          config:
            type: TEXT
            priority: '2'
            label: 'Kubernetes API URL'
            description: 'The Kubernetes API endpoint URL.'
            required: 'YES'
        - macro: '{$KUBE.API_SERVER.PORT}'
          value: '6443'
          description: 'Kubernetes API servers metrics endpoint port. Used in ControlPlane LLD.'
          config:
            type: TEXT
            priority: '10'
            label: 'API Server Port'
            description: 'The port for the Kubernetes API server metrics endpoint. In the range from 1 to 65535 inclusive.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$KUBE.API_SERVER.SCHEME}'
          value: https
          description: 'Kubernetes API servers metrics endpoint scheme. Used in ControlPlane LLD.'
          config:
            type: LIST
            priority: '9'
            label: 'API Server Scheme'
            description: 'The scheme for the Kubernetes API server metrics endpoint.'
            options:
              - value: https
                text: HTTPS
              - value: http
                text: HTTP
        - macro: '{$KUBE.CONTROLLER_MANAGER.PORT}'
          value: '10257'
          description: 'Kubernetes Controller manager metrics endpoint port. Used in ControlPlane LLD.'
          config:
            type: TEXT
            priority: '13'
            label: 'Controller Manager Port'
            description: 'The port for the Kubernetes Controller Manager metrics endpoint. In the range from 1 to 65535 inclusive.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$KUBE.CONTROLLER_MANAGER.SCHEME}'
          value: https
          description: 'Kubernetes Controller manager metrics endpoint scheme. Used in ControlPlane LLD.'
          config:
            type: LIST
            priority: '12'
            label: 'Controller Manager Scheme'
            description: 'The scheme for the Kubernetes Controller Manager metrics endpoint.'
            options:
              - value: https
                text: HTTPS
              - value: http
                text: HTTP
        - macro: '{$KUBE.CONTROL_PLANE.TAINT}'
          value: node-role.kubernetes.io/control-plane
          description: 'Taint that applies to control plane nodes. Change if needed. Used in ControlPlane LLD.'
          config:
            type: TEXT
            priority: '11'
            label: 'Control Plane Taint'
            description: 'The taint for control plane nodes.'
        - macro: '{$KUBE.HTTP.PROXY}'
          description: 'Sets the HTTP proxy to `http_proxy` value. If this parameter is empty, then no proxy is used.'
          config:
            type: TEXT
            priority: '6'
            section_name: Other
            label: 'HTTP Proxy'
            description: 'HTTP proxy to use for requests.'
        - macro: '{$KUBE.KUBELET.FILTER.ANNOTATIONS}'
          description: 'Node annotations to filter Kubelets (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '24'
            section_name: Filters
            label: 'Kubelet Annotations Filter'
            description: 'Node annotations to filter Kubelets.'
        - macro: '{$KUBE.KUBELET.FILTER.LABELS}'
          description: 'Node labels to filter Kubelets (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '25'
            section_name: Filters
            label: 'Kubelet Labels Filter'
            description: 'Node labels to filter Kubelets.'
        - macro: '{$KUBE.KUBELET.PORT}'
          value: '10250'
          description: 'Kubernetes Kubelet metrics endpoint port. Used in Kubelet LLD.'
          config:
            type: TEXT
            priority: '17'
            label: 'Kubelet Port'
            description: 'The port for the Kubernetes Kubelet metrics endpoint. In the range from 1 to 65535 inclusive.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$KUBE.KUBELET.SCHEME}'
          value: https
          description: 'Kubernetes Kubelet metrics endpoint scheme. Used in Kubelet LLD.'
          config:
            type: LIST
            priority: '16'
            label: 'Kubelet Scheme'
            description: 'The scheme for the Kubernetes Kubelet metrics endpoint.'
            options:
              - value: https
                text: HTTPS
              - value: http
                text: HTTP
        - macro: '{$KUBE.LLD.FILTER.KUBELET_NODE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable Kubelets by nodename.'
          config:
            type: TEXT
            priority: '22'
            section_name: Filters
            label: 'Kubelet Node Matches Filter'
            description: 'A regex to filter discoverable Kubelets by nodename.'
        - macro: '{$KUBE.LLD.FILTER.KUBELET_NODE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered Kubelets by nodename.'
          config:
            type: TEXT
            priority: '23'
            section_name: Filters
            label: 'Kubelet Node Exclude Filter'
            description: 'A regex to exclude discovered Kubelets by nodename.'
        - macro: '{$KUBE.LLD.FILTER.NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable metrics by namespace.'
          config:
            type: TEXT
            priority: '18'
            section_name: Filters
            label: 'Namespace Matches Filter'
            description: 'A regex to filter discoverable metrics by namespace.'
        - macro: '{$KUBE.LLD.FILTER.NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered metrics by namespace.'
          config:
            type: TEXT
            priority: '19'
            section_name: Filters
            label: 'Namespace Exclude Filter'
            description: 'A regex to exclude discovered metrics by namespace.'
        - macro: '{$KUBE.LLD.FILTER.NODE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable nodes by nodename.'
          config:
            type: TEXT
            priority: '20'
            section_name: Filters
            label: 'Node Matches Filter'
            description: 'A regex to filter discoverable nodes by nodename.'
        - macro: '{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered nodes by nodename.'
          config:
            type: TEXT
            priority: '21'
            section_name: Filters
            label: 'Node Exclude Filter'
            description: 'A regex to exclude discovered nodes by nodename.'
        - macro: '{$KUBE.LLD.FILTER.PV.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable persistent volumes by name.'
          config:
            type: TEXT
            priority: '26'
            section_name: Filters
            label: 'Persistent Volume Matches Filter'
            description: 'A regex to filter discoverable persistent volumes by name.'
        - macro: '{$KUBE.LLD.FILTER.PV.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered persistent volumes by name.'
          config:
            type: TEXT
            priority: '27'
            section_name: Filters
            label: 'Persistent Volume Exclude Filter'
            description: 'A regex to exclude discovered persistent volumes by name.'
        - macro: '{$KUBE.REPLICA.MISMATCH.EVAL_PERIOD}'
          value: '#5'
          description: 'The evaluation period range which is used for calculation of expressions in trigger prototypes (time period or value range). Can be used with context.'
          config:
            type: TEXT
            priority: '28'
            section_name: Other
            label: 'Replica Mismatch Evaluation Period'
            description: 'The evaluation period range for trigger prototype calculations.'
        - macro: '{$KUBE.SCHEDULER.PORT}'
          value: '10259'
          description: 'Kubernetes Scheduler metrics endpoint port. Used in ControlPlane LLD.'
          config:
            type: TEXT
            priority: '15'
            label: 'Scheduler Port'
            description: 'The port for the Kubernetes Scheduler metrics endpoint. In the range from 1 to 65535 inclusive.'
            regex: '^-?([0-9]+|(([0-9]+)\.([0-9]+)))$'
        - macro: '{$KUBE.SCHEDULER.SCHEME}'
          value: https
          description: 'Kubernetes Scheduler metrics endpoint scheme. Used in ControlPlane LLD.'
          config:
            type: LIST
            priority: '14'
            label: 'Scheduler Scheme'
            description: 'The scheme for the Kubernetes Scheduler metrics endpoint.'
            options:
              - value: https
                text: HTTPS
              - value: http
                text: HTTP
        - macro: '{$KUBE.STATE.ENDPOINT.NAME}'
          value: zabbix-kube-state-metrics
          description: 'Endpoint name for kube-state-metrics service (check with `kubectl get ep -n monitoring -owide`).'
          config:
            type: TEXT
            priority: '7'
            label: 'State Endpoint Name'
            description: 'The name of the Kubernetes state endpoint.'
        - macro: '{$OPENSHIFT.STATE.ENDPOINT.NAME}'
          value: openshift-state-metrics
          description: 'OpenShift state endpoint name.'
          config:
            type: TEXT
            priority: '8'
            label: 'OpenShift State Endpoint Name'
            description: 'The name of the OpenShift state endpoint.'
      valuemaps:
        - uuid: a435f7e23050406ca40cf6f5f872b5a7
          name: 'Boolean format'
          mappings:
            - value: '0'
              newvalue: 'False'
            - value: '1'
              newvalue: 'True'
        - uuid: a315a447059e49f9bc0c3e2e9964696f
          name: 'Build status phases'
          mappings:
            - value: '1'
              newvalue: complete
            - value: '2'
              newvalue: cancelled
            - value: '3'
              newvalue: new
            - value: '4'
              newvalue: pending
            - value: '5'
              newvalue: running
            - value: '6'
              newvalue: failed
            - value: '7'
              newvalue: error
        - uuid: f5aa4a786972420b859029116aac8a2f
          name: 'PV and PVC status phases'
          mappings:
            - value: '1'
              newvalue: Available
            - value: '2'
              newvalue: Bound
            - value: '3'
              newvalue: Failed
            - value: '4'
              newvalue: Lost
            - value: '5'
              newvalue: Pending
            - value: '6'
              newvalue: Released
