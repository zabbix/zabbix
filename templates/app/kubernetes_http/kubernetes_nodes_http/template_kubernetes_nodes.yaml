zabbix_export:
  version: '8.0'
  template_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Templates/Applications
  host_groups:
    - uuid: a571c0d144b14fd4a87a9d9b2aa9fcd6
      name: Applications
  templates:
    - uuid: f397be2340734d24bc666102fbe184a5
      template: 'Kubernetes nodes by HTTP'
      name: 'Kubernetes nodes by HTTP'
      description: |
        Get Kubernetes nodes metrics by HTTP.
        Metrics are collected by requests to Kubernetes API.
        
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      wizard_ready: 'YES'
      readme: |
        ## Overview
        
        The template to monitor Kubernetes nodes that work without any external scripts.
        It works without external scripts and uses the script item to make HTTP requests to the Kubernetes API.
        
        Change the values according to the environment in the file $HOME/zabbix_values.yaml.
        
        For example:
        
        ## Enables use of **Zabbix proxy**
            enabled: false
        
        Set the field: `Kubernetes API URL` such as `<scheme>://<host>:<port>`.
        
        Get the generated service account token using the command:
        
        `kubectl get secret zabbix-zabbix-helm-chart -n monitoring -o jsonpath={.data.token} | base64 -d`
        
        Then set it to the field: `API Authorization Token`.
        
        Set up the fields to filter the metrics of discovered nodes.
        
        
        ## Setup
        
        Install the [Zabbix Helm Chart](https://git.zabbix.com/projects/ZT/repos/kubernetes-helm/browse?at=refs%2Fheads%2Fmaster) in your Kubernetes cluster.
        
        Set the following fields: `Kubernetes API URL` such as `<scheme>://<host>:<port>`.
        
        Get the generated service account token using the command:
        
        `kubectl get secret zabbix-zabbix-helm-chart -n monitoring -o jsonpath={.data.token} | base64 -d`
        
        Then set it to the field: `API Authorization Token`.
        
        Set `Nodes Endpoint Name` with Zabbix agent's endpoint name. See `kubectl -n monitoring get ep`. Default: `zabbix-zabbix-helm-chrt-agent`.
        
        Set up the fields to filter the metrics of discovered nodes and host creation based on host prototypes:
        
        - `Node Matches Filter`
        - `Node Exclusion Filter`
        - `Node Role Matches Filter`
        - `Node Role Exclusion Filter`
        
        Set up fields to filter pod metrics by namespace:
        
        - `Pod Namespace Matches Filter`
        - `Pod Namespace Exclusion Filter`
        
        **Note:** If you have a large cluster, it is highly recommended to set a filter for discoverable pods.
        
        You can use the `Node Labels Filter`, `Pod Labels Filter`, `Node Annotations Filter` and `Pod Annotations Filter` fields for advanced filtering of nodes and pods by labels and annotations.
        
        Notes about labels and annotations filters:
        
        - Values should be specified separated by commas and must have the key/value form with support for regular expressions in the value (`key1: value, key2: regexp`).
        - ECMAScript syntax is used for regular expressions.
        - Filters are applied if such a label key exists for the entity that is being filtered (it means that if you specify a key in a filter, entities which do not have this key will not be affected by the filter and will still be discovered, and only entities containing that key will be filtered by the value).
        - You can also use the exclamation point symbol (`!`) to invert the filter (`!key: value`).
        
        For example: `kubernetes.io/hostname: kubernetes-node[5-25], !node-role.kubernetes.io/ingress: .*`. As a result, the nodes 5-25 without the "ingress" role will be discovered.
        
        
        See the Kubernetes documentation for details about labels and annotations:
        
        - <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
        - <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/>
        
        **Note:** the discovered nodes will be created as separate hosts in Zabbix with the Linux template automatically assigned to them.
      vendor:
        name: Zabbix
        version: 8.0-2
      groups:
        - name: Templates/Applications
      items:
        - uuid: 70dab03a327a4dc0ab9fe8031052584d
          name: 'Get nodes'
          type: SCRIPT
          key: kube.nodes
          delay: 0;s00
          history: '0'
          value_type: TEXT
          params: |
            var Kube = {
            	params: {},
            	pods_limit: 1000,
            
            	setParams: function (params) {
            		['api_token', 'api_url'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined'
            				|| params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            		});
            		['endpoint_name', 'pod_filter_labels', 'pod_filter_annotations', 'node_filter_labels', 'node_filter_annotations'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined') {
            				throw 'Parameter can be empty but not removed: "' + field + '".';
            			}
            		});
            
            		Kube.params = params;
            		if (typeof Kube.params.api_url === 'string' && !Kube.params.api_url.endsWith('/')) {
            			Kube.params.api_url += '/';
            		}
            	},
            
            	apiRequest: function (query) {
            		var request = new HttpRequest(),
            			response,
            			url = encodeURI(Kube.params.api_url + query);
            		if (typeof Kube.params.http_proxy !== 'undefined' && Kube.params.http_proxy !== '') {
            			request.setProxy(Kube.params.http_proxy);
            		}
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Authorization: Bearer ' + Kube.params.api_token);
            
            		if (Kube.params.http_proxy) {
            			Zabbix.log(4, '[ Kubernetes ] Using http proxy: ' + Kube.params.http_proxy);
            		}
            		response = request.get(url);
            
            		Zabbix.log(4, '[ Kubernetes ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() < 200 || request.getStatus() >= 300) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		try {
            			response = JSON.parse(response);
            		}
            		catch (error) {
            			throw 'Failed to parse response received from Kubernetes API. Check debug log for more information.';
            		}
            		return response;
            	},
            
            	parseFilters: function (csv) {
            		if (!csv)
            			return [];
            
            		var filters = [];
            		const filterCapture = /([!\w\-\.\/]+)\s*:\s*(.*)/;
            		const onComma = /\s*,\s*/;
            
            		csv.split(onComma).forEach(function (kv) {
            			var match = kv.match(filterCapture);
            			if (!match) {
            				Zabbix.log(3, 'Cannot parse filter from: "' + kv + '"');
            				return;
            			}
            
            			filters.push({ key: match[1], expression: match[2] });
            		});
            
            		return filters;
            	},
            
            	filter: function (name, data, filters) {
            		if (typeof data !== 'object') {
            			return true;
            		}
            
            		return filters.every(function (filter) {
            			const filter_key = filter.key.startsWith('!') ? filter.key.substring(1) : filter.key;
            
            			if (!(filter_key in data)) {
            				return true;
            			}
            
            			const isExcludingFilter = filter.key.startsWith('!');
            			const isMatchForFilter = new RegExp(filter.expression).test(data[filter_key]);
            
            			if ((isExcludingFilter && isMatchForFilter) ||
            				(!isExcludingFilter && !isMatchForFilter)) {
            				Zabbix.log(4, '[ Kubernetes ] Discarded "' + name + '" by filter "' + filter.key + ': ' + filter.expression + '"');
            				return false;
            			}
            
            			return true;
            		});
            	},
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	getNodes: function () {
            		var result = Kube.apiRequest('api/v1/nodes'),
            			output = [],
            			filterNodeLabels = Kube.parseFilters(Kube.params.node_filter_labels),
            			filterNodeAnnotations = Kube.parseFilters(Kube.params.node_filter_annotations);
            		if (typeof result !== 'object'
            			|| typeof result.items === 'undefined') {
            			throw 'Cannot get nodes from Kubernetes API. Check debug log for more information.';
            		}
            
            		result.items.forEach(function (filternode) {
            			if (Kube.filter(Kube.getField(filternode, 'metadata.name'), Kube.getField(filternode, 'metadata.labels'), filterNodeLabels)
            				&& Kube.filter(Kube.getField(filternode, 'metadata.name'), Kube.getField(filternode, 'metadata.annotations'), filterNodeAnnotations)) {
            				Zabbix.log(4, '[ Kubernetes ] Filtered node "' + filternode.metadata.name + '"');
            
            				output.push({
            					filternode
            				});
            			}
            		});
            
            		return output;
            	},
            
            	getPods: function () {
            		var result = [],
            			continue_token,
            			Pods = [];
            
            		while (continue_token !== '') {
            			var data = Kube.apiRequest('api/v1/pods?limit=' + Kube.pods_limit
            				+ ((typeof continue_token !== 'undefined') ? '&continue=' + continue_token : ''));
            
            			if (typeof data !== 'object'
            				|| typeof data.items === 'undefined') {
            				throw 'Cannot get pods from Kubernetes API. Check debug log for more information.';
            			};
            
            			result.push.apply(result, data.items);
            			continue_token = data.metadata.continue || '';
            		}
            		result.forEach(function (pod) {
            
            			var containers = {
            				limits: { cpu: 0, memory: 0 },
            				requests: { cpu: 0, memory: 0 },
            				restartCount: 0
            			},
            				containerStatuses = [{ restartCount: 0 }];
            
            			if (typeof pod.status.hostIP === 'object'
            				|| typeof pod.status.hostIP === 'undefined') {
            				pod.status.hostIP = 'none';
            			};
            
            			Kube.getField(pod, 'spec.containers').forEach(function (container) {
            				var limits = container.resources.limits,
            					requests = container.resources.requests;
            
            				if (typeof limits !== 'undefined') {
            					containers.limits.cpu += Fmt.cpuFormat(limits.cpu);
            					containers.limits.memory += Fmt.memoryFormat(limits.memory);
            				}
            
            				if (typeof requests !== 'undefined') {
            					containers.requests.cpu += Fmt.cpuFormat(requests.cpu);
            					containers.requests.memory += Fmt.memoryFormat(requests.memory);
            				}
            			});
            
            			if (typeof pod.status.containerStatuses !== 'object'
            				|| typeof pod.status.containerStatuses === 'undefined') {
            				pod.status.containerStatuses = containerStatuses;
            			};
            			pod.status.containerStatuses.forEach(function (container) {
            				containers.restartCount += container.restartCount;
            
            			});
            
            			Pods.push({
            				'name': pod.metadata.name,
            				'nodeIP': pod.status.hostIP,
            				'namespace': pod.metadata.namespace,
            				'labels': pod.metadata.labels,
            				'annotations': pod.metadata.annotations,
            				'phase': pod.status.phase,
            				'conditions': pod.status.conditions,
            				'startTime': pod.status.startTime,
            				'containers': containers,
            				'hostname': 'none'
            			})
            		});
            		return Pods;
            	},
            
            	getEndpointIPs: function () {
            		var endpoints = Kube.apiRequest('api/v1/endpoints'),
            			endpointIPs = [];
            		if (typeof endpoints !== 'object'
            			|| typeof endpoints.items === 'undefined') {
            			throw 'Cannot get endpoints from Kubernetes API. Check debug log for more information.';
            		};
            
            		endpoints.items.forEach(function (ep) {
            			if (Kube.getField(ep, 'metadata.name') !== Kube.params.endpoint_name) {
            				return;
            			}
            			if (!Array.isArray(ep.subsets)) {
            				return;
            			}
            			endpointIPs = ep.subsets;
            
            		});
            		return endpointIPs;
            	}
            },
            
            	Fmt = {
            		factors: {
            			Ki: 1024, K: 1000,
            			Mi: 1024 ** 2, M: 1000 ** 2,
            			Gi: 1024 ** 3, G: 1000 ** 3,
            			Ti: 1024 ** 4, T: 1000 ** 4,
            		},
            
            		cpuFormat: function (cpu) {
            			if (typeof cpu === 'undefined') {
            				return 0;
            			}
            
            			if (cpu.indexOf('m') > -1) {
            				return parseInt(cpu) / 1000;
            			}
            
            			return parseInt(cpu);
            		},
            
            		memoryFormat: function (mem) {
            			if (typeof mem === 'undefined') {
            				return 0;
            			}
            
            			var pair,
            				factor;
            
            			if (pair = mem.match(/(\d+)(\w*)/)) {
            				if (factor = Fmt.factors[pair[2]]) {
            					return parseInt(pair[1]) * factor;
            				}
            
            				return mem;
            			}
            
            			return parseInt(mem);
            		}
            
            	}
            
            try {
            	Kube.setParams(JSON.parse(value));
            
            	var nodes = Kube.getNodes(),
            		pods = Kube.getPods(),
            		Pods = [],
            		hostname = Kube.params.api_url.match(/https?:\/\/([\w.-]+|\[[a-f0-9:]+\]|[^a-zA-Z:]+)(?::\d+)?/),
            		filterPodLabels = Kube.parseFilters(Kube.params.pod_filter_labels),
            		filterPodAnnotations = Kube.parseFilters(Kube.params.pod_filter_annotations),
            		endpointIPs = Kube.getEndpointIPs();
            	if (typeof hostname[1] === 'undefined') {
            		Zabbix.log(4, '[ Kubernetes ] Received incorrect Kubernetes API url: ' + api_url + '. Expected format: <scheme>://<host>:<port>');
            		throw 'Cannot get hostname from Kubernetes API url. Check debug log for more information.';
            	};
            	for (idx in nodes) {
            		var nodePodsCount = 0,
            			endpointpod = [],
            			roles = [];
            		Object.keys(nodes[idx].filternode.metadata.labels).forEach(function (label) {
            			var splitLabel = label.match(/^node-role.kubernetes.io\/([\w\.-]+)/);
            
            			if (splitLabel) {
            				roles.push(splitLabel[1]);
            			}
            		});
            		var internalIPs = Kube.getField(nodes[idx].filternode, 'status.addresses').filter(function (addr) {
            			return addr.type === 'InternalIP';
            		});
            		var internalIP = internalIPs.length && internalIPs[0].address;
            
            		var Hostname = Kube.getField(nodes[idx].filternode, 'status.addresses').filter(function (addr) {
            			return addr.type === 'Hostname';
            		});
            		var Hostname = Hostname.length && Hostname[0].address;
            
            		pods.forEach(function (pod) {
            			if (pod.nodeIP !== internalIP) {
            				return;
            			}
            			nodePodsCount++;
            			pod.hostname = Hostname;
            			Pods = pods.filter(function (f) {
            				return (f.hostname !== 'none' || f.phase === 'Pending') && (
            					Kube.filter(f.name, f.labels, filterPodLabels)
            					&& Kube.filter(f.name, f.annotations, filterPodAnnotations)
            				);
            			}
            			)
            		});
            
            		endpointIPs.forEach(function (agent) {
            			for (k in Kube.getField(agent, 'addresses')) {
            				if (Kube.getField(agent.addresses[k], 'ip') === internalIP) {
            					endpointpod = Kube.getField(agent.addresses[k], 'targetRef.name')
            				}
            				for (k in agent.notReadyAddresses) {
            					if (agent.notReadyAddresses[k].ip === internalIP) {
            						endpointpod = 'notReadyAddresses'
            					}
            				}
            
            			}
            		});
            
            		delete nodes[idx].filternode.metadata.managedFields;
            		delete nodes[idx].filternode.status.images;
            		nodes[idx].filternode.status.capacity.cpu = Fmt.cpuFormat(nodes[idx].filternode.status.capacity.cpu);
            		nodes[idx].filternode.status.capacity.memory = Fmt.memoryFormat(nodes[idx].filternode.status.capacity.memory);
            		nodes[idx].filternode.status.allocatable.cpu = Fmt.cpuFormat(nodes[idx].filternode.status.allocatable.cpu);
            		nodes[idx].filternode.status.allocatable.memory = Fmt.memoryFormat(nodes[idx].filternode.status.allocatable.memory);
            		nodes[idx].filternode.status.podsCount = nodePodsCount;
            		nodes[idx].filternode.status.roles = roles.join(', ');
            		nodes[idx].filternode.status.agent = endpointpod;
            		nodes[idx].filternode.internalIP = internalIP;
            		nodes[idx].filternode.clusterhostname = hostname[1];
            
            	}
            
            	return JSON.stringify({ nodes, Pods });
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ Kubernetes ] ERROR: ' + error);
            	return JSON.stringify({ error: error });
            }
          description: 'Collecting and processing cluster nodes data via Kubernetes API.'
          timeout: 10s
          parameters:
            - name: api_token
              value: '{$KUBE.API.TOKEN}'
            - name: api_url
              value: '{$KUBE.API.URL}'
            - name: endpoint_name
              value: '{$KUBE.NODES.ENDPOINT.NAME}'
            - name: http_proxy
              value: '{$KUBE.HTTP.PROXY}'
            - name: node_filter_annotations
              value: '{$KUBE.NODE.FILTER.ANNOTATIONS}'
            - name: node_filter_labels
              value: '{$KUBE.NODE.FILTER.LABELS}'
            - name: pod_filter_annotations
              value: '{$KUBE.POD.FILTER.ANNOTATIONS}'
            - name: pod_filter_labels
              value: '{$KUBE.POD.FILTER.LABELS}'
          tags:
            - tag: component
              value: raw
        - uuid: f78df5e88780418b894017086f8d9641
          name: 'Get nodes check'
          type: DEPENDENT
          key: kube.nodes.check
          value_type: CHAR
          description: 'Data collection check.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: kube.nodes
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 827016cf41254f38aa58ff99e22f9e6f
              expression: 'length(last(/Kubernetes nodes by HTTP/kube.nodes.check))>0'
              name: 'Kubernetes nodes: Failed to get nodes'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
      discovery_rules:
        - uuid: f408d71f02f645f6a7e24047a57860b6
          name: 'Node discovery'
          type: DEPENDENT
          key: kube.node.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.NODE.MATCHES}'
              - macro: '{#NAME}'
                value: '{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#ROLES}'
                value: '{$KUBE.LLD.FILTER.NODE.ROLE.MATCHES}'
              - macro: '{#ROLES}'
                value: '{$KUBE.LLD.FILTER.NODE.ROLE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          item_prototypes:
            - uuid: 6f986c54ff744522abd793347dba5148
              name: 'Node [{#NAME}] Addresses: External IP'
              type: DEPENDENT
              key: 'kube.node.addresses.external_ip[{#NAME}]'
              value_type: CHAR
              description: 'Typically the IP address of the node that is externally routable (available from outside the cluster).'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.addresses[?(@.type == "ExternalIP")].address.first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: addresses
                - tag: node
                  value: '{#NAME}'
            - uuid: a6bb3067ed44446e9b4831f5be57661b
              name: 'Node [{#NAME}] Addresses: Internal IP'
              type: DEPENDENT
              key: 'kube.node.addresses.internal_ip[{#NAME}]'
              value_type: CHAR
              description: 'Typically the IP address of the node that is routable only within the cluster.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.addresses[?(@.type == "InternalIP")].address.first()'
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: addresses
                - tag: node
                  value: '{#NAME}'
            - uuid: 57eb59ad6e63466f993cd7064788c75d
              name: 'Node [{#NAME}] Allocatable: CPU'
              type: DEPENDENT
              key: 'kube.node.allocatable.cpu[{#NAME}]'
              value_type: FLOAT
              description: |
                Allocatable CPU.
                
                'Allocatable' on a Kubernetes node is defined as the amount of compute resources that are available for pods. The scheduler does not over-subscribe 'Allocatable'. 'CPU', 'memory' and 'ephemeral-storage' are supported as of now.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.allocatable.cpu
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: allocatable
                - tag: node
                  value: '{#NAME}'
            - uuid: 843ecf5ca78148caa49f3b4cca26e4d4
              name: 'Node [{#NAME}] Allocatable: Memory'
              type: DEPENDENT
              key: 'kube.node.allocatable.memory[{#NAME}]'
              units: B
              description: |
                Allocatable Memory.
                
                'Allocatable' on a Kubernetes node is defined as the amount of compute resources that are available for pods. The scheduler does not over-subscribe 'Allocatable'. 'CPU', 'memory' and 'ephemeral-storage' are supported as of now.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.allocatable.memory
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: allocatable
                - tag: node
                  value: '{#NAME}'
            - uuid: be853c34395643af828e349105e2feba
              name: 'Node [{#NAME}] Allocatable: Pods'
              type: DEPENDENT
              key: 'kube.node.allocatable.pods[{#NAME}]'
              description: 'https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.allocatable.pods
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: allocatable
                - tag: node
                  value: '{#NAME}'
            - uuid: 96c25644261446afb70ce874ff1c7b7d
              name: 'Node [{#NAME}] Capacity: CPU'
              type: DEPENDENT
              key: 'kube.node.capacity.cpu[{#NAME}]'
              value_type: FLOAT
              description: |
                CPU resource capacity.
                
                https://kubernetes.io/docs/concepts/architecture/nodes/#capacity
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.capacity.cpu
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: capacity
                - tag: node
                  value: '{#NAME}'
            - uuid: e890e682c3454d20b7cd3becc950279f
              name: 'Node [{#NAME}] Capacity: Memory'
              type: DEPENDENT
              key: 'kube.node.capacity.memory[{#NAME}]'
              units: B
              description: |
                Memory resource capacity.
                
                https://kubernetes.io/docs/concepts/architecture/nodes/#capacity
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.capacity.memory
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: capacity
                - tag: node
                  value: '{#NAME}'
            - uuid: f45997b967964ed29c29b64b94544a48
              name: 'Node [{#NAME}] Capacity: Pods'
              type: DEPENDENT
              key: 'kube.node.capacity.pods[{#NAME}]'
              description: 'https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.capacity.pods
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: capacity
                - tag: node
                  value: '{#NAME}'
            - uuid: ad5f8baa9ff44ca0ba17fc83e197420e
              name: 'Node [{#NAME}] Conditions: Disk pressure'
              type: DEPENDENT
              key: 'kube.node.conditions.diskpressure[{#NAME}]'
              description: 'True if pressure exists on the disk size - that is, if the disk capacity is low; otherwise False.'
              valuemap:
                name: 'Node conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.conditions[?(@.type == "DiskPressure")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: conditions
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 4e283f3f104a4239a0b1c24f0313ab95
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.conditions.diskpressure[{#NAME}])=1'
                  name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the disk size'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the disk size (state: {ITEM.VALUE})'
                  priority: WARNING
                  description: 'True - pressure exists on the disk size - that is, if the disk capacity is low; otherwise False.'
                  tags:
                    - tag: scope
                      value: performance
            - uuid: 44b60c111e2a4d0bae0de443394d0add
              name: 'Node [{#NAME}] Conditions: Memory pressure'
              type: DEPENDENT
              key: 'kube.node.conditions.memorypressure[{#NAME}]'
              description: 'True if pressure exists on the node memory - that is, if the node memory is low; otherwise False.'
              valuemap:
                name: 'Node conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.conditions[?(@.type == "MemoryPressure")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: conditions
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: f580b6534bf54281912515874ca46cdf
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.conditions.memorypressure[{#NAME}])=1'
                  name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the node memory'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the node memory (state: {ITEM.VALUE})'
                  priority: WARNING
                  description: 'True - pressure exists on the node memory - that is, if the node memory is low; otherwise False'
                  tags:
                    - tag: scope
                      value: performance
            - uuid: 8c77db54e90d474a8ff35a98c67772d5
              name: 'Node [{#NAME}] Conditions: Network unavailable'
              type: DEPENDENT
              key: 'kube.node.conditions.networkunavailable[{#NAME}]'
              description: 'True if the network for the node is not correctly configured, otherwise False.'
              valuemap:
                name: 'Node conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.conditions[?(@.type == "NetworkUnavailable")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: conditions
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 0da0db08077a42668efcc886c155bf4e
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.conditions.networkunavailable[{#NAME}])=1'
                  name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Network is not correctly configured'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Network is not correctly configured (state: {ITEM.VALUE})'
                  priority: WARNING
                  description: 'True - the network for the node is not correctly configured, otherwise False'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: 31f02b4517e24571962fefd61e09e2a5
              name: 'Node [{#NAME}] Conditions: PID pressure'
              type: DEPENDENT
              key: 'kube.node.conditions.pidpressure[{#NAME}]'
              description: 'True if pressure exists on the processes - that is, if there are too many processes on the node; otherwise False.'
              valuemap:
                name: 'Node conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.conditions[?(@.type == "PIDPressure")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: conditions
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 5f6a7fce910e4cf79e9fc778519ad00f
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.conditions.pidpressure[{#NAME}])=1'
                  name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the processes'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Pressure exists on the processes (state: {ITEM.VALUE})'
                  priority: WARNING
                  description: 'True - pressure exists on the processes - that is, if there are too many processes on the node; otherwise False'
                  tags:
                    - tag: scope
                      value: performance
            - uuid: 9341a018a45848feae0f61660ca5f849
              name: 'Node [{#NAME}] Conditions: Ready'
              type: DEPENDENT
              key: 'kube.node.conditions.ready[{#NAME}]'
              description: 'True if the node is healthy and ready to accept pods, False if the node is not healthy and is not accepting pods, and Unknown if the node controller has not heard from the node in the last node-monitor-grace-period (default is 40 seconds).'
              valuemap:
                name: 'Node conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.status.conditions[?(@.type == "Ready")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: conditions
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: 02f873ab69fb4df49578cf5e1cbad1b8
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.conditions.ready[{#NAME}])<>1'
                  name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Is not in Ready state'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] Conditions: Is not in Ready state (state: {ITEM.VALUE})'
                  priority: WARNING
                  description: |
                    False - if the node is not healthy and is not accepting pods.
                    Unknown - if the node controller has not heard from the node in the last node-monitor-grace-period (default is 40 seconds).
                  tags:
                    - tag: scope
                      value: availability
            - uuid: 3d8536659ac44347b36e61f60873fa61
              name: 'Node [{#NAME}]: Get data'
              type: DEPENDENT
              key: 'kube.node.get[{#NAME}]'
              history: '0'
              value_type: CHAR
              description: 'Collecting and processing cluster by node [{#NAME}] data via Kubernetes API.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.nodes..[?(@.metadata.name == "{#NAME}")].first()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: raw
                - tag: node
                  value: '{#NAME}'
            - uuid: 8f9152074e2041d7b5cd2c6215e06832
              name: 'Node [{#NAME}] Info: Architecture'
              type: DEPENDENT
              key: 'kube.node.info.architecture[{#NAME}]'
              value_type: CHAR
              description: 'Node architecture.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.architecture
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: 405fe8cae9be4ea8888f378dadda8946
              name: 'Node [{#NAME}] Info: Container runtime'
              type: DEPENDENT
              key: 'kube.node.info.containerruntime[{#NAME}]'
              value_type: CHAR
              description: |
                Container runtime.
                
                https://kubernetes.io/docs/setup/production-environment/container-runtimes/
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.containerRuntimeVersion
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: a14e705e142f4c34bfc9175686b18754
              name: 'Node [{#NAME}] Info: Kernel version'
              type: DEPENDENT
              key: 'kube.node.info.kernelversion[{#NAME}]'
              value_type: CHAR
              description: 'Node kernel version.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.kernelVersion
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: f1a1ea522dfd49d09a69b9b014845f7a
              name: 'Node [{#NAME}] Info: Kubelet version'
              type: DEPENDENT
              key: 'kube.node.info.kubeletversion[{#NAME}]'
              value_type: CHAR
              description: 'Version of Kubelet.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.kubeletVersion
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: d39865e0754b4280926b89f19dddb740
              name: 'Node [{#NAME}] Info: KubeProxy version'
              type: DEPENDENT
              key: 'kube.node.info.kubeproxyversion[{#NAME}]'
              value_type: CHAR
              description: 'Version of KubeProxy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.kubeProxyVersion
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: fe06e13c3aec4efc8f7c9539b6600097
              name: 'Node [{#NAME}] Info: Operating system'
              type: DEPENDENT
              key: 'kube.node.info.operatingsystem[{#NAME}]'
              value_type: CHAR
              description: 'Node operating system.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.operatingSystem
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: 1b25ffe6190c408996b87622b7b87329
              name: 'Node [{#NAME}] Info: OS image'
              type: DEPENDENT
              key: 'kube.node.info.osversion[{#NAME}]'
              value_type: CHAR
              description: 'Node OS image.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.nodeInfo.kernelVersion
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: bcd18bdb8cd1466fa81bbe2e75ba996c
              name: 'Node [{#NAME}] Info: Roles'
              type: DEPENDENT
              key: 'kube.node.info.roles[{#NAME}]'
              value_type: CHAR
              description: 'Node roles.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.roles
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: info
                - tag: node
                  value: '{#NAME}'
            - uuid: 1fb0ebd40fcb4e6c8a22bb646191adb2
              name: 'Node [{#NAME}] Limits: CPU'
              type: DEPENDENT
              key: 'kube.node.limits.cpu[{#NAME}]'
              value_type: FLOAT
              description: |
                Node CPU limits.
                
                https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.Pods[?(@.hostname == "{#NAME}")].containers.limits.cpu.sum()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: limits
                - tag: node
                  value: '{#NAME}'
            - uuid: e3ad703e83724cc7a5b918d9efae6e62
              name: 'Node [{#NAME}] Limits: Memory'
              type: DEPENDENT
              key: 'kube.node.limits.memory[{#NAME}]'
              units: B
              description: |
                Node Memory limits.
                
                https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.Pods[?(@.hostname == "{#NAME}")].containers.limits.memory.sum()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: limits
                - tag: node
                  value: '{#NAME}'
            - uuid: 8ea2954c99cc4e22a82c5a333146d936
              name: 'Node [{#NAME}] Requests: CPU'
              type: DEPENDENT
              key: 'kube.node.requests.cpu[{#NAME}]'
              value_type: FLOAT
              description: |
                Node CPU requests.
                
                https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.Pods[?(@.hostname == "{#NAME}")].containers.requests.cpu.sum()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: requests
                - tag: node
                  value: '{#NAME}'
            - uuid: 32f2f1d3ad084c6c9bbb96ad2fe9d98d
              name: 'Node [{#NAME}] Requests: Memory'
              type: DEPENDENT
              key: 'kube.node.requests.memory[{#NAME}]'
              units: B
              description: |
                Node Memory requests.
                
                https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.Pods[?(@.hostname == "{#NAME}")].containers.requests.memory.sum()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: requests
                - tag: node
                  value: '{#NAME}'
            - uuid: 0e30ed9718a54eb1ac643ac643471ca2
              name: 'Node [{#NAME}] Uptime'
              type: DEPENDENT
              key: 'kube.node.uptime[{#NAME}]'
              units: s
              description: 'Node uptime.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.metadata.creationTimestamp
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return Math.floor((Date.now() - new Date(value)) / 1000);'
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: uptime
                - tag: node
                  value: '{#NAME}'
              trigger_prototypes:
                - uuid: b322a8c9a4404da49c434e78822d6ac5
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.uptime[{#NAME}])<10'
                  name: 'Kubernetes nodes: Node [{#NAME}] has been restarted'
                  event_name: 'Kubernetes nodes: Node [{#NAME}] has been restarted (uptime < 10m)'
                  priority: INFO
                  description: 'Uptime is less than 10 minutes.'
                  tags:
                    - tag: scope
                      value: notice
            - uuid: 0203ec4fb37a4eb180edcba398bf470d
              name: 'Node [{#NAME}] Used: Pods'
              type: DEPENDENT
              key: 'kube.node.used.pods[{#NAME}]'
              description: 'Current number of pods on the node.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.status.podsCount
              master_item:
                key: 'kube.node.get[{#NAME}]'
              tags:
                - tag: component
                  value: used
                - tag: node
                  value: '{#NAME}'
          trigger_prototypes:
            - uuid: f64efc13be2c4c53a48de40504cf064d
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 0.9'
              name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total CPU limits are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total CPU limits are too high (more than 90% of allocatable)'
              opdata: 'Limits: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: WARNING
              dependencies:
                - name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total CPU limits are too high'
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 1'
              tags:
                - tag: scope
                  value: performance
            - uuid: 4c035b6c85574141832691e7ad264f40
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 1'
              name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total CPU limits are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total CPU limits are too high (more than 100% of allocatable)'
              opdata: 'Limits: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              tags:
                - tag: scope
                  value: performance
            - uuid: 5d0d803cfbbe42edb7d32d731ae5f741
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 0.9'
              name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total memory limits are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total memory limits are too high (more than 90% of allocatable)'
              opdata: 'Limits: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: WARNING
              dependencies:
                - name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total memory limits are too high'
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 1'
              tags:
                - tag: scope
                  value: performance
            - uuid: 4fa15174194c476899a96fcf233a5aea
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.limits.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 1'
              name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total memory limits are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Limits: Total memory limits are too high (more than 100% of allocatable)'
              opdata: 'Limits: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              tags:
                - tag: scope
                  value: performance
            - uuid: 256cf876a4674dd09123bb388c1a9d32
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 0.5'
              name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total CPU requests are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total CPU requests are too high (more than 50% of allocatable)'
              opdata: 'Requests: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: WARNING
              dependencies:
                - name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total CPU requests are too high'
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 0.8'
              tags:
                - tag: scope
                  value: performance
            - uuid: 7fa6901f620c4b388d550c669089dde2
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.cpu[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.cpu[{#NAME}]) > 0.8'
              name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total CPU requests are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total CPU requests are too high (more than 80% of allocatable)'
              opdata: 'Requests: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              tags:
                - tag: scope
                  value: performance
            - uuid: d73aa5aa2a9b424789181033630bb432
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 0.5'
              name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total memory requests are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total memory requests are too high (more than 50% of allocatable)'
              opdata: 'Requests: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: WARNING
              dependencies:
                - name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total memory requests are too high'
                  expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 0.8'
              tags:
                - tag: scope
                  value: performance
            - uuid: ad9a65c4786e48b9a4b77c1214fa2e1f
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.requests.memory[{#NAME}]) / last(/Kubernetes nodes by HTTP/kube.node.allocatable.memory[{#NAME}]) > 0.8'
              name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total memory requests are too high'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Requests: Total memory requests are too high (more than 80% of allocatable)'
              opdata: 'Requests: {ITEM.LASTVALUE1}, Allocatable: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              tags:
                - tag: scope
                  value: performance
            - uuid: 0126dfbfa9d949499e0f7689b714c855
              expression: 'last(/Kubernetes nodes by HTTP/kube.node.used.pods[{#NAME}])/ last(/Kubernetes nodes by HTTP/kube.node.capacity.pods[{#NAME}]) > 0.9'
              name: 'Kubernetes nodes: Node [{#NAME}] Used: Kubelet too many pods'
              event_name: 'Kubernetes nodes: Node [{#NAME}] Used: Kubelet too many pods (more than 95% of capacity)'
              opdata: 'Used: {ITEM.LASTVALUE1}, Capacity: {ITEM.LASTVALUE2}'
              priority: WARNING
              description: 'Kubelet is running at capacity.'
              tags:
                - tag: scope
                  value: performance
          graph_prototypes:
            - uuid: 646efb7b19f5408dba2f3fe2d6a92213
              name: 'Node [{#NAME}] Allocatable: Pod limits'
              graph_items:
                - sortorder: '1'
                  drawtype: BOLD_LINE
                  color: 4CAF50
                  item:
                    host: 'Kubernetes nodes by HTTP'
                    key: 'kube.node.allocatable.pods[{#NAME}]'
                - sortorder: '2'
                  drawtype: BOLD_LINE
                  color: AB47BC
                  item:
                    host: 'Kubernetes nodes by HTTP'
                    key: 'kube.node.capacity.pods[{#NAME}]'
                - sortorder: '3'
                  drawtype: GRADIENT_LINE
                  color: 1E88E5
                  calc_fnc: MAX
                  item:
                    host: 'Kubernetes nodes by HTTP'
                    key: 'kube.node.used.pods[{#NAME}]'
          host_prototypes:
            - uuid: bfcbf26edd704bdfaa65e244a987839e
              host: '{#NAME}'
              name: '{#NAME}'
              status: DISABLED
              discover: NO_DISCOVER
              group_links:
                - group:
                    name: Applications
              group_prototypes:
                - name: '{#CLUSTER_HOSTNAME}: Kubernetes/Nodes/Role: {#ROLES}'
              templates:
                - name: 'Linux by Zabbix agent'
              macros:
                - macro: '{$VFS.FS.FSNAME.NOT_MATCHES}'
                  value: ^/(dev|sys|run|proc|etc/.+|.+/shm|hostfs/root/var/lib/docker/.+)$
                  description: 'This macro is used in filesystems discovery. Can be overridden on the host or linked template level'
                - macro: '{$VFS.FS.FSTYPE.NOT_MATCHES}'
                  value: ^(autofs|binfmt_misc|cgroup|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|mqueue|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|sysfs|tracefs)$
                  description: 'This macro is used in filesystems discovery. Can be overridden on the host or linked template level'
              tags:
                - tag: addr
                  value: '{#IP}'
                - tag: arch
                  value: '{#ARCH}'
                - tag: os
                  value: '{#OS}'
                - tag: roles
                  value: '{#ROLES}'
              custom_interfaces: 'YES'
              interfaces:
                - ip: '{#IP}'
          master_item:
            key: kube.nodes
          lld_macro_paths:
            - lld_macro: '{#ARCH}'
              path: '$.metadata.labels[''kubernetes.io/arch'']'
            - lld_macro: '{#CLUSTER_HOSTNAME}'
              path: $.clusterhostname
            - lld_macro: '{#ENDPOINT}'
              path: $.status.agent
            - lld_macro: '{#IP}'
              path: $.internalIP
            - lld_macro: '{#NAME}'
              path: $.metadata.name
            - lld_macro: '{#OS}'
              path: '$.metadata.labels[''kubernetes.io/os'']'
            - lld_macro: '{#ROLES}'
              path: $.status.roles
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.nodes..filternode
          overrides:
            - name: 'Endpoints host'
              step: '1'
              filter:
                conditions:
                  - macro: '{#ENDPOINT}'
                    value: 'zabbix-helm-chart-agent.*'
              operations:
                - operationobject: HOST_PROTOTYPE
                  operator: REGEXP
                  discover: DISCOVER
                  status: ENABLED
        - uuid: b9dd5b50208e415da509f61ec73451c1
          name: 'Pod discovery'
          type: DEPENDENT
          key: kube.pod.discovery
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.POD.NAMESPACE.MATCHES}'
              - macro: '{#NAMESPACE}'
                value: '{$KUBE.LLD.FILTER.POD.NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
              - macro: '{#NODE}'
                value: '{$KUBE.LLD.FILTER.NODE.MATCHES}'
              - macro: '{#NODE}'
                value: '{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
          lifetime: '0'
          item_prototypes:
            - uuid: ed4ea3dbbce74404a5039aa9918b8e2b
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Conditions: Containers ready'
              type: DEPENDENT
              key: 'kube.pod.conditions.containers_ready[{#NAMESPACE}/{#POD}]'
              description: |
                All containers in the Pod are ready.
                
                https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions
              valuemap:
                name: 'Pod conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.conditions[?(@.type == "ContainersReady")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: conditions
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
            - uuid: 647ca68c325742d083e37c05e2826205
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Conditions: Initialized'
              type: DEPENDENT
              key: 'kube.pod.conditions.initialized[{#NAMESPACE}/{#POD}]'
              description: |
                All init containers have started successfully.
                
                https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions
              valuemap:
                name: 'Pod conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.conditions[?(@.type == "Initialized")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: conditions
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
            - uuid: b73a5c5d3b614815be157eb53c6afb1f
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Conditions: Ready'
              type: DEPENDENT
              key: 'kube.pod.conditions.ready[{#NAMESPACE}/{#POD}]'
              description: |
                The Pod is able to serve requests and should be added to the load balancing pools of all matching Services.
                
                https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions
              valuemap:
                name: 'Pod conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.conditions[?(@.type == "Ready")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: conditions
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
            - uuid: 5956cd1780604f0793efd7bbce2559b6
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Conditions: Scheduled'
              type: DEPENDENT
              key: 'kube.pod.conditions.scheduled[{#NAMESPACE}/{#POD}]'
              description: |
                The Pod has been scheduled to a node.
                
                https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions
              valuemap:
                name: 'Pod conditions'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.conditions[?(@.type == "PodScheduled")].status.first()'
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''True'', ''False'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: conditions
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
            - uuid: 5fd018faebb84462bf8111861795b04e
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Containers: Restarts'
              type: DEPENDENT
              key: 'kube.pod.containers.restartcount[{#NAMESPACE}/{#POD}]'
              description: 'The number of times the container has been restarted, currently based on the number of dead containers that have not yet been removed. Note that this is calculated from dead containers. But those containers are subject to garbage collection.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.containers.restartCount
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: container
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
              trigger_prototypes:
                - uuid: 8f1808cd67614cda959ec70e92a59235
                  expression: '(last(/Kubernetes nodes by HTTP/kube.pod.containers.restartcount[{#NAMESPACE}/{#POD}])-min(/Kubernetes nodes by HTTP/kube.pod.containers.restartcount[{#NAMESPACE}/{#POD}],15m))>1'
                  name: 'Kubernetes nodes: Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}]: Pod is crash looping'
                  priority: WARNING
                  description: 'Containers of the pod keep restarting. This most likely indicates that the pod is in the CrashLoopBackOff state.'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: 34a542538cf449f287a99052870988be
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}]: Get data'
              type: DEPENDENT
              key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              history: '0'
              value_type: CHAR
              description: 'Collecting and processing cluster by node [{#NODE}] data via Kubernetes API.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.Pods[?(@.name == "{#POD}" && @.namespace == "{#NAMESPACE}")].first()'
              master_item:
                key: kube.nodes
              tags:
                - tag: component
                  value: raw
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
            - uuid: 6862be81e52b4abcb319a8847b022634
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Status: Phase'
              type: DEPENDENT
              key: 'kube.pod.status.phase[{#NAMESPACE}/{#POD}]'
              description: |
                The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
                
                https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
              valuemap:
                name: 'Pod phase'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.phase
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return [''Pending'', ''Running'', ''Succeeded'', ''Failed'', ''Unknown''].indexOf(value) + 1 || ''Problem with status processing in JS'';'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: pod
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
              trigger_prototypes:
                - uuid: e565d243bef84007b09addb22ea3d759
                  expression: 'count(/Kubernetes nodes by HTTP/kube.pod.status.phase[{#NAMESPACE}/{#POD}],10m, "regexp","^(1|4|5)$")>=9'
                  name: 'Kubernetes nodes: Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}] Status: Kubernetes Pod not healthy'
                  priority: HIGH
                  description: 'Pod has been in a non-ready state for longer than 10 minutes.'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: abb0b84204164301bb9fc6ab14284631
              name: 'Node [{#NODE}] Namespace [{#NAMESPACE}] Pod [{#POD}]: Uptime'
              type: DEPENDENT
              key: 'kube.pod.uptime[{#NAMESPACE}/{#POD}]'
              units: s
              description: 'Pod uptime.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.startTime
                  error_handler: DISCARD_VALUE
                - type: JAVASCRIPT
                  parameters:
                    - 'return Math.floor((Date.now() - new Date(value)) / 1000);'
              master_item:
                key: 'kube.pod.get[{#NAMESPACE}/{#POD}]'
              tags:
                - tag: component
                  value: uptime
                - tag: namespace
                  value: '{#NAMESPACE}'
                - tag: node
                  value: '{#NODE}'
                - tag: pod
                  value: '{#POD}'
          master_item:
            key: kube.nodes
          lld_macro_paths:
            - lld_macro: '{#NAMESPACE}'
              path: $.namespace
            - lld_macro: '{#NODE}'
              path: $.hostname
            - lld_macro: '{#POD}'
              path: $.name
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.Pods
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: subclass
          value: automation
        - tag: subclass
          value: containers
        - tag: subclass
          value: deploy
        - tag: subclass
          value: development
        - tag: subclass
          value: virtualization
        - tag: target
          value: kubernetes
        - tag: target
          value: nodes
      macros:
        - macro: '{$KUBE.API.TOKEN}'
          type: SECRET_TEXT
          description: 'Service account bearer token.'
          config:
            type: TEXT
            priority: '1'
            label: 'API Authorization Token'
            description: 'Service account bearer token for authentication.'
            required: 'YES'
        - macro: '{$KUBE.API.URL}'
          value: 'https://kubernetes.default.svc.cluster.local:443'
          description: 'Kubernetes API endpoint URL in the format <scheme>://<host>:<port>'
          config:
            type: TEXT
            priority: '2'
            label: 'Kubernetes API URL'
            description: 'The Kubernetes API endpoint URL.'
            required: 'YES'
        - macro: '{$KUBE.HTTP.PROXY}'
          description: 'Sets the HTTP proxy to `http_proxy` value. If this parameter is empty, then no proxy is used.'
          config:
            type: TEXT
            priority: '3'
            label: 'HTTP Proxy'
            description: 'HTTP proxy to use for requests.'
        - macro: '{$KUBE.LLD.FILTER.NODE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable nodes.'
          config:
            type: TEXT
            priority: '5'
            section_name: Filters
            label: 'Node Matches Filter'
            description: 'A regex to filter discoverable nodes.'
        - macro: '{$KUBE.LLD.FILTER.NODE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered nodes.'
          config:
            type: TEXT
            priority: '6'
            section_name: Filters
            label: 'Node Exclusion Filter'
            description: 'A regex to exclude discovered nodes.'
        - macro: '{$KUBE.LLD.FILTER.NODE.ROLE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable nodes by role.'
          config:
            type: TEXT
            priority: '7'
            section_name: Filters
            label: 'Node Role Matches Filter'
            description: 'A regex to filter discoverable nodes by role.'
        - macro: '{$KUBE.LLD.FILTER.NODE.ROLE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered node by role.'
          config:
            type: TEXT
            priority: '8'
            section_name: Filters
            label: 'Node Role Exclusion Filter'
            description: 'A regex to exclude discovered nodes by role.'
        - macro: '{$KUBE.LLD.FILTER.POD.NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable pods by namespace.'
          config:
            type: TEXT
            priority: '13'
            section_name: Filters
            label: 'Pod Namespace Matches Filter'
            description: 'A regex to filter discoverable pods by namespace.'
        - macro: '{$KUBE.LLD.FILTER.POD.NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered pods by namespace.'
          config:
            type: TEXT
            priority: '14'
            section_name: Filters
            label: 'Pod Namespace Exclusion Filter'
            description: 'A regex to exclude discovered pods by namespace.'
        - macro: '{$KUBE.NODE.FILTER.ANNOTATIONS}'
          description: 'Annotations to filter nodes (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '9'
            section_name: Filters
            label: 'Node Annotations Filter'
            description: 'Annotations to filter nodes.'
        - macro: '{$KUBE.NODE.FILTER.LABELS}'
          description: 'Labels to filter nodes (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '10'
            section_name: Filters
            label: 'Node Labels Filter'
            description: 'Labels to filter nodes.'
        - macro: '{$KUBE.NODES.ENDPOINT.NAME}'
          value: zabbix-zabbix-helm-chart-agent
          description: 'Kubernetes nodes endpoint name. See "kubectl -n monitoring get ep".'
          config:
            type: TEXT
            priority: '4'
            label: 'Nodes Endpoint Name'
            description: 'The Kubernetes nodes endpoint name.'
        - macro: '{$KUBE.POD.FILTER.ANNOTATIONS}'
          description: 'Annotations to filter pods (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '11'
            section_name: Filters
            label: 'Pod Annotations Filter'
            description: 'Annotations to filter pods.'
        - macro: '{$KUBE.POD.FILTER.LABELS}'
          description: 'Labels to filter Pods (regex in values are supported). See the template''s README.md for details.'
          config:
            type: TEXT
            priority: '12'
            section_name: Filters
            label: 'Pod Labels Filter'
            description: 'Labels to filter pods.'
      valuemaps:
        - uuid: 785b20f8979341c4b470870ec8f50414
          name: 'Node conditions'
          mappings:
            - value: '1'
              newvalue: 'True'
            - value: '2'
              newvalue: 'False'
            - value: '3'
              newvalue: Unknown
        - uuid: f93e30e125de4909b52e7c38bc3f2c97
          name: 'Pod conditions'
          mappings:
            - value: '1'
              newvalue: 'True'
            - value: '2'
              newvalue: 'False'
            - value: '3'
              newvalue: Unknown
        - uuid: 21ff77dde5964dcfb4bb2ae202a5f33c
          name: 'Pod phase'
          mappings:
            - value: '1'
              newvalue: Pending
            - value: '2'
              newvalue: Running
            - value: '3'
              newvalue: Succeeded
            - value: '4'
              newvalue: Failed
            - value: '5'
              newvalue: Unknown
